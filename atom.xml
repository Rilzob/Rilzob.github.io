<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极氙世界</title>
  <icon>https://www.gravatar.com/avatar/01a8e9aa2bb51f443bf32f125ff052ed</icon>
  <subtitle>追求梦想，永不止步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rilzob.com/"/>
  <updated>2018-11-26T09:16:51.369Z</updated>
  <id>https://rilzob.com/</id>
  
  <author>
    <name>Rilzob</name>
    <email>watermirrorsir@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐系统实践读书笔记（三）</title>
    <link href="https://rilzob.com/2018/11/26/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://rilzob.com/2018/11/26/推荐系统实践读书笔记（三）/</id>
    <published>2018-11-26T06:35:08.655Z</published>
    <updated>2018-11-26T09:16:51.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-推荐系统冷启动问题"><a href="#第3章-推荐系统冷启动问题" class="headerlink" title="第3章 推荐系统冷启动问题"></a>第3章 推荐系统冷启动问题</h1><p>如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对推荐结果满意从而愿意使用推荐系统，就是<strong>冷启动</strong>的问题。<br>本章简单介绍一下冷启动问题的分类，以及如何解决不同种类的冷启动问题。<br><a id="more"></a></p><h2 id="3-1-冷启动问题简介"><a href="#3-1-冷启动问题简介" class="headerlink" title="3.1 冷启动问题简介"></a>3.1 冷启动问题简介</h2><p>冷启动问题(cold start)主要分3类。</p><ul><li><strong>用户冷启动</strong> 用户冷启动主要解决如何给新用户做个性化推荐的问题。</li><li><strong>物品冷启动</strong> 物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。</li><li><strong>系统冷启动</strong> 系统冷启动主要解决如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务这一问题。</li></ul><p>对于这3种不同的冷启动问题，有不同的解决方案。一般来说，可以参考如下解决方案。</p><ul><li><em>提供非个性化的推荐。</em> 非个性化推荐的最简单例子就是热门排行榜。</li><li><em>利用用户注册时提供的年龄、性别等数据做粗粒度的个性化。</em></li><li><em>利用用户的社交网络账号登录（需要用户授权），导入用户在社交网站上的好友信息，然后给用户推荐其好友喜欢的物品。</em></li><li><em>要求用户在登录时对一些物品进行反馈，收集用户对这些物品的兴趣信息，然后给用户推荐那些和这些物品相似的物品。</em></li><li><em>对于新加入的物品，可以利用内容信息，将它们推荐给喜欢过和它们相似的物品的用户。</em></li><li><em>在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表。</em></li></ul><h2 id="3-2-利用用户注册信息"><a href="#3-2-利用用户注册信息" class="headerlink" title="3.2 利用用户注册信息"></a>3.2 利用用户注册信息</h2><p>用户的注册信息分3种。</p><ul><li><strong>人口统计学信息</strong> 包括用户的年龄、性别、职业、民族、学历和居住地。</li><li><strong>用户兴趣的描述</strong> 有一些网站会让用户用文字描述他们的兴趣。</li><li><strong>从其他网站导入的用户站外行为数据</strong> 比如用户通过豆瓣、新浪微博的账号登录，就可以在得到用户同意的情况下获取用户在豆瓣或者新浪微博的一些行为数据和社交网络数据。</li></ul><p><strong>基于人口统计学特征的推荐系统</strong>其典型代表是Bruce Krulwich开发的Lifestyle Finder(参见论文Bruce Krulwich的“Lifestyle finder : intelligent user profiling using large scale demographic data”（1997）) 。书上这部分有关于该算法的简略介绍和评测，但并没有涉及该算法是具体如何根据人口统计学属性进行分类的，详情见书。</p><p>基于注册信息的<u>个性化推荐流程</u>基本如下：</p><ol><li>获取用户的注册信息；</li><li>根据用户的注册信息对用户分类；</li><li>给用户推荐他所属分类中用户喜欢的物品。</li></ol><p><strong>基于用户注册信息的推荐算法</strong>其<u>核心问题</u>是计算每种特征的用户喜欢的物品。也就是说，对于每种特征$f$，计算具有这种特征的用户对各个物品的喜好程度$p(f, i)$。<br>$p(f,i)$可以简单地定义为物品$i$在具有$f$的特征的用户中的热门程度：$$p(f,i)=\vert N(i) \cap U(f) \vert$$其中$N(i)$是喜欢物品$i$的用户集合，$U(f)$是具有特征$f$的用户集合。</p><p>上面这种定义可以比较准确地预测具有某种特征的用户是否喜欢某个物品。但是，在这种定义下，往往热门的物品会在各种特征的用户中都具有比较高的权重。也就是说具有比较高的$\vert N (i) \vert$的物品会在每一类用户中都有比较高的$p(f ,i)$。给用户推荐热门物品并不是推荐系统的主要任务，推荐系统应该帮助用户发现他们不容易发现的物品。因此，可以将$p( f , i )$定义为喜欢物品$i$的用户中具有特征$f$的比例：$$p(f,i) =  \frac {\vert N(i) \cap U(f) \vert}{\vert N(i) \vert + \alpha}$$这里分母中使用参数$\alpha$的目的是解决<strong>数据稀疏问题</strong>。比如有一个物品只被1个用户喜欢过， 而这个用户刚好就有特征$f$，那么就有$p(f,i)$。但是，这种情况并没有统计意义，因此为分母加上一个比较大的数，可以避免这样的物品产生比较大的权重。</p><p>有两个推荐系统数据集包含了人口统计学信息， 一个是 BookCrossing 数据集。另一个是Lastfm数据集。</p><blockquote><p>BookCrossing数据集:<br>参见<a href="http://www.informatik.uni-freiburg.de/~cziegler/BX/" target="_blank" rel="noopener">http://www.informatik.uni-freiburg.de/~cziegler/BX/</a><br>Lastfm数据集：<br>参见<a href="http://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-360K.html" target="_blank" rel="noopener">http://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-360K.html</a></p></blockquote><p>作者在这两个数据集上做实验验证，证明基于人口统计学特征的推荐系统准确率、召回率和覆盖率确实更高，而且利用的用户人口统计学特征越多，越能准确地预测用户兴趣，详情见书。</p><h2 id="3-3-选择合适的物品启动用户的兴趣"><a href="#3-3-选择合适的物品启动用户的兴趣" class="headerlink" title="3.3 选择合适的物品启动用户的兴趣"></a>3.3 选择合适的物品启动用户的兴趣</h2><p>对于通过让用户对物品进行评分来收集用户兴趣，从而对用户进行冷启动的系统，它们需要解决的<u>首要问题</u>就是如何选择物品让用户进行反馈。</p><p>一般来说，能够用来启动用户兴趣的物品需要具有以下特点。</p><ul><li><strong>比较热门</strong> 因为用户需要知道这个物品是什么，才能对它们作出准确反馈。</li><li><strong>具有代表性和区分性</strong> 启动用户兴趣的物品不能是大众化或老少咸宜的，因为这样的物品对用户的兴趣没有区分性。</li><li><strong>启动物品集合需要有多样性</strong> 冷启动时，由于不清楚用户的兴趣，并且用户用户兴趣的可能性非常多，为了匹配多样的兴趣，为此需要提供具有很高覆盖率的启动物品集合，这些物品能覆盖几乎所有主流的用户兴趣。</li></ul><p>上面这些因素都是选择启动物品时需要考虑的，但还需要考虑的是如何设计一个选择启动物品集合的系统？Nadav Golbandi在论文中(“Adaptive Bootstrapping of Recommender Systems Using Decision Trees”，下载地址为 <a href="http://research.yahoo.com/pub/3502" target="_blank" rel="noopener">http://research.yahoo.com/pub/3502</a>) 探讨了这个问题，提出可以用一个<strong>决策树</strong>解决这个问题。<br>首先，给定一群用户，Nadav Golbandi用这群用户对物品评分的<strong>方差</strong>度量这群用户兴趣的一致程度。如果方差很大，说明这一群用户的兴趣不太一致，反之则说明这群用户的兴趣比较一致。 令$\sigma_u \in U’$为用户集合$U’$中所有评分的方差，Nadav Golbandi的<u>基本思想</u>是通过如下方式度量一个物品的<strong>区分度</strong>$D(i)$:$$D(i) = \sigma_{u \in N^+(i)} + \sigma_{u \in N^-(i)} + \sigma_{u \in  \bar N(i)}$$其中，$N^+(i)$是喜欢物品i的用户集合，$N^-(i)$是不喜欢物品i的用户集合，$\bar N(i)$是没有对物品$i$评分的用户集合。$ \sigma_{u \in N^+(i)}$是喜欢物品i的用户对其他物品评分的方差，$\sigma_{u \in N^-(i)}$是不喜欢物品$i$的用户对其他物品评分的方差，$\sigma_{u \in  \bar N(i)}$是没有对物品$i$评分的用户对其他物品评分的方差。也就是说，对于物品$i$，Nadav Golbandi将用户分成3类——喜欢物品i的用户、不喜欢物品i的用户和不知道物品i的用户（即没有给i评分的用户）。如果这3类用户集合内的用户对其他的物品兴趣很不一致，说明物品i具有较高的区分度。<br>Nadav Golbandi的<u>算法</u>首先会从所有用户中找到具有最高区分度的物品i，然后将用户分成3类。然后在每类用户中再找到最具区分度的物品，然后将每一类用户又各自分为3类，也就是将总用户分成9类，然后这样继续下去，最终可以通过对一系列物品的看法将用户进行分类。而在冷启动时，我们从根节点开始询问用户对该节点物品的看法，然后根据用户的选择将用户放到不同的分枝，直到进入最后的叶子节点，此时我们就已经对用户的兴趣有了比较清楚的了解，从而可以开始对用户进行比较准确地个性化推荐。</p><h2 id="3-4-利用物品的内容信息"><a href="#3-4-利用物品的内容信息" class="headerlink" title="3.4 利用物品的内容信息"></a>3.4 利用物品的内容信息</h2><p>物品冷启动需要解决的问题是如何将新加入的物品推荐给对它感兴趣的用户。</p><p>第2章介绍了两种主要的推荐算法——<strong>UserCF</strong>和<strong>ItemCF算法</strong>。首先需要指出的是，UserCF算法对物品冷启动问题并不非常敏感。因为，UserCF在给用户进行推荐时，会首先找到和用户兴趣相似的一群用户，然后给用户推荐这一群用户喜欢的物品。在很多网站中，推荐列表并不是给用户展示内容的唯一列表，那么当一个新物品加入时，总会有用户从某些途径看到这些物品，对这些物品产生反馈。那么，当一个用户对某个物品产生反馈后，和他历史兴趣相似的其他用户的推荐列表中就有可能出现这一物品，从而更多的人就会对这个物品产生反馈，导致更多的人的推荐列表中会出现这一物品，因此该物品就能不断地扩散开来，从而逐步展示到对它感兴趣用户的推荐列表中。<br>但是，有些网站中推荐列表可能是用户获取信息的主要途径，比如豆瓣网络电台。那么对于UserCF算法就需要解决第一推动力的问题，即第一个用户从哪儿发现新的物品。只要有一小部分人能够发现并喜欢新的物品，UserCF算法就能将这些物品扩散到更多的用户中。解决第一推动力最简单的方法是将新的物品<strong>随机</strong>展示给用户，但这样显然不太个性化，因此可以考虑利用物品的内容信息，将新物品先投放给曾经喜欢过和它内容相似的其他物品的用户。<br>对于ItemCF算法来说，物品冷启动就是一个严重的问题了。因为ItemCF算法的原理是给用户推荐和他之前喜欢的物品相似的物品。ItemCF算法会每隔一段时间利用用户行为计算<strong>物品相似度表</strong>（一般一天计算一次），在线服务时ItemCF算法会将之前计算好的<strong>物品相关度矩阵</strong>放在内存中。因此，当新物品加入时，内存中的物品相关表中不会存在这个物品，从而ItemCF算法无法推荐新的物品。解决这一问题的办法是频繁更新物品相似度表，但基于用户行为计算物品相似度是非常耗时的事情，主要原因是用户行为日志非常庞大。而且，新物品如果不展示给用户，用户就无法对它产生行为，通过行为日志计算是计算不出包含新物品的相关矩阵的。为此，我们只能利用物品的内容信息计算物品相关表，并且频繁地更新相关表（比如半小时计算一次）。</p><p>一般来说，物品的内容可以通过<strong>向量空间模型</strong>(参见维基百科Vector Space Model词条)表示，该模型会将物品表示成一个<strong>关键词向量</strong>。如果物品的内容是一些诸如导演、演员等实体的话，可以直接将这些实体作为关键词。但如果内容是文本的形式，则需要引入一些理解自然语言的技术抽取关键词。图3-11展示了从文本生成关键词向量的主要步骤。对于中文，首先要对文本进行<strong>分词</strong>，将字流变成词流，然后从词流中检测出<strong>命名实体</strong>（如人名、地名、组织名等），这些实体和一些其他重要的词将组成关键词集合， 最后对关键词进行排名，计算每个关键词的<strong>权重</strong>，从而生成关键词向量。<br><img src="/2018/11/26/推荐系统实践读书笔记（三）/关键词向量的生成过程.png" alt="关键词向量的生成过程"><br>对于物品$d$，它的内容表示成一个关键词向量如下：$$d_i = \{ (e_1,w_1),(e_2,w_2), ···\}$$其中$e_i$是关键词，$w_i$是关键词对应的权重。如果物品是文本，我们可以用信息检索领域著名的<strong>TF-IDF公式</strong>计算词的权重：$$w_i = \frac {TF(e_i)}{\log DF(e_i)}​$$</p><p>向量空间模型的<u>优点</u>是简单，<u>缺点</u>是丢失了一些信息，比如关键词之间的关系信息。不过在绝大多数应用中，向量空间模型对于文本的分类、聚类、相似度计算已经可以给出令人满意的结果。</p><p>在给定物品内容的关键词向量后，物品的内容相似度可以通过向量之间的余弦相似度计算：$$w_{ij} = \frac {d_i \cdot d_j}{\sqrt {\Vert d_i \Vert \Vert d_j \Vert}}$$<br>在具体计算物品之间的内容相似度时，最简单的方法当然是对两两物品都利用上面的余弦相似度公式计算相似度，如下代码简单实现了这种方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CalculateSimilarity</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> di <span class="keyword">in</span> D:</span><br><span class="line">        <span class="keyword">for</span> dj <span class="keyword">in</span> D:</span><br><span class="line">            w[i][j] = CosineSimilarity(di, dj) </span><br><span class="line">    <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure></p><p><code>D</code>是文档集合。</p><p>但这种算法的时间复杂度很高。假设有$N$个物品，每个物品平均由$m$个实体表示，那么这个算法的复杂度是$O( N^2m)$。 在实际应用中，可以首先通过建立关键词—物品的<strong>倒排表</strong>加速这一计算过程，关于这一方法已经在前面介绍UserCF和ItemCF算法时详细介绍过了，所以这里直接给出计算的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CalculateSimilarity</span><span class="params">(entity-items)</span></span></span><br><span class="line">    w = dict() </span><br><span class="line">    ni = dict() </span><br><span class="line">    <span class="keyword">for</span> e,items <span class="keyword">in</span> entity_items.items():</span><br><span class="line">        <span class="keyword">for</span> i,wie <span class="keyword">in</span> items.items(): </span><br><span class="line">            addToVec(ni, i, wie * wie) </span><br><span class="line">            <span class="keyword">for</span> j,wje <span class="keyword">in</span> items.items(): </span><br><span class="line">                addToMat(w, i, j, wie, wje) </span><br><span class="line">    <span class="keyword">for</span> i, relate_items <span class="keyword">in</span> w.items():</span><br><span class="line">        relate_items = &#123;x:y/math.sqrt(ni[i] * ni[x]) <span class="keyword">for</span> x,y <span class="keyword">in</span> relate_items.items()&#125;</span><br></pre></td></tr></table></figure></p><p>得到物品的相似度之后，可以利用上一章提到的ItemCF算法的思想，给用户推荐和他历史上喜欢的物品内容相似的物品。</p><p>既然内容相似度计算简单，能频繁更新，而且能够解决物品冷启动问题，那么为什么还需要协同过滤的算法?书中这部分在MovieLens和GitHub两个数据集上进行了实验，并加以说明，详情见书。</p><h4 id="话题模型"><a href="#话题模型" class="headerlink" title="话题模型"></a>话题模型</h4><p>向量空间模型在内容数据丰富时可以获得比较好的效果。以文本为例，如果是计算长文本的相似度，用向量空间模型利用关键词计算相似度已经可以获得很高的精确度。但是，如果文本很短，关键词很少，向量空间模型就很难计算出准确的相似度。举个例子，假设有两篇论文，它们的标题分别是“推荐系统的动态特性”和“基于时间的协同过滤算法研究”。如果读者对推荐系统很熟悉，可以知道这两篇文章的研究方向是类似的，但是它们标题中没有一样的关键词。其实，它们的关键词虽然不同，但却是相似的。“动态”和“基于时间”含义相似，“协同过滤”是“推荐系统”的一种算法。换句话说，这两篇文章的关键词虽然不同，但关键词所属的话题是相同的。在这种情况下，首先需要知道文章的<strong>话题分布</strong>，然后才能准确地计算文章的相似度。如何建立文章、话题和关键词的关系是<strong>话题模型（topic model）</strong>研究的重点。</p><p>代表性的话题模型有<strong>LDA</strong>。关于LDA的详细理论介绍可以参考DM Blei的论文“Latent Dirichlet Allocation” (参见David M. Blei、 Andrew Y. Ng、 Michael I. Jordan的“ Latent dirichlet allocation”（Journal of Machine Learning Research 3， 2003）)。<br>任何模型都有一个假设，LDA作为一种<strong>生成模型</strong>，对一篇文档产生的过程进行了建模。话题模型的<u>基本思想</u>是，一个人在写一篇文档的时候，会首先想这篇文章要讨论哪些话题，然后思考这些话题应该用什么词描述，从而最终用词写成一篇文章。因此，文章和词之间是通过话题联系的。<br>LDA中有3种元素，即文档、话题和词语。每一篇文档都会表现为词的集合，这称为<strong>词袋模型(bag of words)</strong>。每个词在一篇文章中属于一个话题。令$D$为文档集合，$D[i]$是第$i$篇文档。$w[i][j]$是第$i$篇文档中的第$j$个词。$z[i][j]$是第$i$篇文档中第$j$个词属于的话题。</p><p>LDA的<u>计算过程</u>包括<strong>初始化</strong>和<strong>迭代</strong>两部分。首先要对$z$进行初始化，而初始化的方法很简单，假设一共有$K$个话题， 那么对第$i$篇文章中的第$j$个词， 可以随机给它赋予一个话题。同时，用$NWZ(w,z)$记录词$w$被赋予话题$z$的次数，$NZD(z,d)$记录文档$d$中被赋予话题$z$的词的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foreach document i <span class="keyword">in</span> range(<span class="number">0</span>,|D|):</span><br><span class="line">    foreach word j <span class="keyword">in</span> range(<span class="number">0</span>, |D(i)|):</span><br><span class="line">        z[i][j] = rand() % K </span><br><span class="line">        NZD[z[i][j], D[i]]++ </span><br><span class="line">        NWZ[w[i][j], z[i][j]]++ </span><br><span class="line">        NZ[z[i][j]]++</span><br></pre></td></tr></table></figure><p>在初始化之后，要通过迭代使话题的分布收敛到一个合理的分布上去。伪代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> converged:</span><br><span class="line">    foreach document i <span class="keyword">in</span> range(<span class="number">0</span>, |D|):</span><br><span class="line">        foreach word j <span class="keyword">in</span> range(<span class="number">0</span>, |D(i)|): </span><br><span class="line">            NWZ[w[i][j], z[i][j]]--</span><br><span class="line">            NZ[z[i][j]]--</span><br><span class="line">            NZD[z[i][j], D[i]]--</span><br><span class="line">            z[i][j] = SampleTopic() </span><br><span class="line">            NWZ[w[i][j], z[i][j]]++ </span><br><span class="line">            NZ[z[i][j]]++ </span><br><span class="line">            NZD[z[i][j], D[i]]++</span><br></pre></td></tr></table></figure><p>LDA可以很好地将词组合成不同的话题。</p><p>在使用LDA计算物品的内容相似度时，可以先计算出物品在话题上的分布，然后利用两个物品的话题分布计算物品的相似度。比如，如果两个物品的话题分布相似，则认为两个物品具有较高的相似度，反之则认为两个物品的相似度较低。计算分布的相似度可以利用<strong>KL散度</strong>(参见<a href="http://en.wikipedia.org/wiki/Kullback-Leibler_divergence" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Kullback-Leibler_divergence</a>) ：$$D_{KL}(p||q) = \sum_i p(i)ln \frac{p(i)}{q(i)}$$其中$p$和$q$是两个分布，KL散度越大说明分布的相似度越低。</p><h2 id="3-5-发挥专家的作用"><a href="#3-5-发挥专家的作用" class="headerlink" title="3.5 发挥专家的作用"></a>3.5 发挥专家的作用</h2><p>书中这部分对个性化网络电台Pandora和电影推荐网站Jinni如何利用专家对物品进行标注，进而建立推荐系统作了介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-推荐系统冷启动问题&quot;&gt;&lt;a href=&quot;#第3章-推荐系统冷启动问题&quot; class=&quot;headerlink&quot; title=&quot;第3章 推荐系统冷启动问题&quot;&gt;&lt;/a&gt;第3章 推荐系统冷启动问题&lt;/h1&gt;&lt;p&gt;如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对推荐结果满意从而愿意使用推荐系统，就是&lt;strong&gt;冷启动&lt;/strong&gt;的问题。&lt;br&gt;本章简单介绍一下冷启动问题的分类，以及如何解决不同种类的冷启动问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://rilzob.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://rilzob.com/tags/Python/"/>
    
      <category term="推荐系统" scheme="https://rilzob.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统实践读书笔记（二）</title>
    <link href="https://rilzob.com/2018/11/24/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://rilzob.com/2018/11/24/推荐系统实践读书笔记（二）/</id>
    <published>2018-11-24T06:41:12.976Z</published>
    <updated>2018-11-26T00:43:02.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章-利用用户行为数据"><a href="#第2章-利用用户行为数据" class="headerlink" title="第2章 利用用户行为数据"></a>第2章 利用用户行为数据</h1><p>用户行为数据中蕴涵着很多不是那么显而易见的规律，而个性化推荐算法的任务就是通过计算机去发现这些规律，从而为产品的设计提供指导，提高用户体验。<br>基于<strong>用户行为分析</strong>的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为<strong>协同过滤算法</strong>。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。<br><a id="more"></a></p><h2 id="2-1-用户行为数据简介"><a href="#2-1-用户行为数据简介" class="headerlink" title="2.1 用户行为数据简介"></a>2.1 用户行为数据简介</h2><h3 id="用户行为数据的存在形式"><a href="#用户行为数据的存在形式" class="headerlink" title="用户行为数据的存在形式"></a>用户行为数据的存在形式</h3><p>用户行为数据在网站上最简单的存在形式就是<strong>日志</strong>。网站在运行过程中都产生大量<strong>原始日志(raw log)</strong>，并将其存储在文件系统中。很多互联网业务会把多种原始日志按照用户行为汇总成<strong>会话日志(session log)</strong>，其中每个会话表示一次用户行为和对应的服务。比如，在搜索引擎和搜索广告系统中，服务会为每次查询生成一个<strong>展示日志(impression log)</strong>，其中记录了查询和返回结果。如果用户点击了某个结果，这个点击信息会被服务器截获并存储在<strong>点击日志(click log)</strong>中。 一个并行程序会周期性地归并展示日志和点击日志，得到的会话日志中每个消息是一个用户提交的查询、得到的结果以及点击。类似地，推荐系统和电子商务网站也会汇总原始日志生成描述用户行为的会话日志。</p><h3 id="用户行为数据的分类"><a href="#用户行为数据的分类" class="headerlink" title="用户行为数据的分类"></a>用户行为数据的分类</h3><p>用户行为在个性化推荐系统中一般分两种——<strong>显性反馈行为(explicit feedback)</strong>和<strong>隐性反馈行为(implicit feedback)</strong>。显性反馈行为包括用户明确表示对物品喜好的行为，主要形式就是评分和喜欢/不喜欢。和显性反馈行为相对应的是隐性反馈行为。隐性反馈行为指的是那些不能明确反应用户喜好的行为。最具代表性的隐性反馈行为就是页面浏览行为。<br>按照反馈的明确性分，用户行为数据可以分为显性反馈和隐性反馈，但按照反馈的方向分，又可以分为<strong>正反馈</strong>和<strong>负反馈</strong>。正反馈指用户的行为倾向于指用户喜欢该物品，而负反馈指用户的行为倾向于指用户不喜欢该物品。在显性反馈中，很容易区分一个用户行为是正反馈还是负反馈，而在隐性反馈行为中，就相对比较难以确定。</p><h3 id="显性反馈数据和隐性反馈数据的区别"><a href="#显性反馈数据和隐性反馈数据的区别" class="headerlink" title="显性反馈数据和隐性反馈数据的区别"></a>显性反馈数据和隐性反馈数据的区别</h3><p>下图从几个方面比较了显性反馈数据和隐性反馈数据。<br><img src="/2018/11/24/推荐系统实践读书笔记（二）/显示反馈数据和隐性反馈数据的比较.png" alt="显示反馈数据和隐性反馈数据的比较"></p><h3 id="用户行为的表示方式"><a href="#用户行为的表示方式" class="headerlink" title="用户行为的表示方式"></a>用户行为的表示方式</h3><p>下图给出了一种表示方式，它将一个用户行为表示为六部分，即产生行为的用户和行为的对象。行为的种类、产生行为的上下文、行为的内容和权重。<br><img src="/2018/11/24/推荐系统实践读书笔记（二）/用户行为的统一表示.png" alt="用户行为的统一表示"><br>很多时候我们并不使用统一结构表示所有行为，而是针对不同的行为给出不同表示。有时可能会忽略一些信息(比如上下文)，但有些信息不能忽略(比如产生行为的用户和行为的对象就是所有行为都必须包含的)。</p><h3 id="数据集的分类"><a href="#数据集的分类" class="headerlink" title="数据集的分类"></a>数据集的分类</h3><p>不同的数据集针对不同的情况，根据所包含行为的不同将数据集进行分类，目前比较有代表性的数据集有如下几个：</p><ul><li><strong>无上下文信息的隐性反馈数据集</strong> 每一条行为记录仅仅包含用户ID和物品ID。Book-Crossing(参见“Book-Crossing Dataset”，地址为<a href="http://www.informatik.uni-freiburg.de/~cziegler/BX/" target="_blank" rel="noopener">http://www.informatik.uni-freiburg.de/~cziegler/BX/</a>) 就是这种类型的数据集。 </li><li><strong>无上下文信息的显性反馈数据集</strong> 每一条记录包含用户ID、物品ID和用户对物品的评分。</li><li><strong>有上下文信息的隐性反馈数据集</strong> 每一条记录包含用户ID、物品ID和用户对物品产生行为的时间戳。Lastfm数据集(参见<a href="http://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-1K.html" target="_blank" rel="noopener">http://www.dtic.upf.edu/~ocelma/MusicRecommendationDataset/lastfm-1K.html</a>) 就是这种类型的数据集。</li><li><strong>有上下文信息的显性反馈数据集</strong> 每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。Netflix Prize(参见<a href="http://netflixprize.com/" target="_blank" rel="noopener">http://netflixprize.com/</a>) 提供的就是这种类型的数据集。</li></ul><h2 id="2-2-用户行为分析"><a href="#2-2-用户行为分析" class="headerlink" title="2.2 用户行为分析"></a>2.2 用户行为分析</h2><p>在利用用户行为数据设计推荐算法之前，研究人员首先需要对用户行为数据进行分析，了解数据中蕴含的一般规律，这样才能对算法的设计起到指导作用。</p><h3 id="2-2-1-用户活跃度和物品流行度的分布"><a href="#2-2-1-用户活跃度和物品流行度的分布" class="headerlink" title="2.2.1 用户活跃度和物品流行度的分布"></a>2.2.1 用户活跃度和物品流行度的分布</h3><h4 id="长尾分布"><a href="#长尾分布" class="headerlink" title="长尾分布"></a>长尾分布</h4><p>很多关于互联网数据的研究发现，互联网上的很多数据分布都满足一种称为Power Law(参见“浅谈网络世界的Power Law现象”，地址为<a href="http://mmdays.com/2008/11/22/power_law_1/" target="_blank" rel="noopener">http://mmdays.com/2008/11/22/power_law_1/</a>) 的分布，这个分布在互联网领域也称<strong>长尾分布</strong>。$$f(x) = \alpha x^k$$<br>1932年，哈佛大学的语言学家Zipf在研究英文单词的词频时发现，如果将单词出现的频率按照由高到低排列，则每个单词出现的频率和它在热门排行榜中排名的常数次幂成反比。这个现象表明，在英文中大部分词的词频其实很低，只有很少的词被经常使用。<br>用户行为数据也蕴含着这种规律。令$f_u(k)$为对k个物品产生过行为的用户数，令$f_i(k)$为被k个用户产生过行为的物品数。那么，$f_u(k)$和$f_i(k)$都满足长尾分布。也就是说：$$f_u(k)= \alpha_u k^{\beta_u}$$ $$f_i(k)= \alpha_i k^{\beta_i}$$</p><h3 id="2-2-2-用户活跃度和物品流行度的关系"><a href="#2-2-2-用户活跃度和物品流行度的关系" class="headerlink" title="2.2.2 用户活跃度和物品流行度的关系"></a>2.2.2 用户活跃度和物品流行度的关系</h3><p>用户越活跃，越倾向于浏览冷门的物品。<br>仅仅基于用户行为数据设计的推荐算法一般称为协同过滤算法。 学术界对协同过滤算法进行了深入研究，提出了很多方法，比如<strong>基于邻域的方法（ neighborhood-based ）</strong>、<strong>隐语义模型（ latent factor model）</strong>、<strong>基于图的随机游走算法（random walk on graph）</strong>等。在这些方法中，最著名的、在业界得到最广泛应用的算法是基于邻域的方法， 而基于邻域的方法主要包含下面两种算法。</p><ul><li><strong>基于用户的协同过滤算法</strong></li><li><strong>基于物品的协同过滤算法</strong></li></ul><h2 id="2-3-实验设计和算法评测"><a href="#2-3-实验设计和算法评测" class="headerlink" title="2.3 实验设计和算法评测"></a>2.3 实验设计和算法评测</h2><h3 id="2-3-1-数据集"><a href="#2-3-1-数据集" class="headerlink" title="2.3.1 数据集"></a>2.3.1 数据集</h3><p>采用GroupLens提供的MovieLens数据集(数据集详细信息见 <a href="http://www.grouplens.org/node/73" target="_blank" rel="noopener">http://www.grouplens.org/node/73</a>) 介绍和评测各种算法，并且忽略了数据集中的评分记录。</p><h3 id="2-3-2-实验设计"><a href="#2-3-2-实验设计" class="headerlink" title="2.3.2 实验设计"></a>2.3.2 实验设计</h3><p>协同过滤算法的离线实验一般如下设计。首先，将用户行为数据集按照均匀分布随机分成M份，挑选一份作为测试集，将剩下的M-1份作为训练集。然后在训练集上建立用户兴趣模型，并在测试集上对用户行为进行预测，统计出相应的评测指标。为了保证评测指标并不是过拟合的结果，需要进行M次实验，并且每次都使用不同的测试集。然后将M次实验测出的评测指标的平均值作为最终的评测指标。</p><p>下面的代码描述了将数据集随机分成训练集和测试集的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SplitData</span><span class="params">(data, M, k, seed)</span>:</span></span><br><span class="line">    test = []</span><br><span class="line">    train = []</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    <span class="keyword">for</span> user, item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">0</span>,M) == k:</span><br><span class="line">            test.append([user,item])</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            train.append([user,item])</span><br><span class="line">    <span class="keyword">return</span> train, test</span><br></pre></td></tr></table></figure><p>这里，每次实验选取不同的k（0≤k≤M-1）和相同的随机数种子seed，进行M次实验就可以得到M个不同的训练集和测试集，然后分别进行实验，用M次实验的平均值作为最后的评测指标。这样做主要是防止某次实验的结果是过拟合的结果（over fitting），但如果数据集够大，模型够简单，为了快速通过离线实验初步地选择算法，也可以只进行一次实验。</p><h3 id="2-3-3-评测指标"><a href="#2-3-3-评测指标" class="headerlink" title="2.3.3 评测指标"></a>2.3.3 评测指标</h3><h4 id="召回率和准确率"><a href="#召回率和准确率" class="headerlink" title="召回率和准确率"></a>召回率和准确率</h4><p>计算方法和第一章预测准确度中TopN推荐部分一样</p><h4 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h4><p>同样与之前介绍的一致。如下代码可以用来计算推荐算法的覆盖率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Coverage</span><span class="params">(train, test, N)</span>:</span></span><br><span class="line">    recommend_items = set() </span><br><span class="line">    all_items = set() </span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> train.keys():</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> train[user].keys():</span><br><span class="line">            all_items.add(item)</span><br><span class="line">        rank = GetRecommendation(user, N)</span><br><span class="line">        <span class="keyword">for</span> item, pui <span class="keyword">in</span> rank:</span><br><span class="line">            recommend_items.add(item) </span><br><span class="line">    <span class="keyword">return</span> len(recommend_items) / (len(all_items) * <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure><h4 id="新颖度"><a href="#新颖度" class="headerlink" title="新颖度"></a>新颖度</h4><p>使用推荐列表中物品的平均流行度度量推荐结果的新颖度。如果推荐出的物品都很热门，说明推荐的新颖度较低，否则说明推荐结果比较新颖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Popularity</span><span class="params">(train, test, N)</span>:</span></span><br><span class="line">    item_popularity = dict() </span><br><span class="line">    <span class="keyword">for</span> user, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items.keys() </span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> item_popularity:</span><br><span class="line">                item_popularity[item] = <span class="number">0</span> </span><br><span class="line">            item_popularity[item] += <span class="number">1</span> </span><br><span class="line">    ret = <span class="number">0</span> </span><br><span class="line">    n = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> train.keys():</span><br><span class="line">        rank = GetRecommendation(user, N)</span><br><span class="line">        <span class="keyword">for</span> item, pui <span class="keyword">in</span> rank:</span><br><span class="line">            ret += math.log(<span class="number">1</span> + item_popularity[item]) </span><br><span class="line">            n += <span class="number">1</span> </span><br><span class="line">    ret /= n * <span class="number">1.0</span> </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>计算平均流行度时对每个物品的流行度取对数，这是因为物品的流行度分布满足长尾分布，在取对数后，流行度的平均值更加稳定。</p><h2 id="2-4-基于近邻的算法"><a href="#2-4-基于近邻的算法" class="headerlink" title="2.4 基于近邻的算法"></a>2.4 基于近邻的算法</h2><p>基于邻域的算法分为两大类，一类是<strong>基于用户的协同过滤算法</strong>，另一类是<strong>基于物品的协同过滤算法</strong>。</p><h3 id="2-4-1-基于用户的协同过滤算法-UserCF算法"><a href="#2-4-1-基于用户的协同过滤算法-UserCF算法" class="headerlink" title="2.4.1 基于用户的协同过滤算法(UserCF算法)"></a>2.4.1 基于用户的协同过滤算法(UserCF算法)</h3><p>基于用户的协同过滤算法是推荐系统中最古老的算法。这个算法的诞生标志了推荐系统的诞生。该算法在1992年被提出，并应用于邮件过滤系统，1994年被GroupLens用于新闻过滤。在此之后直到2000年，该算法都是推荐系统领域最著名的算法。</p><h4 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1.基础算法"></a>1.基础算法</h4><p>在一个在线个性化推荐系统中，当一个用户A需要个性化推荐时，可以先找到和他有相似兴趣的其他用户，然后把那些用户喜欢的、而用户A没有听说过的物品推荐给A。这种方法称为<em>基于用户的协同过滤算法</em>。<br>基于用户的协同过滤算法主要包括两个步骤。</p><ol><li>找到和目标用户兴趣相似的用户集合。</li><li>找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。</li></ol><p>步骤(1)的关键是计算两个用户的兴趣相似度。协同过滤算法主要利用行为的相似度计算兴趣的相似度。给定用户u和用户v，令$N(u)$表示用户u曾经有过正反馈的物品集合，令$N(v)$为用户v曾经有过正反馈的物品集合。可以通过如下的Jaccard公式简单计算用户u和用户v的兴趣相似度：$$w_{uv} = \frac{|N(u) \cap N(v)|}{|N(u) \cup N(v)|}$$<br>或者通过余弦相似度计算：$$w_{uv} = \frac{|N(u) \cap N(v)|}{\sqrt{|N(u)||N(v)|}}$$<br>实现余弦相似度可以利用如下的伪码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UserSimilarity</span><span class="params">(train)</span>:</span></span><br><span class="line">    W = dict() </span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> train.keys():</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> train.keys():</span><br><span class="line">            <span class="keyword">if</span> u == v:</span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            W[u][v] = len(train[u] &amp; train[v]) </span><br><span class="line">            W[u][v] /= math.sqrt(len(train[u]) * len(train[v]) * <span class="number">1.0</span>) </span><br><span class="line">    <span class="keyword">return</span> W</span><br></pre></td></tr></table></figure><p>该代码对两两用户都利用余弦相似度计算相似度。这种方法的时间复杂度是$O(|U|*|U|)$，这在用户数很大时非常耗时。由于实际上很多用户户相互之间并没有对同样的物品产生过行为，即$|N(u)\cap N(v)| = 0 $，因此会将很多时间浪费在计算用户之间相似度上。换个思路，首先计算出$|N(u)\cap N(v)|\neq 0$的用户对$(u, v)$，然后再对这种情况除以分母$\sqrt{|N(u)||N(v)|}$。<br>为此，首先建立物品到用户的倒排表，对于每个物品都保存对该物品产生过行为的用户列表。令稀疏矩阵$C[u][v]= N(u) \cap N(v)$ 。那么，假设用户u和用户v同时属于倒排表中K个物品对应的用户列表，就有$C[u][v]=K$。从而，可以扫描倒排表中每个物品对应的用户列表，将用户列表中的两两用户对应的$C[u][v]$加1，最终就可以得到所有用户之间不为0的$C[u][v]$。下面的代码实现了上面提到的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UserSimilarity</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="comment"># build inverse table for item_users </span></span><br><span class="line">    item_users = dict() </span><br><span class="line">    <span class="keyword">for</span> u, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> items.keys():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> item_users: </span><br><span class="line">                item_users[i] = set() </span><br><span class="line">            item_users[i].add(u)</span><br><span class="line">            </span><br><span class="line">    <span class="comment">#calculate co-rated items between users </span></span><br><span class="line">    C = dict() </span><br><span class="line">    N = dict() </span><br><span class="line">    <span class="keyword">for</span> i, users <span class="keyword">in</span> item_users.items():</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> users:</span><br><span class="line">            N[u] += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> users: </span><br><span class="line">                <span class="keyword">if</span> u == v: </span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                C[u][v] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">    <span class="comment">#calculate finial similarity matrix W </span></span><br><span class="line">    W = dict() </span><br><span class="line">    <span class="keyword">for</span> v, cuv <span class="keyword">in</span> related_users.items(): </span><br><span class="line">        W[u][v] = cuv / math.sqrt(N[u] * N[v]) </span><br><span class="line">    <span class="keyword">return</span> W</span><br></pre></td></tr></table></figure><p>得到用户之间的兴趣相似度后，UserCF算法会给用户推荐和他兴趣最相似的K个用户喜欢的物品。如下的公式度量了UserCF算法中用户u对物品i的感兴趣程度：$$p(u,i)=\sum_{v \in S(u,K) \cap N(i)} w_{uv}r_{vi}$$<br>其中，$S(u,K)$包含和用户u兴趣最接近的K个用户，$N(i)$是对物品i有过行为的用户集合，$w_{uv}$是用户u和用户v的兴趣相似度，$r_{vi}$代表用户v对物品i的兴趣，因为使用的是单一行为的隐反馈数据，所以所有的$r_{vi}=1$。</p><p>如下代码实现了上面的UserCF推荐算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recommend</span><span class="params">(user, train, W)</span>:</span></span><br><span class="line">    rank = dict() </span><br><span class="line">    interacted_items = train[user] </span><br><span class="line">    <span class="keyword">for</span> v, wuv <span class="keyword">in</span> sorted(W[u].items, key=itemgetter(<span class="number">1</span>), \</span><br><span class="line">        reverse=<span class="keyword">True</span>)[<span class="number">0</span>:K]:</span><br><span class="line">        <span class="keyword">for</span> i, rvi <span class="keyword">in</span> train[v].items:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> interacted_items:</span><br><span class="line">                <span class="comment"># we should filter items user interacted before</span></span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            rank[i] += wuv * rvi </span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure><p>参数K是UserCF的一个重要参数，它的调整对推荐算法的各种指标都会产生一定的影响。</p><ul><li><strong>准确率和召回率</strong> 选择合适的K对于获得高的推荐系统精度比较重要。推荐结果的精度对K也不是特别敏感，只要选在一定的区域内，就可以获得不错的精度。</li><li><strong>流行度</strong> K越大，参考的人越多，结果就越来越趋近于全局热门的物品。</li><li><strong>覆盖率</strong> K越大，则UserCF推荐结果的覆盖率越低。覆盖率的降低是因为流行度的增加，随着流行度增加，UserCF越来越倾向于推荐热门的物品，从而对长尾物品的推荐越来越少，因此造成了覆盖率的降低。</li></ul><h4 id="2-用户相似度计算的改进"><a href="#2-用户相似度计算的改进" class="headerlink" title="2.用户相似度计算的改进"></a>2.用户相似度计算的改进</h4><p>之前介绍的通过余弦相似度公式计算兴趣相似度，但是由于这个公式过于粗糙，于是需要改进该公式来提高UserCF的推荐性能。<br>研究表明，用户对冷门物品采取与热门物品同样的行为更能说明他们兴趣的相似度。因此，John S. Breese在论文(参见John S. Breese、 David Heckerman和 Carl Kadie的论文“ Empirical Analysis of Predictive Algorithms for Collaborative Filtering”（Morgan Kaufmann Publishers，1998）)中提出了如下公式，根据用户行为计算用户的兴趣相似度：$$w_{uv} = \frac {\sum_{i \in N(u) \cap N(v)}\frac{1}{\log 1 + |N(i)|}}{\sqrt{|N(u)||N(v)|}}$$<br>该公式通过$\frac{1}{\log 1 + |N(i)|}$惩罚了用户u和用户v共同兴趣列表中热门物品对他们相似度的影响。</p><p>将基于上述用户相似度公式的UserCF算法记为User-IIF算法。下面的代码实现了上述用户相似度公式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UserSimilarity</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="comment"># build inverse table for item_users</span></span><br><span class="line">    item_users = dict() </span><br><span class="line">    <span class="keyword">for</span> u, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> items.keys():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> item_users: </span><br><span class="line">                item_users[i] = set() </span><br><span class="line">            item_users[i].add(u)</span><br><span class="line">            </span><br><span class="line">    <span class="comment">#calculate co-rated items between users </span></span><br><span class="line">    C = dict() </span><br><span class="line">    N = dict() </span><br><span class="line">    <span class="keyword">for</span> i, users <span class="keyword">in</span> item_users.items():</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> users:</span><br><span class="line">            N[u] += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> users:</span><br><span class="line">                <span class="keyword">if</span> u == v:</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                C[u][v] += <span class="number">1</span> / math.log(<span class="number">1</span> + len(users))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#calculate finial similarity matrix W </span></span><br><span class="line">    W = dict() </span><br><span class="line">    <span class="keyword">for</span> u, related_users <span class="keyword">in</span> C.items():</span><br><span class="line">        <span class="keyword">for</span> v, cuv <span class="keyword">in</span> related_users.items(): </span><br><span class="line">            W[u][v] = cuv / math.sqrt(N[u] * N[v]) </span><br><span class="line">    <span class="keyword">return</span> W</span><br></pre></td></tr></table></figure><p>通过实验评测证明计算用户兴趣相似度时考虑物品的流行度对提升推荐效果的质量确实有帮助。</p><h4 id="3-实际在线系统中使用UserCF的例子"><a href="#3-实际在线系统中使用UserCF的例子" class="headerlink" title="3.实际在线系统中使用UserCF的例子"></a>3.实际在线系统中使用UserCF的例子</h4><p>相比我们后面要讨论的基于物品的协同过滤算法(ItemCF)，UserCF在目前的实际应用中使用并不多。其中最著名的使用者是Digg，书中这部分介绍了Digg的推荐系统设计思路。</p><h4 id="4-UserCF算法的缺点"><a href="#4-UserCF算法的缺点" class="headerlink" title="4.UserCF算法的缺点"></a>4.UserCF算法的缺点</h4><p>首先，随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系。其次，基于用户的协同过滤很难对推荐结果作出解释。</p><h3 id="2-4-2-基于物品的协同过滤算法-ItemCF"><a href="#2-4-2-基于物品的协同过滤算法-ItemCF" class="headerlink" title="2.4.2 基于物品的协同过滤算法(ItemCF)"></a>2.4.2 基于物品的协同过滤算法(ItemCF)</h3><p><em>基于物品的协同过滤（item-based collaborative filtering）算法</em>是目前业界应用最多的算法。无论是亚马逊网，还是Netflix、Hulu、YouTube，其推荐算法的基础都是该算法。</p><h4 id="1-基础算法-1"><a href="#1-基础算法-1" class="headerlink" title="1.基础算法"></a>1.基础算法</h4><p>ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B 。</p><p>基于物品的协同过滤算法主要分为两步：</p><ol><li>计算物品之间的相似度。</li><li>根据物品的相似度和用户的历史行为给用户生成推荐列表。</li></ol><p>为了避免推荐出热门的商品，用下面的公式定义物品的相似度：$$w_{ij}=\frac {|N(i)\cap N(j)|} {\sqrt{|N(i)||N(j)|}}$$<br>这个公式惩罚了物品j的权重，因此减轻了热门物品会和很多物品相似的可能性。</p><p>和UserCF算法类似，用ItemCF算法计算物品相似度时也可以首先建立用户—物品倒排表（即对每个用户建立一个包含他喜欢的物品的列表），然后对于每个用户，将他物品列表中的物品两两在共现矩阵C中加1。</p><p>详细代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ItemSimilarity</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="comment">#calculate co-rated users between items </span></span><br><span class="line">    C = dict() </span><br><span class="line">    N = dict() </span><br><span class="line">    <span class="keyword">for</span> u, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> users:</span><br><span class="line">            N[i] += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> users:</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                C[i][j] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#calculate finial similarity matrix W </span></span><br><span class="line">    W = dict() </span><br><span class="line">    <span class="keyword">for</span> i,related_items <span class="keyword">in</span> C.items():</span><br><span class="line">        <span class="keyword">for</span> j, cij <span class="keyword">in</span> related_items.items(): </span><br><span class="line">            W[u][v] = cij / math.sqrt(N[i] * N[j]) </span><br><span class="line">    <span class="keyword">return</span> W</span><br></pre></td></tr></table></figure></p><p>在得到物品之间的相似度后，ItemCF通过如下公式计算用户u对一个物品j的兴趣：$$p_{uj}=\sum_{i\in N(u) \cap S(j,K)} {w_{ji}r_{ui}} $$<br>这里$N(u)$是用户喜欢的物品的集合，$S(j,K)$是和物品$j$最相似的$K$个物品的集合，$w_{ji}$是物品$j$和$i$的相似度，$r_{ui}$是用户$u$对物品$i$的兴趣。（对于隐反馈数据集，如果用户$u$对物品$i$有过行为，即可令$r_{ui}$ =1。）该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。</p><p>该公式的实现代码如下所示。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recommendation</span><span class="params">(train, user_id, W, K)</span>:</span></span><br><span class="line">    rank = dict() </span><br><span class="line">    ru = train[user_id] </span><br><span class="line">    <span class="keyword">for</span> i,pi <span class="keyword">in</span> ru.items():</span><br><span class="line">        <span class="keyword">for</span> j, wj <span class="keyword">in</span> sorted(W[i].items(), / key=itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)[<span class="number">0</span>:K]: </span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> ru:</span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            rank[j] += pi * wj </span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure></p><p>ItemCF的一个优势就是可以提供推荐解释，即利用用户历史上喜欢的物品为现在的推荐结果进行解释。</p><p>如下代码实现了带解释的ItemCF算法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recommendation</span><span class="params">(train, user_id, W, K)</span>:</span></span><br><span class="line">    rank = dict() </span><br><span class="line">    ru = train[user_id] </span><br><span class="line">    <span class="keyword">for</span> i,pi <span class="keyword">in</span> ru.items():</span><br><span class="line">        <span class="keyword">for</span> j, wj <span class="keyword">in</span> sorted(W[i].items(), / key=itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)[<span class="number">0</span>:K]: </span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> ru:</span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            rank[j].weight += pi * wj </span><br><span class="line">            rank[j].reason[i] = pi * wj </span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure></p><p>参数K同样也是ItemCF算法中的一个重要参数。</p><ul><li><strong>精度(准确率和召回率)</strong> ItemCF推荐结果的精度也是不和K成正相关或者负相关的，因此选择合适的K对获得最高精度是非常重要的。</li><li><strong>流行度</strong> 和UserCF不同，参数K对ItemCF推荐结果流行度的影响也不是完全正相关的。随着K的增加，结果流行度会逐渐提高，但当K增加到一定程度，流行度就不会再有明显变化。</li><li><strong>覆盖率</strong> K增加会降低系统的覆盖率。</li></ul><h4 id="2-用户活跃度对物品相似度的影响"><a href="#2-用户活跃度对物品相似度的影响" class="headerlink" title="2.用户活跃度对物品相似度的影响"></a>2.用户活跃度对物品相似度的影响</h4><p>John S. Breese在论文中(参见John S. Breese、 David Heckerman和 Carl Kadie的“ Empirical Analysis of Predictive Algorithms for Collaborative Filtering”（Morgan Kaufmann Publishers ，1998）)提出了一个称为<strong>IUF(Inverse User Frequence)</strong>，即用户活跃度对数的倒数的参数，他认为活跃用户对物品相似度的贡献应该小于不活跃的用户，他提出应该增加<em>IUF 参数</em>来修正物品相似度的计算公式：$$w_{ij}=\frac{\sum_{u\in N(i)\cap N(j)} \frac{1}{\log1 + |N(u)|}}{\sqrt{|N(i)||N(j)|}}$$</p><p>上面的公式只是对活跃用户做了一种软性惩罚，对于很多过于活跃的用户，为了避免相似度矩阵过于稠密，在实际计算中一般直接忽略他的兴趣列表，而不将其纳入到相似度计算的数据集中。</p><p>下面代码实现了改进后的算法，并将改进后的算法记为ItemCF-IUF：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ItemSimilarity</span><span class="params">(train)</span>:</span></span><br><span class="line">    <span class="comment">#calculate co-rated users between items </span></span><br><span class="line">    C = dict() </span><br><span class="line">    N = dict() </span><br><span class="line">    <span class="keyword">for</span> u, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> users:</span><br><span class="line">            N[i] += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> users:</span><br><span class="line">                 <span class="keyword">if</span> i == j:</span><br><span class="line">                     <span class="keyword">continue</span> </span><br><span class="line">                 C[i][j] += <span class="number">1</span> / math.log(<span class="number">1</span> + len(items) * <span class="number">1.0</span>)</span><br><span class="line">                    </span><br><span class="line">    <span class="comment">#calculate finial similarity matrix W </span></span><br><span class="line">    W = dict() </span><br><span class="line">    <span class="keyword">for</span> i,related_items <span class="keyword">in</span> C.items():</span><br><span class="line">        <span class="keyword">for</span> j, cij <span class="keyword">in</span> related_items.items(): </span><br><span class="line">            W[u][v] = cij / math.sqrt(N[i] * N[j]) </span><br><span class="line">    <span class="keyword">return</span> W</span><br></pre></td></tr></table></figure></p><p>通过离线算法评测该算法证明，ItemCF-IUF在准确率和召回率两个指标上和ItemCF相近，但ItemCF-IUF明显提高了推荐结果的覆盖率，降低了推荐结果的流行度。从这个意义上说，ItemCF-IUF确实改进了ItemCF的综合性能。</p><h4 id="3-物品相似度的归一化"><a href="#3-物品相似度的归一化" class="headerlink" title="3.物品相似度的归一化"></a>3.物品相似度的归一化</h4><p>Karypis在研究中发现如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率(参见George Karypis的论文“ Evaluation of Item-based Top-N Recommendation Algorithms”)。其研究表明，如果已经得到了物品相似度矩阵w，那么可以用如下公式得到归一化之后的相似度矩阵$w’$：$$w_{ij}’ = \frac{w_{ij}}{max_j{w_{ij}}}$$<br>归一化的好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。从实验结果可以看到，归一化确实能提高ItemCF的性能，其中各项指标都有了比较明显的提高。</p><h3 id="2-4-3-UserCF和ItemCF的综合比较"><a href="#2-4-3-UserCF和ItemCF的综合比较" class="headerlink" title="2.4.3 UserCF和ItemCF的综合比较"></a>2.4.3 UserCF和ItemCF的综合比较</h3><h4 id="UserCF和ItemCF的应用领域比较及原因"><a href="#UserCF和ItemCF的应用领域比较及原因" class="headerlink" title="UserCF和ItemCF的应用领域比较及原因"></a>UserCF和ItemCF的应用领域比较及原因</h4><p>UserCF多被用于新闻推荐比如Digg，而ItemCF则在电子商务和书籍电影推荐方面得到广泛应用比如Amazon和Netflix。<br>UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF 的推荐结果着重于维系用户的历史兴趣。换句话说，UserCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF的推荐更加个性化，反映了用户自己的兴趣传承。<br>在新闻网站中，用户的兴趣不是特别细化，绝大多数用户都喜欢看热门的新闻。即使是个性化，也是比较粗粒度的。因此，个性化新闻推荐更加强调抓住新闻热点，热门程度和时效性是个性化新闻推荐的重点，而个性化相对于这两点略显次要。因此，UserCF可以给用户推荐和他有相似爱好的一群其他用户今天都在看的新闻，这样在抓住热点和时效性的同时， 保证了一定程度的个性化。 这是 Digg在新闻推荐中使用UserCF的最重要原因。<br>UserCF适合用于新闻推荐的另一个原因是从技术角度考量的。因为作为一种物品，新闻的更新非常快，每时每刻都有新内容出现，而ItemCF需要维护一张物品相关度的表，如果物品更新很快，那么这张表也需要很快更新，这在技术上很难实现。绝大多数物品相关度表都只能做到一天一次更新，这在新闻领域是不可以接受的。而UserCF只需要用户相似性表，虽然UserCF对于新用户也需要更新相似度表，但在新闻网站中，物品的更新速度远远快于新用户的加入速度，而且对于新用户，完全可以给他推荐最热门的新闻，因此UserCF显然是利大于弊。<br>但是，在图书、电子商务和电影网站，比如亚马逊、豆瓣、Netflix中，ItemCF则能极大地发挥优势。首先，在这些网站中，用户的兴趣是比较固定和持久的。而且这些网站中有一些活跃度很高的人，例如技术人员。一个技术人员可能都是在购买 技术方面的书，而且他们对书的热门程度并不是那么敏感，事实上越是资深的技术人员，他们看的书就越可能不热门。此外，这些系统中的用户大都不太需要流行度来辅助他们判断一个物品的 好坏，而是可以通过自己熟悉领域的知识自己判断物品的质量。因此，这些网站中个性化推荐的任务是帮助用户发现和他研究领域相关的物品。因此，ItemCF算法成为了这些网站的首选算法。 此外，这些网站的物品更新速度不会特别快，一天一次更新物品相似度矩阵对它们来说不会造成太大的损失，是可以接受的。<br>同时，从技术上考虑，UserCF需要维护一个用户相似度的矩阵，而ItemCF需要维护一个物品相似度矩阵。从存储的角度说，如果用户很多，那么维护用户兴趣相似度矩阵需要很大的空间， 同理，如果物品很多，那么维护物品相似度矩阵代价较大。<br>在早期的研究中，大部分研究人员都是让少量的用户对大量的物品进行评价，然后研究用户兴趣的模式。对于他们来说，因为用户很少，计算用户兴趣相似度是最快也是最简单的方法。但在实际的互联网中，用户数目往往非常庞大，而在图书、电子商务网站中，物品的数目则是比较少的。此外，物品的相似度相对于用户的兴趣一般比较稳定，因此使用ItemCF是比较好的选择。当然，新闻网站是个例外，在那儿，物品的相似度变化很快，物品数目庞大， 相反用户兴趣则相对固定（都是喜欢看热门的），所以新闻网站的个性化推荐使用UserCF算法的更多。</p><p><img src="/2018/11/24/推荐系统实践读书笔记（二）/UserCF和ItemCF优缺点的对比.png" alt="UserCF和ItemCF优缺点的对比"></p><h4 id="UserCF与ItemCF的性能比较及原因"><a href="#UserCF与ItemCF的性能比较及原因" class="headerlink" title="UserCF与ItemCF的性能比较及原因"></a>UserCF与ItemCF的性能比较及原因</h4><p>离线实验结果可见，ItemCF算法在各项指标上似乎都不如UserCF，特别是其推荐结果的覆盖率和新颖度都低于UserCF。<br>似乎与之前所说的不符合。首先要指出的是，离线实验的性能在选择推荐算法时并不起决定作用。首先应该满足产品的需求，比如如果需要提供推荐解释，那么可能得选择ItemCF算法。其次，需要看实现代价，比如若用户太多，很难计算用户相似度矩阵，这个时候可能不得不抛弃UserCF算法。最后，离线指标和点击率等在线指标不一定成正比。而且，这里对比的是最原始的UserCF和ItemCF算法，这两种算法都可以进行各种各样的改进。一般来说，这两种算法经过优化后，最终得到的离线性能是近似的。</p><h4 id="哈利波特问题"><a href="#哈利波特问题" class="headerlink" title="哈利波特问题"></a>哈利波特问题</h4><p>亚马逊网的研究人员在设计ItemCF算法之初发现ItemCF算法计算出的图书相关表存在一个问题，就是很多书都和《哈利波特》相关。  也就是说，购买任何一本书的人似乎都会购买《哈利波特》。后来他们研究发现，主要是因为《哈利波特》太热门了，确实是购买任何一本书的人几乎都会购买它。<br>回顾一下ItemCF计算物品相似度的经典公式：$$w_{ij}=\frac {\vert N(i)\cap N(j) \vert} {\sqrt{\vert N(i)||N(j)\vert}}$$<br>这个问题的原因是，如果j非常热门， 那么上面公式的分子$N (i ) \cap  N ( j )$就会越来越接近$N (i)$。 尽管上面的公式分母已经考虑到了$j$的流行度，但在实际应用中，热门的j仍然会获得比较大的相似度。</p><p>哈利波特问题有几种解决方案。<br>第一种是在分母上加大对热门物品的惩罚，比如采用如下公式：$$w_{ij} = \frac {\vert N(i) \cap N(j) \vert}{\vert  N(i)\vert^{1-\alpha} \vert  N(j)\vert^{\alpha}}$$<br>其中$\alpha \in [0.5,1]$。通过提高$\alpha$，就可以惩罚热门的j。</p><p>如果α＝0.5就是标准的ItemCF算法。从离线实验结果可以看到，α只有在取值为0.5时才会导致最高的准确率和召回率，而无论α＜0.5或者α＞0.5都不会带来这两个指标的提高。但是，如果看覆盖率和平均流行度就可以发现，α越大，覆盖率就越高，并且结果的平均热门程度会降低。因此，通过这种方法可以在适当牺牲准确率和召回率的情况下显著提升结果的覆盖率和新颖性（降低流行度即提高了新颖性）。<br>上述方法还不能彻底地解决哈利波特问题。每个用户一般都会在不同的领域喜欢一种物品。两个不同领域的最热门物品之间往往具有比较高的相似度。这个时候，仅仅靠用户行为数据是不能解决这个问题的，因为用户的行为表示这种物品之间应该相似度很高。此时，我们只能依靠引入物品的内容数据解决这个问题，比如对不同领域的物品降低权重等。这些就不是协同过滤讨论的范畴了。</p><h2 id="2-5-隐语义模型"><a href="#2-5-隐语义模型" class="headerlink" title="2.5 隐语义模型"></a>2.5 隐语义模型</h2><p>自从Netflix Prize比赛举办以来，LFM（latent factor model）隐语义模型逐渐成为推荐系统领域耳熟能详的名词。其实该算法最早在文本挖掘领域被提出，用于找到文本的隐含语义。</p><h3 id="2-5-1-基础算法"><a href="#2-5-1-基础算法" class="headerlink" title="2.5.1 基础算法"></a>2.5.1 基础算法</h3><p>隐语义模型的核心思想是通过特征(latent factor)联系用户兴趣和物品。<br>针对推荐问题除了UserCF、ItemCF算法，还有一种方法就是根据用户的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。<br>这个基于兴趣分类的方法大概需要解决3个问题：</p><ul><li>如何给物品进行分类？</li><li>如何确定用户对哪些类的物品感兴趣，以及感兴趣的程度？</li><li>对于一个给定的类，选择哪些属于这个类的物品推荐给用户，以及如何确定这些物品在一个类中的权重？</li></ul><p>对于第一个问题的简单解决方案是找编辑给物品分类。但是，即使有很系统的分类体系，编辑给出的分类仍然具有以下缺点。</p><ul><li>编辑的意见不能代表各种用户的意见。编辑的分类大部分是从书的内容出 发，而不是从书的读者群出发。</li><li>编辑很难控制分类的粒度。</li><li>编辑很难给一个物品多个分类。有的书不仅属于一个类，而是可能属于很多的类。</li><li>编辑很难给出多维度的分类。</li><li>编辑很难决定一个物品在某一个分类中的权重。</li></ul><p>为了解决上面的问题，研究人员提出：为什么我们不从数据出发，自动地找到那些类，然后进行个性化推荐？于是，隐含语义分析技术（latent variable analysis）出现了。隐含语义分析技术因为采取基于用户行为统计的自动聚类，较好地解决了上面提出的5个问题。</p><ul><li>编辑的意见不能代表各种用户的意见，但隐含语义分析技术的分类来自对用户行为的统计，代表了用户对物品分类的看法。隐含语义分析技术和ItemCF在物品分类方面的思想类似，如果两个物品被很多用户同时喜欢，那么这两个物品就很有可能属于同一个类。</li><li>编辑很难控制分类的粒度，但隐含语义分析技术允许我们指定最终有多少个分类，这个数字越大，分类的粒度就会越细，反正分类粒度就越粗。</li><li>编辑很难给一个物品多个分类，但隐含语义分析技术会计算出物品属于每个类的权重，因此每个物品都不是硬性地被分到某一个类中。</li><li>编辑很难给出多维度的分类，但隐含语义分析技术给出的每个分类都不是同一个维度的，它是基于用户的共同兴趣计算出来的，如果用户的共同兴趣是某一个维度，那么LFM给出的类也是相同的维度。</li><li>编辑很难决定一个物品在某一个分类中的权重，但隐含语义分析技术可以通过统计用户行为决定物品在每个类中的权重，如果喜欢某个类的用户都会喜欢某个物品，那么这个物品在这个类中的权重就可能比较高。</li></ul><p>隐含语义分析技术从诞生到今天产生了很多著名的模型和方法，其中和该技术相关且耳熟能详的名词有pLSA、LDA、隐含类别模型（latent class model）、隐含主题模型（latent topic model）、矩阵分解（matrix factorization）。这些技术和方法在本质上是相通的，其中很多方法都可以用于个性化推荐系统。</p><p>LFM通过如下公式计算用户u对物品i的兴趣：$$Preference(u,i)=r_{ui}=p_u^Tq_i=\sum_{f=1}^F p_{u,k} q_{i,k}$$<br>这个公式中$p_{u,k}$和$q_{i,k}$是模型的参数，其中$p_{u,k}$度量了用户u的兴趣和第k个隐类的关系，而$q_{i,k}$度量了第k个隐类和物品i之间的关系。</p><p>要计算这两个参数，需要一个训练集，对于每个用户u，训练集里都包含了用户u喜欢的物品和不感兴趣的物品，通过学习这个数据集，就可以获得上面的模型参数。</p><p>LFM在显性反馈数据（也就是评分数据）上解决评分预测问题并达到了很好的精度。不过本章主要讨论的是隐性反馈数据集，这种数据集的特点是只有正样本（用户喜欢什么物品），而没有负样本（用户对什么物品不感兴趣）。<br>在隐性反馈数据集上应用LFM解决TopN推荐的第一个关键问题就是如何给每个用户生成负样本。 对于这个问题，Rong Pan在文章(参见“One-Class Collaborative Filtering”)中进行了深入探讨。他对比了如下几种方法。</p><ul><li>对于一个用户，用他所有没有过行为的物品作为负样本。</li><li>对于一个用户，从他没有过行为的物品中均匀采样出一些物品作为负样本。</li><li>对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证每个用户的正负样本数目相当。</li><li>对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，偏重采样不热门的物品。</li></ul><p>对于第一种方法，它的明显缺点是负样本太多，正负样本数目相差悬殊，因而计算复杂度很高，最终结果的精度也很差。对于另外3种方法，Rong Pan在文章中表示第三种好于第二种，而第二种好于第四种。</p><p>作者认为对负样本采样时应该遵循以下原则：</p><ul><li>对每个用户，要保证正负样本的平衡（数目相似）。</li><li>对每个用户采样负样本时，要选取那些很热门，而用户却没有行为的物品。</li></ul><p>下面的代码实现了负样本采样过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RandomSelectNegativeSample</span><span class="params">(self, items)</span>:</span></span><br><span class="line">    ret = dict() </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> items.keys():</span><br><span class="line">        ret[i] = <span class="number">1</span> </span><br><span class="line">    n = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(items) * <span class="number">3</span>): <span class="comment"># 将上限设为len(items) * 3，主要是保证正、负样本数量接近</span></span><br><span class="line">        item = items_pool[random.randint(<span class="number">0</span>, len(items_pool) - <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> ret:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ret[item] = <span class="number">0</span></span><br><span class="line">        n + = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; len(items): </span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>items_pool</code>维护了候选物品的列表，在这个列表中，物品i出现的次数和物品i的流行度成正比。<code>items</code>是一个dict，它维护了用户已经有过行为的物品的集合。因此，上面的代码按照物品的流行度采样出了那些热门的、但用户却没有过行为的物品。经过采样，可以得到一个用户—物品集$K = {(u,i)}$，其中如果$(u, i)$是正样本，则有$r_{ui}$ = 1，否则有$r_{ui}$ = 0 。然后， 需要优化如下的损失函数来找到最合适的参数p和q：$$C = \sum_{(u,i) \in K} (r_{ui} - \hat r_{ui})^2 =  \sum_{(u,i) \in K}(r_{ui} - \sum_{k=1}^K p_{u,k}q_{i,k})^2 + \lambda \Vert p_u \Vert^2 + \lambda \Vert q_i \Vert^2$$<br>这里$\lambda \Vert p_u \Vert^2 + \lambda \Vert q_i \Vert^2$用来防止过拟合的正则化项，$\lambda$可以通过实验获得。最小化上面的损失函数，可以利用随机梯度下降算法。该算法是最优化理论里最基础的优化算法，它首先通过求参数的偏导数找到最速下降方向，然后通过迭代法不断地优化参数。下面介绍优化方法的数学推导。</p><p>上面定义的损失函数里有两组参数$p_{u,k}$和$q_{i,k}$，随机梯度下降法需要首先对它们分别求偏导数，可以得到：$$\frac{\partial C}{\partial p_{uk}} = -2q_{ik} + 2\lambda p_{uk}$$ $$\frac{\partial C}{\partial q_{ik}} = -2p_{uk} + 2\lambda q_{ik}$$</p><p>然后，根据随机梯度下降法，需要将参数沿着最速下降方向向前推进，因此可以得到如下递推公式：$$p_{uk}=p_{uk} + \alpha(q_{ik}-\lambda p_{uk})$$ $$q_{ik} = q_{ik} + \alpha (p_{uk} - \lambda q_{ik})$$<br>其中，$\alpha$是学习速率(learning rate)，它的选取需要通过反复实验获得。</p><p>下面的Python代码实现了这一优化过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LatentFactorModel</span><span class="params">(user_items, F, N, alpha, lambda)</span>:</span></span><br><span class="line">    [P, Q] = InitModel(user_items, F) </span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">0</span>,N):</span><br><span class="line">        <span class="keyword">for</span> user, items <span class="keyword">in</span> user_items.items():</span><br><span class="line">           samples = RandSelectNegativeSamples(items) </span><br><span class="line">            <span class="keyword">for</span> item, rui <span class="keyword">in</span> samples.items():</span><br><span class="line">                eui = rui - Predict(user, item) </span><br><span class="line">                <span class="keyword">for</span> f <span class="keyword">in</span> range(<span class="number">0</span>, F):</span><br><span class="line">                    P[user][f] += alpha * (eui * Q[item][f] - \ <span class="keyword">lambda</span> * P[user][f]) </span><br><span class="line">                    Q[item][f] += alpha * (eui * P[user][f] - \ <span class="keyword">lambda</span> * Q[item][f])</span><br><span class="line">        alpha *= <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recommend</span><span class="params">(user, P, Q)</span>:</span></span><br><span class="line">    rank = dict() </span><br><span class="line">    <span class="keyword">for</span> f, puf <span class="keyword">in</span> P[user].items():</span><br><span class="line">        <span class="keyword">for</span> i, qfi <span class="keyword">in</span> Q[f].items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> rank: </span><br><span class="line">                rank[i] += puf * qfi </span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure></p><p>经过离线实验评测证明，LFM确实可以实现通过用户行为将物品聚类的功能。</p><p>在LFM中，重要的参数有4个：</p><ul><li>隐特征的个数F；</li><li>学习速率alpha；</li><li>正则化参数lambda；</li><li>负样本/正样本比例 ratio。</li></ul><p>通过实验发现， ratio 参数对LFM的性能影响最大。随着负样本数目的增加， LFM 的准确率和召回率有明显提高。 不过当ratio&gt;10以后，准确率和召回率基本就比较稳定了。同时，随着负样本数目的增加，覆盖率不断降低，而推荐结果的流行度不断增加，说明ratio参数控制了推荐算法发掘长尾的能力。当数据集非常稀疏时，LFM的性能会明显下降，甚至不如UserCF和ItemCF的性能。</p><h3 id="2-5-2-基于LFM的实际系统的例子"><a href="#2-5-2-基于LFM的实际系统的例子" class="headerlink" title="2.5.2 基于LFM的实际系统的例子"></a>2.5.2 基于LFM的实际系统的例子</h3><p>雅虎的研究人员公布过一个使用LFM进行雅虎首页个性化设计的方案(参见Bee-Chung Chen、Deepak Agarwal、Pradheep Elango和Raghu Ramakrishnan的“Latent Factor Models for Web Recommender Systems”)。</p><p>雅虎的研究人员以CTR作为优化目标，利用LFM来预测用户是否会单击一个链接。为此， 他们将用户历史上对首页上链接的行为记录作为训练集。其中，如果用户u单击过链接i，那么就定义$(u, i)$是正样本，即$r_{ui}$ = 1。如果链接i展示给用户u，但用户u从来没有单击过，那么就定义$(u, i)$是负样本，即$r_{ui}$ = -1。然后，雅虎的研究人员利用前文提到的LFM预测用户是否会单击链接：$$\hat r_{ui} = p_u^T \cdot q_i$$</p><p>LFM模型在实际使用中有一个困难，那就是它很难实现实时的推荐。经典的LFM模型每次训练时都需要扫描所有的用户行为记录，这样才能计算出用户隐类向量$p_u$和物品隐类向量$q_i$。而且LFM的训练需要在用户行为记录上反复迭代才能获得比较好的性能。因此，LFM的每次训练都很耗时，一般在实际应用中只能每天训练一次，并且计算出所有用户的推荐结果。从而LFM模型不能因为用户行为的变化实时地调整推荐结果来满足用户最近的行为。为了解决传统LFM不能实时化，而产品需要实时性的矛盾，雅虎的研究人员提出了一个解决方案。</p><p>他们的解决方案分为两个部分。首先，他们利用新闻链接的内容属性（关键词、类别等）得到链接i的内容特征向量$y_i$。其次，他们会实时地收集用户对链接的行为，并且用这些数据得到链接i的隐特征向量$q_i$。然后，他们会利用如下公式预测用户u是否会单击链接i：$$r_{ui} = x^T_u \cdot y_i + p_u^T \cdot q_i$$</p><p>其中，$y_i$是根据物品的内容属性直接生成的，$x_{uk}$是用户u对内容特征k的兴趣程度，用户向量$x_{u}$可以根据历史行为记录获得，而且每天只需要计算一次。而$p_u$、$q_i$是根据实时拿到的用户最近几小时的行为训练LFM获得的。因此，对于一个新加入的物品i，可以通过$ x^T_u \cdot y_i$估计用户u对物品i的兴趣，然后经过几个小时后，就可以通过$p_u^T \cdot q_i$得到更加准确的预测值。</p><h3 id="2-5-3-LFM和基于邻域的方法比较"><a href="#2-5-3-LFM和基于邻域的方法比较" class="headerlink" title="2.5.3 LFM和基于邻域的方法比较"></a>2.5.3 LFM和基于邻域的方法比较</h3><p>LFM是一种基于机器学习的方法，具有比较好的理论基础。这个方法和基于邻域的方法（比如UserCF、ItemCF）相比，各有优缺点。下面将从不同的方面对比LFM和基于邻域的方法。</p><ul><li><strong>理论基础</strong> LFM具有比较好的理论基础，它是一种学习方法，通过优化一个设定的指标建立最优的模型。基于邻域的方法更多的是一种基于统计的方法，并没有学习过程。</li><li><strong>离线计算的空间复杂度</strong> 基于邻域的方法需要维护一张离线的相关表。在离线计算相关表的过程中，如果用户/物品数很多，将会占据很大的内存。假设有M个用户和N个物品，在计算相关表的过程中，我们可能会获得一张比较稠密的临时相关表（尽管最终我们对每个物品只保留K个最相关的物品，但在中间计算过程中稠密的相关表是不可避免的），那么假设是用户相关表，则需要$O(M * M)$的空间，而对于物品相关表，则需要 $O(N * N)$的空间。而LFM在建模过程中，如果是F个隐类，那么它需要的存储空间是$O(F * (M+N))$，这在M和N很大时可以很好地节省离线计算的内存。</li><li><strong>离线计算的时间复杂度</strong> 假设有M个用户、N个物品、K条用户对物品的行为记录。那么，UserCF计算用户相关表的时间复杂度是$O(N * (K/N)^2)$，而ItemCF计算物品相关表的时间复杂度是$O(M * (K / M)^2)$。而对于LFM，如果用F个隐类，迭代S次，那么它的计算复杂度是$O(K * F * S)$。那么，如果$K / N &gt; F * S$，则代表UserCF的时间复杂度低于LFM ，如果$K / M&gt;F * S$，则说明ItemCF的时间复杂度低于LFM。在一般情况下，LFM的时间复杂度要稍微高于UserCF和ItemCF，这主要是因为该算法需要多次迭代。但总体上，这两种算法在时间复杂度上没有质的差别。</li><li><strong>在线实时推荐</strong> UserCF和ItemCF在线服务算法需要将相关表缓存在内存中，然后可以在线进行实时的预测。以ItemCF算法为例，一旦用户喜欢了新的物品，就可以通过查询内存中的相关表将和该物品相似的其他物品推荐给用户。因此，一旦用户有了新的行为， 而且该行为被实时地记录到后台的数据库系统中，他的推荐列表就会发生变化。而从LFM的预测公式可以看到，LFM在给用户生成推荐列表时，需要计算用户对所有物品的兴趣权重，然后排名，返回权重最大的N个物品。那么，在物品数很多时，这一过程的时间复杂度非常高，可达$O(M * N * F)$。因此，LFM不太适合用于物品数非常庞大的系统，如果要用，我们也需要一个比较快的算法给用户先计算一个比较小的候选列表，然后再用LFM重新排名。另一方面，LFM在生成一个用户推荐列表时速度太慢，因此不能在线实时计算，而需要离线将所有用户的推荐结果事先计算好存储在数据库中。因此，LFM不能进行在线实时推荐，也就是说，当用户有了新的行为后，他的推荐列表不会发生变化。</li><li><strong>推荐解释</strong> ItemCF算法支持很好的推荐解释，它可以利用用户的历史行为解释推荐结果。但LFM无法提供这样的解释，它计算出的隐类虽然在语义上确实代表了一类兴趣和物品，却很难用自然语言描述并生成解释展现给用户。</li></ul><h2 id="2-6-基于图的模型"><a href="#2-6-基于图的模型" class="headerlink" title="2.6 基于图的模型"></a>2.6 基于图的模型</h2><h3 id="2-6-1-用户行为数据的二分图表示"><a href="#2-6-1-用户行为数据的二分图表示" class="headerlink" title="2.6.1 用户行为数据的二分图表示"></a>2.6.1 用户行为数据的二分图表示</h3><p>在研究基于图的模型之前，首先需要将用户行为数据表示成图的形式。本章讨论的用户行为数据是由一系列二元组组成的，其中每个二元组$(u, i)$表示用户u对物品i产生过行为。<br>令$G(V,E)$表示用户物品二分图，其中$V = V_U \cup V_I$由用户顶点集合$V_U$和物品顶点集合$V_I$组成。对于数据集中每一个二元组$(u, i)$，图中都有一套对应的边$e(v_u,v_i)$，其中$v_u \in V_U$是用户u对应的顶点，$v_i \in V_I$是物品i对应的顶点。</p><h3 id="2-6-2-基于图的推荐算法"><a href="#2-6-2-基于图的推荐算法" class="headerlink" title="2.6.2 基于图的推荐算法"></a>2.6.2 基于图的推荐算法</h3><p>如果将个性化推荐算法放到二分图模型上，那么给用户u推荐物品的任务就可以转化为度量用户顶点$v_u$和与$v_u$没有边直接相连的物品节点在图上的相关性，相关性越高的物品在推荐列表中的权重就越高。</p><p>度量图中两个顶点之间相关性的方法很多，但一般来说图中顶点的相关性主要取决于下面3个因素：</p><ul><li>两个顶点之间的路径数；</li><li>两个顶点之间路径的长度；</li><li>两个顶点之间的路径经过的顶点。</li></ul><p>而相关性高的一对顶点一般具有如下特征：</p><ul><li>两个顶点之间有很多路径相连；</li><li>连接两个顶点之间的路径长度都比较短；</li><li>连接两个顶点之间的路径不会经过出度比较大的顶点。</li></ul><p>基于上面3个主要因素，研究人员设计了很多计算图中顶点之间相关性的方法(参见Fouss Francois、Pirotte Alain、Renders Jean-Michel和Saerens Marco的“Random-Walk Computation of Similarities between Nodes of a Graph with Application to Collaborative Recommendation”(IEEE Transactions on Knowl edge and Data Eng ineering, 2007))。本节将介绍一种基于随机游走的PersonalRank算法(参见Taher H .Haveliwala的“Topic-Sensitive PageRank”（WWW 2002, 2002）)。</p><p>假设要给用户u进行个性化推荐，可以从用户u对应的节点$v_u$开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照概率α决定是继续游走，还是停止这次游走并从$v_u$节点开始重新游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。这样，经过很多次随机游走后，每个物品节点被访问到的概率会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。</p><p>如果将上面的描述表示成公式，可以得到如下公式：<br>$$<br>PR(v) =<br>\begin{cases}<br>\alpha \sum_{v’ \in in(v)} \frac{PR(v’)}{\vert out(v’) \vert},  &amp;  (v \neq v_u) \\<br>(1- alpha) + \alpha \sum_{v’ \in in(v)} \frac{PR(v’)}{\vert out(v’) \vert}, &amp; (v = v_u)<br>\end{cases}<br>$$</p><p>下面的代码简单实现了上面的公式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PersonalRank</span><span class="params">(G, alpha, root)</span>:</span></span><br><span class="line">    rank = dict() </span><br><span class="line">    rank = &#123;x:<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> G.keys()&#125; </span><br><span class="line">    rank[root] = <span class="number">1</span> </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        tmp = &#123;x:<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> G.keys()&#125;</span><br><span class="line">        <span class="keyword">for</span> i, ri <span class="keyword">in</span> G.items():</span><br><span class="line">            <span class="keyword">for</span> j, wij <span class="keyword">in</span> ri.items():</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> tmp:</span><br><span class="line">                    tmp[j] = <span class="number">0</span> </span><br><span class="line">                tmp[j] += <span class="number">0.6</span> * rank[i] / (<span class="number">1.0</span> * len(ri)) </span><br><span class="line">                <span class="keyword">if</span> j == root:</span><br><span class="line">                    tmp[j] += <span class="number">1</span> - alpha</span><br><span class="line">        rank = tmp </span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure><p>虽然PersonalRank算法可以通过随机游走进行比较好的理论解释，但该算法在时间复杂度上有明显的缺点。因为在为每个用户进行推荐时，都需要在整个用户物品二分图上进行迭代，直到整个图上的每个顶点的PR值收敛。这一过程的时间复杂度非常高，不仅无法在线提供实时推荐，甚至离线生成推荐结果也很耗时。</p><p>为了解决PersonalRank每次都需要在全图迭代并因此造成时间复杂度很高的问题，给出两种解决方案。第一种就是减少迭代次数，在收敛之前就停止。这样会影响最终的精度，但一般来说影响不会特别大。另一种方法就是从矩阵论出发，重新设计算法。</p><p>对矩阵运算比较熟悉的读者可以轻松将PersonalRank转化为矩阵的形式。令M为用户物品二分图的转移概率矩阵，即：$$M(v, v’) = \frac {1}{\vert out(v) \vert}$$<br>进而迭代公式可以转化为：<br>$$<br>\begin{align}<br>r&amp; = (1-\alpha)r_0 + \alpha M^Tr \\<br>&amp; = (1-\alpha)(1-\alpha M^T)^{-1}r_0<br>\end{align}<br>$$</p><p>因此，只需要一次$(1-\alpha M^T)^{-1}​$，这里$1-\alpha M^T​$是稀疏矩阵。关于如何对稀疏矩阵快速求逆，可以参考矩阵计算方面的书籍和论文(比如Song Li的“Fast Algorithms For Sparse Matrix Inverse Compuataions”（2009）)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第2章-利用用户行为数据&quot;&gt;&lt;a href=&quot;#第2章-利用用户行为数据&quot; class=&quot;headerlink&quot; title=&quot;第2章 利用用户行为数据&quot;&gt;&lt;/a&gt;第2章 利用用户行为数据&lt;/h1&gt;&lt;p&gt;用户行为数据中蕴涵着很多不是那么显而易见的规律，而个性化推荐算法的任务就是通过计算机去发现这些规律，从而为产品的设计提供指导，提高用户体验。&lt;br&gt;基于&lt;strong&gt;用户行为分析&lt;/strong&gt;的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为&lt;strong&gt;协同过滤算法&lt;/strong&gt;。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://rilzob.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://rilzob.com/tags/Python/"/>
    
      <category term="推荐系统" scheme="https://rilzob.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统实践读书笔记（一）</title>
    <link href="https://rilzob.com/2018/11/23/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://rilzob.com/2018/11/23/推荐系统实践读书笔记（一）/</id>
    <published>2018-11-23T04:36:25.802Z</published>
    <updated>2018-11-24T12:25:10.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-好的推荐系统"><a href="#第1章-好的推荐系统" class="headerlink" title="第1章 好的推荐系统"></a>第1章 好的推荐系统</h1><p>在研究如何设计推荐系统前，了解什么是好的推荐系统至关重要。只有了解了优秀的推荐系统的特征，我们才能在设计推荐系统时根据实际情况进行取舍。</p><p>本章分3个步骤回答这个问题：</p><ol><li>首先介绍了什么是推荐系统、推荐系统的主要任务、推荐系统和分类目录以及搜索引擎的区别等；</li><li>然后按照不同领域分门别类地介绍目前业界常见的个性化推荐应用；</li><li>最后介绍推荐系统的评测，通过介绍评测指标给出“好”的定义，从而最终解答“什么是好的推荐系统”这个问题。</li></ol><a id="more"></a><h2 id="1-1-什么是推荐系统"><a href="#1-1-什么是推荐系统" class="headerlink" title="1.1 什么是推荐系统"></a>1.1 什么是推荐系统</h2><h3 id="推荐系统产生的背景"><a href="#推荐系统产生的背景" class="headerlink" title="推荐系统产生的背景"></a>推荐系统产生的背景</h3><p>随着信息技术和互联网的发展，人们逐渐从<strong>信息匮乏</strong>的时代走入了<strong>信息过载(overload)</strong>的时代。在这个时代，无论是信息消费者还是信息产生着都遇到了很大的挑战：作为信息消费者，如何从大量信息中找到自己感兴趣的信息是一件非常困难的的事情；作为信息产生者，如何让自己生产的信息脱颖而出，受到广大用户的关注，也是一件非常困难的事情。推荐系统就是解决这一矛盾的重要工具。</p><h3 id="推荐系统的任务"><a href="#推荐系统的任务" class="headerlink" title="推荐系统的任务"></a>推荐系统的任务</h3><p>推荐系统的任务就是联系用户和信息，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。</p><h3 id="推荐系统与搜索引擎的异同"><a href="#推荐系统与搜索引擎的异同" class="headerlink" title="推荐系统与搜索引擎的异同"></a>推荐系统与搜索引擎的异同</h3><p>众所周知，为了解决信息过载的问题，最具代表的解决方案是分类目录(雅虎)和搜索引擎(谷歌)。最初的分类目录网站将著名的网站分门别类，从而方便用户根据类别查找网站，然而随着互联网规模的不断扩大，门户网站也只能覆盖少量的热门网站，越来越不满足用户的需求。因此搜索引擎诞生了。但是搜索引擎需要用户主动提供准确的关键词来寻找信息，因此不能解决用户的很多其他需求，比如用户无法提供准确的关键词时，搜索引擎就无能为力了。</p><p>和搜索引擎一样，推荐系统也是一种帮助用户快速发现有用信息的工具。但和搜索引擎不同的是，推荐系统不需要用户提供明确的需求，而是通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐能够满足他们兴趣和需求的信息。因此从某种意义上说，推荐系统和搜索引擎对于用户来说是两个互补的工具。搜索引擎满足了用户有明确目的时的主动查找需求，而推荐系统能够在用户没有明确目的的时候他们发现感兴趣的新内容。</p><h3 id="生活中常见的推荐过程"><a href="#生活中常见的推荐过程" class="headerlink" title="生活中常见的推荐过程"></a>生活中常见的推荐过程</h3><p>以看电影为例：</p><ol><li>向朋友咨询。这种方式在推荐系统中称为<strong>社会化推荐(social recommendation)</strong>，即让好友给自己推荐物品。</li><li>寻找与自己之前看过的电影在内容上相似的电影。这种推荐方式在推荐系统中称为<strong>基于内容的推荐(content-based filtering)</strong>。</li><li>查看排行榜，看看别人都在看什么电影又或者看看和自己兴趣相近的人看什么电影。这种方式称为<strong>基于协同过滤(collaborative filtering)</strong>的推荐。</li></ol><p>从上面三种方法可以看出，推荐算法的<strong>本质</strong>是通过一定的方式将用户和物品联系起来，而不同的推荐系统利用了不同的方式。</p><h2 id="1-2-个性化推荐系统的应用"><a href="#1-2-个性化推荐系统的应用" class="headerlink" title="1.2 个性化推荐系统的应用"></a>1.2 个性化推荐系统的应用</h2><p>在互联网的各类网站中都可以看到推荐系统的应用，而个性化推荐系统在这些网站中的主要作用是通过分析大量用户行为日志，给不同用户提供不同的个性化页面展示，以提高网站的点击率和转化率。</p><p>尽管不同的网站使用不同的推荐系统技术，但总地来说，几乎所有推荐系统应用都是由<strong>前台的展示页面</strong>、<strong>后台的日志系统</strong>、<strong>推荐算法系统</strong>3部分构成。</p><h3 id="1-2-1-电子商务"><a href="#1-2-1-电子商务" class="headerlink" title="1.2.1 电子商务"></a>1.2.1 电子商务</h3><p>著名的电子商务网站亚马逊(Amazon)是个性化推荐系统的积极应用者和推广者。Amazon的推荐系统融入到了其各类产品中，其中最主要的应用是个性化商品推荐列表和相关商品的推荐列表。</p><h4 id="个性化推荐列表"><a href="#个性化推荐列表" class="headerlink" title="个性化推荐列表"></a>个性化推荐列表</h4><h5 id="基于物品的推荐算法-item-based-method"><a href="#基于物品的推荐算法-item-based-method" class="headerlink" title="基于物品的推荐算法(item-based method)"></a>基于物品的推荐算法(item-based method)</h5><p>该算法给用户用户推荐那些和他们之前喜欢的物品相似的物品。</p><h6 id="个性化推荐列表组成部分"><a href="#个性化推荐列表组成部分" class="headerlink" title="个性化推荐列表组成部分"></a>个性化推荐列表组成部分</h6><ol><li>推荐结果的标题、缩略图以及其他内容属性。</li><li>推荐结果的平均分。</li><li>推荐理由。并且允许用户修正这一推荐</li></ol><h5 id="基于好友的推荐算法"><a href="#基于好友的推荐算法" class="headerlink" title="基于好友的推荐算法"></a>基于好友的推荐算法</h5><p>该算法按照用户在Facebook的好友关系，给用户推荐他们的好友在亚马逊上喜欢的物品。<br>基于该种推荐算法生成的推荐列表的组成部分与基于物品的推荐列表类似，只不过这里的推荐理由换成了喜欢过相关物品的用户好友的头像。</p><h4 id="相关推荐列表"><a href="#相关推荐列表" class="headerlink" title="相关推荐列表"></a>相关推荐列表</h4><p>Amazon有两种相关商品列表：</p><ul><li>包含购买了这个商品的用户也经常购买的其他商品</li><li>包含浏览过这个商品的用户经常购买的其他商品</li></ul><p>这两种相关推荐列表的区别就是使用了不同用户行为计算物品的相关性。<br> 此外，相关推荐列表最重要的应用就是<strong>打包销售(cross selling)</strong>。</p><h3 id="1-2-2-电影和视频网站"><a href="#1-2-2-电影和视频网站" class="headerlink" title="1.2.2 电影和视频网站"></a>1.2.2 电影和视频网站</h3><p>代表公司Netflix、Youtube、Hulu。其中Netflix和Youtube的算法与Amazon的算法类似，也是基于物品的推荐算法，即给用户推荐和他们曾经喜欢的视频相似的视频。</p><h3 id="1-2-3-个性化音乐网络电台"><a href="#1-2-3-个性化音乐网络电台" class="headerlink" title="1.2.3 个性化音乐网络电台"></a>1.2.3 个性化音乐网络电台</h3><p>个性化推荐的成功应用需要两个条件：</p><ol><li>存在信息过载。因为如果用户可以很容易地从所有物品中找到喜欢的物品，就不需要个性化推荐了。</li><li>用户大部分时候没有特别明确的需求。因为用户如果有明确的需求，可以直接通过搜索引擎找到感兴趣的物品。</li></ol><p>在这两个条件下，个性化网络电台无疑是最合适的个性化推荐产品。<br>目前有很多知名的个性化音乐网络电台。国际上著名的有Pandora和Last.fm，国内的代表则是网易云音乐。这三种应用虽然都是个性化网络电台，但背后的技术却不太一样。</p><h4 id="Pandora"><a href="#Pandora" class="headerlink" title="Pandora"></a>Pandora</h4><p>Pandora背后的音乐推荐系统主要来自于一个叫做音乐基因工程的项目。Pandora的算法主要基于内容，其音乐家和研究人员亲自听了上万首来自不同歌手的歌，然后对歌曲的不同特性(比如旋律、节奏、编曲和歌词等)<br>进行标注，这些标注被称为音乐的基因。然后，Pandora会根据专家标注的基因计算歌曲的相似度，并给用户推荐和他之前喜欢的音乐在基因上相似的其他音乐。</p><h4 id="Last-fm"><a href="#Last-fm" class="headerlink" title="Last.fm"></a>Last.fm</h4><p>Last.fm记录了所有用户的听歌记录以及用户对歌曲的反馈，在这一基础上计算出不同用户在歌曲上的喜好相似度，从而给用户推荐和他有相似听歌爱好的其他用户喜欢的歌曲。同时，Last.fm也建立了一个社交网络，让用户能够和其他用户建立联系，同时也能让用户给好友推荐自己喜欢的歌曲。和Pandora相比，Last.fm没有使用专家标注，而是主要利用用户行为计算歌曲的相似度。</p><h4 id="音乐推荐的特点"><a href="#音乐推荐的特点" class="headerlink" title="音乐推荐的特点"></a>音乐推荐的特点</h4><p>2011年的Recsys大会专门要求了Pandora和研究人员对音乐推荐系统进行了演讲。演讲人总结了音乐推荐的如下特点：</p><ol><li>物品空间大；</li><li>消费每首歌的代价很小；</li><li>物品种类丰富；</li><li>听一首歌耗时很少；</li><li>物品重用率很高；</li><li>用户充满激情；</li><li>上下文相关；</li><li>次序很重要；</li><li>很多播放列表资源；</li><li>不需要用户全神贯注；</li><li>高度社会化；</li></ol><p>上面这些特点决定了音乐是一种非常适合用来推荐的物品。因此，尽管现在很多推荐系统都是作为一个应用存在与网站中，比如Amazon的商品推荐和Netflix的电影推荐，但唯有音乐推荐系统可以支持独立的个性化推荐网站，比如Pandora、Last.fm和豆瓣网络电台。</p><h3 id="1-2-4-社交网络"><a href="#1-2-4-社交网络" class="headerlink" title="1.2.4 社交网络"></a>1.2.4 社交网络</h3><p>社交网络中的个性化推荐主要应用于3个方面：</p><ol><li>利用用户的社交网络信息对用户进行个性化的物品推荐；</li><li>信息流的会话推荐；</li><li>给用户推荐好友；</li></ol><h3 id="1-2-5-个性化阅读"><a href="#1-2-5-个性化阅读" class="headerlink" title="1.2.5 个性化阅读"></a>1.2.5 个性化阅读</h3><p>个性化阅读同样符合前面提出的需要个性化推荐的两个因素：首先，互联网上的文章很多，用户面临信息过载的问题；其次，用户很多时候并没有必须看某篇具体文章的需求，他们只是想通过阅读特定领域的文章了解这些领域的动态。</p><h4 id="Google-Reader"><a href="#Google-Reader" class="headerlink" title="Google Reader"></a>Google Reader</h4><p>Google Reader是一款流行的社会化阅读工具。它允许用户关注自己感兴趣的人，然后看到所关注用户分享的文章。</p><h4 id="Zite"><a href="#Zite" class="headerlink" title="Zite"></a>Zite</h4><p>和Google Reader不同，个性化阅读工具Zite则是收集用户对文章的偏好信息。在每篇文章右侧，Zite都允许用户给出喜欢或不喜欢的反馈，然后通过分析用户的反馈数据不停地更新用户的个性化文章列表。</p><h4 id="Digg"><a href="#Digg" class="headerlink" title="Digg"></a>Digg</h4><p>Digg是一家著名的新闻阅读网站。Digg首先根据用户的Digg历史计算用户之间的兴趣相似度，然后给用户推荐和他兴趣相似的用户喜欢的文章。</p><h3 id="1-2-6-基于位置的服务"><a href="#1-2-6-基于位置的服务" class="headerlink" title="1.2.6 基于位置的服务"></a>1.2.6 基于位置的服务</h3><p>随着移动设备的飞速发展，用户的位置信息已经非常容易获取，而位置是一种很重要的上下文信息，基于位置给用户推荐离他近的且他感兴趣的服务，用户就更有可能去消费。</p><h4 id="Foursquare"><a href="#Foursquare" class="headerlink" title="Foursquare"></a>Foursquare</h4><p>基于位置的服务往往和社交网络结合在一起。其中Foursquare推出了探索功能，给用户推荐好友在附近的行为。</p><h3 id="1-2-7-个性化邮件"><a href="#1-2-7-个性化邮件" class="headerlink" title="1.2.7 个性化邮件"></a>1.2.7 个性化邮件</h3><p>使对用户重要的邮件能够让用户优先浏览。</p><h4 id="Tapestry"><a href="#Tapestry" class="headerlink" title="Tapestry"></a>Tapestry</h4><p>目前在文献中能够查到的第一个推荐系统Tapestry就是一个个性化邮件推荐系统，它通过分析用户阅读邮件的历史行为和习惯对新邮件进行重新排序，从而提高用户的工作效率。</p><h3 id="1-2-8-个性化广告"><a href="#1-2-8-个性化广告" class="headerlink" title="1.2.8 个性化广告"></a>1.2.8 个性化广告</h3><p>个性化广告投放目前已经成为了一门独立的学科——计算广告，但该学科和推荐系统在很多基础理论和方法上是相通的，比如它们的目的都是联系用户和物品，只是在个性化广告中，物品就是广告。</p><h4 id="个性化广告投放和狭义个性化推荐的区别"><a href="#个性化广告投放和狭义个性化推荐的区别" class="headerlink" title="个性化广告投放和狭义个性化推荐的区别"></a>个性化广告投放和狭义个性化推荐的区别</h4><p>个性化推荐着重于帮助用户找到可能令他们感兴趣的物品，而广告推荐着重于帮助广告找到可能对它们感兴趣的用户，即一个是以用户为核心，而另一个是以广告为核心。</p><h4 id="个性化广告投放技术"><a href="#个性化广告投放技术" class="headerlink" title="个性化广告投放技术"></a>个性化广告投放技术</h4><p>目前个性化广告投放技术主要分为3种：</p><ol><li><strong>上下文广告</strong>。通过分析用户正在浏览的网页内容，投放和网页内容相关的广告。代表系统是谷歌的Adsense。</li><li><strong>搜索广告</strong>。通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告。</li><li><strong>个性化展示广告</strong>。我们经常在很多网站看到大量的展示广告(就是那些大的横幅图片)，它们是根据用户的兴趣，对不同用户投放不同的展示广告。</li></ol><p>Yahoo发表了大量个性化广告方面的论文，而最成功的则是Facebook。</p><h2 id="1-3-推荐系统评测"><a href="#1-3-推荐系统评测" class="headerlink" title="1.3 推荐系统评测"></a>1.3 推荐系统评测</h2><p>一个完整的推荐系统一般存在3个参与方：用户、物品提供者和提供推荐系统的网站。同时好的推荐系统设计，能够让推荐系统本身收集到高质量的用户反馈，不断完善推荐的质量，增加用户和网站的交互，提高网站的收入。因此在评测一个推荐算法时，需要同时考虑三方的利益，一个好的推荐系统是能够令三方共赢的系统。<br>在推荐系统的早期研究中，很多人将好的推荐系统定义为能够作出准确预测的推荐系统。但是，后来很多研究表明，准确的预测并不代表好的推荐。举个极端点的例子，某推荐系统预测明天太阳将从东方升起，虽然预测准确率为100%，却是一种没有意义的预测。所以，好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西。<br>为了全面评测推荐系统对三方利益的影响，本章从不同角度出发，提出不同的指标。</p><h3 id="1-3-1-推荐系统实验方法"><a href="#1-3-1-推荐系统实验方法" class="headerlink" title="1.3.1 推荐系统实验方法"></a>1.3.1 推荐系统实验方法</h3><p>首先介绍计算和获得这些指标的主要实验方法。推荐系统中主要有3种评测推荐效果的实验方法，即<strong>离线实验(offline experiment)、用户调查(user study)和在线实验(online experiment)</strong>。</p><h4 id="离线实验"><a href="#离线实验" class="headerlink" title="离线实验"></a>离线实验</h4><h5 id="离线实验的方法"><a href="#离线实验的方法" class="headerlink" title="离线实验的方法"></a>离线实验的方法</h5><p>离线实验的方法一般由如下几个步骤构成：</p><ol><li>通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集；</li><li>将数据集按照一定的规则分成训练集和测试集；</li><li>在训练集上训练用户兴趣模型，在测试集上进行预测；</li><li>通过事先定义的离线指标评测算法评测在测试集上的预测结果。</li></ol><p>从上面的步骤可以看到，推荐系统的离线实验都是在数据集上完成的，也就是说它不需要一个实际的系统来供它实验，而只要有一个从实验系统日志中提取的数据集即可。</p><h5 id="离线实验的优缺点"><a href="#离线实验的优缺点" class="headerlink" title="离线实验的优缺点"></a>离线实验的优缺点</h5><p>这种实验方法的好处是不需要真实用户参与，可以直接快速地计算出来，从而方便、快速地测试大量不同的算法。<br>它的主要缺点是无法获得很多商业上关注的指标，如点击率、转化率等，而找到和商业指标非常相关的离线指标也是很困难的事情。</p><h4 id="用户调查"><a href="#用户调查" class="headerlink" title="用户调查"></a>用户调查</h4><p>用户调查是推荐系统评测的一个重要工具，很多离线时没有办法评测的与用户主观感受有关的指标都可以通过用户调查获得。</p><h5 id="用户调查的方法"><a href="#用户调查的方法" class="headerlink" title="用户调查的方法"></a>用户调查的方法</h5><p>用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。</p><h5 id="用户调查的优缺点"><a href="#用户调查的优缺点" class="headerlink" title="用户调查的优缺点"></a>用户调查的优缺点</h5><p>它的优点是可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。<br>缺点是招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。此外，在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。</p><h4 id="在线实验"><a href="#在线实验" class="headerlink" title="在线实验"></a>在线实验</h4><p>在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试，将它和旧的算法进行比较。</p><h5 id="在线实验的方法"><a href="#在线实验的方法" class="headerlink" title="在线实验的方法"></a>在线实验的方法</h5><p>AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同用户的各种不同的评测指标比较不同算法。</p><blockquote><p>网站<a href="http://www.abtests.com/给出了很多通过实际AB测试提高网站用户满意度的例子，从中我们可以学习到如何进行合理的AB测试。" target="_blank" rel="noopener">http://www.abtests.com/给出了很多通过实际AB测试提高网站用户满意度的例子，从中我们可以学习到如何进行合理的AB测试。</a></p></blockquote><h5 id="在线实验的优缺点"><a href="#在线实验的优缺点" class="headerlink" title="在线实验的优缺点"></a>在线实验的优缺点</h5><p>AB测试的优点是可以公平获得不同算法实际在线时的性能指标，包括商业上关注的指标。<br>AB测试的缺点主要是周期比较长，必须进行长期的实验才能得到可靠的结果。因此一般不会用AB测试测试所有的算法，而只是用它测试那些在离线实验和用户调查中表现很好的算法。其次，一个大型网站的AB测试系统的设计也是一项复杂的工程。</p><p>一般来说，一个新的推荐算法最终上线，需要完成上面所说的3个实验。</p><ol><li>首先，需要通过离线实验证明它在很多离线指标上优于现有的算法。</li><li>然后，需要通过用户调查确定它的用户满意度不低于现有的算法。</li><li>最后，通过在线的AB测试确定它在我们关心的指标上优于现有的算法。</li></ol><h3 id="1-3-2-评测指标"><a href="#1-3-2-评测指标" class="headerlink" title="1.3.2 评测指标"></a>1.3.2 评测指标</h3><h4 id="1-用户满意度"><a href="#1-用户满意度" class="headerlink" title="1.用户满意度"></a>1.用户满意度</h4><p> 用户作为推荐系统的重要参与者，其满意度是评测推荐系统的最重要指标。但是，用户满意度没有办法离线计算，只能通过用户调查或在线实验方式获得。<br> 用户调查获得用户满意度主要是通过调查问卷的形式。用户对推荐系统的满意度分为不同的层次。因此在设计问卷时需要考虑到用户各方面的感受，这样用户才能针对问题给出自己准确的回答。<br> 在在线系统中，用户满意度主要通过一些对用户行为的统计得到。更一般的情况下，我们可以用点击率、用户停留时间和转化率等指标度量用户的满意度。</p><h4 id="2-预测准确度"><a href="#2-预测准确度" class="headerlink" title="2.预测准确度"></a>2.预测准确度</h4><p> 预测准确度度量一个推荐系统或者推荐算法预测用户行为的能力。<br> 计算方法：在计算该指标时需要有一个离线的数据集，该数据集包含用户的历史行为记录。然后，将该数据集通过时间分为训练集和测试集。最后，通过在训练集上建立用户的行为和兴趣模型预测用户在测试集上的行为，并计算预测行为和测试集上实际行为的重合度作为预测准确度。<br> 不同的研究方向有不同的预测准确度指标。</p><h5 id="评分预测"><a href="#评分预测" class="headerlink" title="评分预测"></a>评分预测</h5><p> 预测用户对物品评分的行为称为评分预测。<br> 评分预测的预测准确度一般通过<strong>均方根误差(RMSE)</strong>和<strong>平均绝对误差(MAE)</strong>计算。对于测试集中的一个用户u和物品i，令$r_{ui}$是用户u对物品i的实际评分，而$\hat r_{ui}$是推荐算法给出的预测评分，那么RMSE的定义为：$$RMSE = \frac {\sqrt{\sum_{u,i \in T} (r_{ui} - \hat r_{ui})^2}}{|T|}$$</p><p>MAE采用绝对值计算预测误差，它的定义为：$$MAE=\frac{\sum_{u,i \in T}|r_{ui}-\hat r_{ui}|} {|T|}$$</p><p>假设我们用一个列表<code>records</code>存放用户评分数据，令<code>records[i] = [u,i,rui,pui]</code>，其中<code>rui</code>是用户u对物品i的实际评分，<code>pui</code>是算法预测出来的用户u对物品i的评分，下面代码实现了RME和MAE的计算过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RMSE</span><span class="params">(records)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum([(rui - pui) * (rui - pui) <span class="keyword">for</span> u,i,rui,pui <span class="keyword">in</span> records])/float(len(records)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAE</span><span class="params">(records)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([abs(rui-pui) <span class="keyword">for</span> u,i,rui,pui <span class="keyword">in</span> records])/float(len(records))</span><br></pre></td></tr></table></figure><p>关于RMSE和MAE这两个指标的优缺点，Netflix认为RMSE加大了对预测不准的用户物品评分的惩罚(平方项的惩罚)，因而对系统的评测更加苛刻。研究表明，如果评分系统是基于基数建立的(即用户给的评分都是整数)，那么对预测结果取整可能会降低MAE的误差。 </p><h5 id="TopN推荐"><a href="#TopN推荐" class="headerlink" title="TopN推荐"></a>TopN推荐</h5><p>网站在提供推荐服务时，一般是给用户一个个性化的推荐列表，这种推荐叫做TopN推荐。TopN推荐的预测准确率一般通过准确率(precision)/召回率(recall)度量。<br>$R(u)$是根据用户在训练集上的行为给用户作出的推荐列表，而$T(u)$是用户在测试集上的行为列表。那么，推荐结果的召回率定义为：$$Recall=\frac {\sum_{u \in U} |R(u) \cap T(u)|}{\sum_{u \in U} |T(u)|} $$<br>推荐结果的准确率定义为：$$Precision=\frac {\sum_{u \in U} |R(u) \cap T(u)|}{\sum_{u \in U} |R(u)|} $$<br>下面的Python代码同时计算出了一个推荐算法的准确率和召回率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrecisionRecall</span><span class="params">(test, N)</span>:</span></span><br><span class="line">    hit = <span class="number">0</span></span><br><span class="line">    n_recall = <span class="number">0</span></span><br><span class="line">    n_precision = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> user, items <span class="keyword">in</span> test.items():</span><br><span class="line">        rank = Recommend(user, N)</span><br><span class="line">        hit += len(rank &amp; item)  <span class="comment"># hit是推荐列表与行为列表相交的部分</span></span><br><span class="line">        n_recall += len(items)  </span><br><span class="line">        n_precision += N</span><br><span class="line">        <span class="keyword">return</span> [hit/(<span class="number">1.0</span>*n_recall),hit/(<span class="number">1.0</span>*n_precision)]</span><br></pre></td></tr></table></figure><p>有的时候，为了全面评测TopN推荐的准确率和召回率，一般会选取不同的推荐列表长度N，计算出一组准确率和召回率，然后画出准确率/召回率曲线(precision/recall curve)。</p><h5 id="关于评分预测和TopN推荐的讨论"><a href="#关于评分预测和TopN推荐的讨论" class="headerlink" title="关于评分预测和TopN推荐的讨论"></a>关于评分预测和TopN推荐的讨论</h5><p>评分预测一直是推荐系统研究的热点，绝大多数推荐系统的研究都是基于用户评分数据的评分预测。这主要是因为，一方面推荐系统的早期研究组GroupLens的研究主要就是基于电影评分 数据MovieLens进行的，其次，Netflix大赛也主要面向评分预测问题。因而，很多研究人员都将 研究精力集中在优化评分预测的RMSE上。</p><p>对此，亚马逊前科学家Greg Linden有不同的看法。2009年, 他在Communications of the ACM 网站发表了一篇文章 (“What is a Good Recommendation Algorithm？”,参见<a href="http://cacm.acm.org/blogs/blog-cacm/22925-what-is-a-goodrecommendation-algorithm/fulltext/" target="_blank" rel="noopener">http://cacm.acm.org/blogs/blog-cacm/22925-what-is-a-goodrecommendation-algorithm/fulltext/</a>) ，指出电影推荐的目的是找到用户最有可能感兴趣的电影，而不是预测用户看了电影后会给电影什么样的评分。因此，TopN推荐更符合实际的应用需求。也许有一部电影用户看了之后会给很高的分数，但用户看的可能性非常小。因此，预测用户是否会看一部电影， 应该比预测用户看了电影后会给它什么评分更加重要。因此，本书主要也是讨论TopN推荐。</p><h4 id="3-覆盖度"><a href="#3-覆盖度" class="headerlink" title="3.覆盖度"></a>3.覆盖度</h4><p>覆盖度(coverage)描述一个推荐系统对物品长尾的发掘能力。覆盖率有不同的定义方法，最简单的定义为推荐系统能够推荐出来的物品占总物品集合的比例。假设系统的用户集合为$U$，推荐系统给每个用户推荐一个长度为N的物品列表$R(u)$。那么推荐系统的覆盖率可以通过下面的公式计算：$$Coverage=\frac{| \bigcup_{u \in U} R(u)|}{|I|}$$<br>从上面的定义可以看到，覆盖率是一个内容提供商会关心的指标。一个好的推荐系统不仅需要有比较高的用户满意度，也要有较高的覆盖率。<br>但是上面的定义过于粗略。覆盖率为100%的系统可以有无数的物品流行度分布。为了更细致地描述推荐系统发掘长尾的能力，需要统计推荐列表中不同物品出现次数的分布。如果所有的物品都出现在推荐列表中，且出现的次数差不多，那么推荐系统发掘长尾的能力就很好。因此，可以通过研究物品在推荐列表中出现次数的分布描述推荐系统挖掘长尾的能力。如果这个分布比较平，那么说明推荐系统的覆盖率较高，而如果这个分布较陡峭，说明推荐系统的覆盖率较低。在信息论和经济学中有两个著名的指标可以用来定义覆盖率。<br>第一个是<strong>信息熵</strong>：$$H = -\sum_{i=1}^n p(i) \log p(i)$$<br>这里$p(i)$是物品i的流行度除以所有物品的流行度之和。<br>第二个是<strong>基尼系数(Gini Index)</strong>：$$G = \frac{1}{n-1} \sum_{j=1}^n (2j-n-1)p(i_j)$$<br>这里$i_j$是按照物品流行度$p()$从小到大排序的物品列表中第j个物品。<br>下面代码用来计算给定物品流行度分布后的基尼系数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GiniIndex</span><span class="params">(p)</span>:</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    n = len(p)</span><br><span class="line">    G = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item, weight <span class="keyword">in</span> sorted(p.items(), key=itemgetter(<span class="number">1</span>)):</span><br><span class="line">        G += (<span class="number">2</span> * j - n - <span class="number">1</span>) * weight</span><br><span class="line">    <span class="keyword">return</span> G / float(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/23/推荐系统实践读书笔记（一）/屏幕快照 2018-11-24 下午2.58.23.png" alt="基尼系数的计算原理"></p><p>社会学领域有一个著名的马太效应，即所谓强者更强，弱者更弱的效应。推荐系统的初衷是希望消除马太效应，使得各种物品都能被展示给对它们感兴趣的某一类人群。但是，很多研究表明现在主流的推荐算法（比如协同过滤算法）是具有马太效应的。评测推荐系统是否具有马太效应的简单办法就是使用基尼系数。如果G1是从初始用户行为中计算出的物品流行度的基尼系数，G2是从推荐列表中计算出的物品流行度的基尼系数，那么如果G2 &gt; G1，就说明推荐算法具有马太效应。</p><h4 id="4-多样性"><a href="#4-多样性" class="headerlink" title="4.多样性"></a>4.多样性</h4><p>为了满足用户广泛的兴趣，推荐列表需要能够覆盖用户不同的兴趣领域，即推荐结果需要具有多样性。多样性推荐列表的好处用一句俗话表述就是“不在一棵树上吊死”。尽管用户的兴趣在较长的时间跨度中是一样的，但具体到用户访问推荐系统的某一刻，其兴趣往往是单一的，那么如果推荐列表只能覆盖用户的一个兴趣点，而这个兴趣点不是用户这个时刻的兴趣点，推荐列表就不会让用户满意。反之，如果推荐列表比较多样，覆盖了用户绝大多数的兴趣点，那么就会增加用户找到感兴趣物品的概率。因此给用户的推荐列表也需要满足用户广泛的兴趣，即具有多样性。<br>多样性描述了推荐列表中物品两两之间的不相似性。因此，多样性和相似性是对应的。假设$s(i,j) \in [0,1]$定义了物品i和j之间的相似度，那么用户u的推荐列表$R(u)$的多样性定义如下：$$Diversity=1-\frac {\sum_{i,j \in R(u),i \neq j} s(i,j)}{\frac{1}{2}|R(u)|(|R(u)|-1)}$$<br>而推荐系统的整体多样性可以定义为所有用户推荐列表多样性的平均值：$$Diversity=\frac{1}{|U|} \sum_{u \in U}Diversity(R(u))$$<br>从上面的定义可以看到，不同的物品相似度度量函数$s(i, j)$可以定义不同的多样性。如果用内容相似度描述物品间的相似度，我们就可以得到内容多样性函数，如果用协同过滤的相似度函数描述物品间的相似度，就可以得到协同过滤的多样性函数。</p><h4 id="5-新颖性"><a href="#5-新颖性" class="headerlink" title="5.新颖性"></a>5.新颖性</h4><p>新颖的推荐是指给用户推荐那些他们以前没有听说过的物品。在一个网站中实现新颖性的最简单办法是，把那些用户之前在网站中对其有过行为的物品从推荐列表中过滤掉。<br>O’scar Celma在博士论文“Music Recommendation and Discovery in the Long Tail”(参见“Music Recommendation and Discovery in the Long Tail”，地址为<a href="http://mtg.upf.edu/static/media/PhD_ocelma.pdf" target="_blank" rel="noopener">http://mtg.upf.edu/static/media/PhD_ocelma.pdf</a>) 中研究了新颖度的评测。评测新颖度的最简单方法是利用推荐结果的平均流行度，因为越不热门的物品越可能让用户觉得新颖。因此，如果推荐结果中物品的平均热门程度较低，那么推荐结果就可能有比较高的新颖性。<br>但是，用推荐结果的平均流行度度量新颖性比较粗略，因为不同用户不知道的东西是不同的。因此，要准确地统计新颖性需要做用户调查。<br>最近几年关于多样性和新颖性的研究越来越受到推荐系统研究人员的关注。ACM的推荐系统会议在2011年有一个专门的研讨会讨论推荐的多样性和新颖性。 (参见“International Workshop on Novelty and Diversity in Recommender Systems”，地址为<a href="http://ir.ii.uam.es/divers2011/" target="_blank" rel="noopener">http://ir.ii.uam.es/divers2011/</a>) 该研讨会的组织者认为，通过牺牲精度来提高多样性和新颖性是很容易的，而困难的是如何在不牺牲精度的情况下提高多样性和新颖性。关心这两个指标的读者可以关注一下这个研讨会最终发表的论文。</p><h4 id="6-惊喜度"><a href="#6-惊喜度" class="headerlink" title="6.惊喜度"></a>6.惊喜度</h4><p>惊喜度（serendipity）是最近这几年推荐系统领域最热门的话题。惊喜度和新颖度作为推荐系统的指标，它们之间的区别并非两个词在中文里含义的区别而是意义上的区别。<br>可以举一个例子说明这两种指标的区别。假设一名用户喜欢周星驰的电影，然后我们给他推荐了一部叫做《临歧》的电影（该电影是1983年由刘德华、周星驰、梁朝伟合作演出的，很少有人知道这部有周星驰出演的电影），而该用户不知道这部电影，那么可以说这个推荐具有新颖性。但是，这个推荐并没有惊喜度，因为该用户一旦了解了这个电影的演员，就不会觉得特别奇怪。但如果我们给用户推荐张艺谋导演的《红高粱》，假设这名用户没有看过这部电影，那么他看完这部电影后可能会觉得很奇怪，因为这部电影和他的兴趣一点关系也没有，但如果用户看完电影<br>后觉得这部电影很不错，那么就可以说这个推荐是让用户惊喜的。这个例子的原始版本来自于Guy Shani的论文(参见Guy Shani和 Asela Gunawardana的“Evaluating Recommendation Systems”) ，他的基本意思就是，如果推荐结果和用户的历史兴趣不相似，但却让用户觉得满意，那么就可以说推荐结果的惊喜度很高，而推荐的新颖性仅仅取决于用户是否听说过这个推荐结果。<br>目前并没有什么公认的惊喜度指标定义方式，这里只给出一种定性的度量方式。上面提到，令用户惊喜的推荐结果是和用户历史上喜欢的物品不相似，但用户却觉得满意的推荐。那么，定义惊喜度需要首先定义推荐结果和用户历史上喜欢的物品的相似度，其次需要定义用户对推荐结果的满意度。前面也曾提到，用户满意度只能通过问卷调查或者在线实验获得，而推荐结果和用户历史上喜欢的物品相似度一般可以用内容相似度定义。也就是说，如果获得了一个用户观看电影的历史，得到这些电影的演员和导演集合A，然后给用户推荐一个不属于集合A的导演和演员创作的电影，而用户表示非常满意，这样就实现了一个惊喜度很高的推荐。因此提高推荐惊喜度需要提高推荐结果的用户满意度，同时降低推荐结果和用户历史兴趣的相似度。惊喜度的问题最近几年获得了学术界的一定关注，但这方面的工作还不是很成熟。相关工作可以参考Yuan Cao Zhang等的论文(参见Yuan Cao Zhang、Diarmuid Ó Séaghdha、Daniele Quercia和 Tamas Jambor的“Auralist: introducing serendipity into music recommendation.”)和Tomoko Murakami等的论文 (参见Tomoko Murakami、 Koichiro. Mori和Ryohei Orihara的“ Metrics for evaluating the serendipity of recommendationlists”)。</p><h4 id="7-信任度"><a href="#7-信任度" class="headerlink" title="7.信任度"></a>7.信任度</h4><p>对于基于机器学习的自动推荐系统，同样存在信任度（trust）的问题，如果用户信任推荐系统，那就会增加用户和推荐系统的交互。<br>度量推荐系统的信任度只能通过问卷调查的方式，询问用户是否信任推荐系统的推荐结果。<br>提高推荐系统的信任度主要有两种方法。首先需要增加推荐系统的透明度(transparency)(参见Henriette Cramer、Vanessa Evers、 Satyan Ramlal、 Maarten van Someren、Lloyd Rutledge、 Natalia Stash、Lora Aroyo和Bob Wielinga的“ The effects of transparency on trust in and acceptance of a content-based art recommender”) ， 而增加推荐系统透明度的主要办法是提供推荐解释。只有让用户了解推荐系统的运行机制，让用 户认同推荐系统的运行机制，才会提高用户对推荐系统的信任度。其次是考虑用户的社交网络 信息，利用用户的好友信息给用户做推荐，并且用好友进行推荐解释。这是因为用户对他们的 好友一般都比较信任，因此如果推荐的商品是好友购买过的，那么他们对推荐结果就会相对比较信任。<br>关于推荐系统信任度的研究(参见Paolo Massa和 Paolo Avesani的“Trust-aware recommender systems”)主要集中在评论网站Epinion的推荐系统上。这是因为Epinion创建了一套用户之间的信任系统来建立用户之间的信任关系，帮助用户判断是否信任当前用户对某一个商品的评论。</p><h4 id="8-实时性"><a href="#8-实时性" class="headerlink" title="8.实时性"></a>8.实时性</h4><p>在很多网站中，因为物品（新闻、微博等）具有很强的时效性，所以需要在物品还具有时效性时就将它们推荐给用户。<br>推荐系统的实时性包括两个方面。首先，推荐系统需要实时地更新推荐列表来满足用户新的行为变化。很多推荐系统都会在离线状态每天计算一次用户推荐列表，然后于在线期间将推荐列表展示给用户。这种设计显然是无法满足实时性的。与用户行为相应的实时性，可以通过推荐列表的变化速率来评测。如果推荐列表在用户有行为后变化不大，或者没有变化，说明推荐系统的实时性不高。<br>实时性的第二个方面是推荐系统需要能够将新加入系统的物品推荐给用户。这主要考验了推荐系统处理物品冷启动的能力。</p><h4 id="9-健壮性"><a href="#9-健壮性" class="headerlink" title="9.健壮性"></a>9.健壮性</h4><p>健壮性（即robust,鲁棒性）指标衡量了一个推荐系统抗击作弊的能力。<br>算法健壮性的评测主要利用模拟攻击。首先，给定一个数据集和一个算法，可以用这个算法给这个数据集中的用户生成推荐列表。然后，用常用的攻击方法向数据集中注入噪声数据，然后利用算法在注入噪声后的数据集上再次给用户生成推荐列表。最后，通过比较攻击前后推荐列表的相似度评测算法的健壮性。如果攻击后的推荐列表相对于攻击前没有发生大的变化，就说明算法比较健壮。<br>在实际系统中，提高系统的健壮性，除了选择健壮性高的算法，还有以下方法。</p><ul><li>设计推荐系统时尽量使用代价比较高的用户行为。</li><li>在使用数据前，进行攻击检测，从而对数据进行清理。</li></ul><h4 id="10-商业目标"><a href="#10-商业目标" class="headerlink" title="10.商业目标"></a>10.商业目标</h4><p>不同的网站会根据自己的盈利模式设有不同的商业目标。因此，设计推荐系统时需要考虑最终的商业目标，而网站使用推荐系统的目的除了满足用 户发现内容的需求，也需要利用推荐系统加快实现商业上的指标。</p><h4 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h4><p><img src="/2018/11/23/推荐系统实践读书笔记（一）/屏幕快照 2018-11-24 下午2.59.19.png" alt="总结获取各种评测指标的途径"><br>对于可以离线优化的指标，作者的看法是应该在给定覆盖率、多样性、新颖性等限制条件下，尽量优化预测准确度。用一个数学公式表达，离线实验的优化目标是：<br>​                最大化预测准确度<br>​                使得 覆盖率 &gt; A<br>​                    多样性 &gt; B<br>​                    新颖性 &gt; C<br>其中，A、B、C的取值应该视不同的应用而定。</p><h3 id="1-3-3-评测维度"><a href="#1-3-3-评测维度" class="headerlink" title="1.3.3 评测维度"></a>1.3.3 评测维度</h3><p>除了应该考虑评测指标，还应考虑评测维度。增加评测维度的目的就是知道一个推荐算法在什么情况下性能最好。这样可以为融合不同推荐算法取得最好的整体性能带来参考。<br>一般情况下，评测维度分为如下3种：</p><ul><li><strong>用户维度</strong>：主要包括用户的人口统计学信息、活跃度以及是不是新用户等。</li><li><strong>物品维度</strong>：包括物品的属性信息、流行度、平均分以及是不是新加入的物品等。</li><li><strong>时间维度</strong>：包括季节，是工作日还是周末，是白天还是晚上等。</li></ul><p>如果能够在推荐系统评测报告中包含不同维度下的系统评测指标，就能帮我们全面地了解推荐系统性能，找到一个看上去比较弱的算法的优势，发现一个看上去比较强的算法的缺点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章-好的推荐系统&quot;&gt;&lt;a href=&quot;#第1章-好的推荐系统&quot; class=&quot;headerlink&quot; title=&quot;第1章 好的推荐系统&quot;&gt;&lt;/a&gt;第1章 好的推荐系统&lt;/h1&gt;&lt;p&gt;在研究如何设计推荐系统前，了解什么是好的推荐系统至关重要。只有了解了优秀的推荐系统的特征，我们才能在设计推荐系统时根据实际情况进行取舍。&lt;/p&gt;
&lt;p&gt;本章分3个步骤回答这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先介绍了什么是推荐系统、推荐系统的主要任务、推荐系统和分类目录以及搜索引擎的区别等；&lt;/li&gt;
&lt;li&gt;然后按照不同领域分门别类地介绍目前业界常见的个性化推荐应用；&lt;/li&gt;
&lt;li&gt;最后介绍推荐系统的评测，通过介绍评测指标给出“好”的定义，从而最终解答“什么是好的推荐系统”这个问题。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://rilzob.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://rilzob.com/tags/Python/"/>
    
      <category term="推荐系统" scheme="https://rilzob.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一次顿悟</title>
    <link href="https://rilzob.com/2018/11/11/%E4%B8%80%E6%AC%A1%E9%A1%BF%E6%82%9F/"/>
    <id>https://rilzob.com/2018/11/11/一次顿悟/</id>
    <published>2018-11-11T08:51:35.146Z</published>
    <updated>2018-11-11T08:54:48.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直都在搞怎么让百度收录我的Blog的问题，最后也没有解决，耽误了两三天的时间。为什么Google就能爬取Github Pages，百度就不行呢，忍不住去吐槽(这个事真是烦死我)，对了还有Coding也是个坑。</p><p>在解决这个期间也有所思考，并且得到一个顿悟(大喜)，就是人如果想成功就要在高维度上努力而不是低维度。<a id="more"></a></p><p>人的时间都是有限的，并且假设所有人的资质都是相同的(当然是不可能的)，如果能尽可能地节省时间，那么相比其他人就会走得更远。换句话说就是尽可能地让前进的步子迈得更大。说这话什么意思呢?举个例子，如果你高中三年努力考上了清华北大，可能就会比研究生考上清北的人节省出三四年甚至更多的时间。为什么？因为你高中同样花了三年的时间，大学花去了四年时间才和人家只花高中三年的人站在同一高度，有可能还低一些，那么人家是不是比你少花了三四年呢？拿三年换七年血赚啊，谁都明白这个道理。</p><p>上升一个层次再去思考这个问题。有的人本科阶段很努力每天都在研究编程，编程技术很厉害，就比如我。但另一些人会去研究论文，刷绩点，准备出国留学。两者的努力程度是一样的，如果两种人的目标是相同的，那么很明显后者到达目标的速度会明显比前者快很多，这就是努力层次的问题。前者是在低维度努力，而后者是在高纬度努力，类似于高处的人比低处的人看得更远。更形象地距举例就是一个人在高抬腿向前跑，而另一个人则是大跨步向前跑。为什么说前者是低维度而后者是高维度呢？因为前者所做的是有一定经验的人都能去做的，虽然短期可能会得到更现实的成就感，但从长远来看后者所做的开创性研究是不可替代的，更牛逼。</p><p>令人伤心地是之前的我就是第一种人，而我本科前两年的努力都是高抬腿跑。我已经落后很多了。但凡事都有两面性，好的一方面是现在的我意识到了这点，于是我坚定了我要考研清华的决心，只有这样我才能追回来一些时间。相比那些保研的同学我还有一个优势，就是别无选择，我不会因为目标的不确定而恍惚。</p><p>背水一战，向死而生。希望我自己能谨记这次顿悟，会受益匪浅。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直都在搞怎么让百度收录我的Blog的问题，最后也没有解决，耽误了两三天的时间。为什么Google就能爬取Github Pages，百度就不行呢，忍不住去吐槽(这个事真是烦死我)，对了还有Coding也是个坑。&lt;/p&gt;
&lt;p&gt;在解决这个期间也有所思考，并且得到一个顿悟(大喜)，就是人如果想成功就要在高维度上努力而不是低维度。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://rilzob.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中常用的内置函数</title>
    <link href="https://rilzob.com/2018/11/09/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>https://rilzob.com/2018/11/09/Python中常用的内置函数/</id>
    <published>2018-11-09T01:04:38.129Z</published>
    <updated>2018-11-09T01:25:23.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中常用的内置函数"><a href="#Python中常用的内置函数" class="headerlink" title="Python中常用的内置函数"></a>Python中常用的内置函数</h1><p>Python内置函数(built-in)是随着Python解释器的运行而被创建的。在Python程序中，你可以随时调用这些函数，而且不需要定义。在开发过程中，合理地使用这些内置函数能极大地提升你的开发效率。</p><p>这篇文章是对我在开发过程中经常遇到的内置函数的用法总结。<a id="more"></a></p><h2 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate()函数"></a>enumerate()函数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合成一个索引序列，同时列出数据和数据下标，一般用于for循环中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enumerate(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>sequence: 一个序列、迭代器或其他可迭代对象。</li><li>start: 下标开始位置。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回enumerate(枚举)对象。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">'Spring'</span>), (<span class="number">2</span>, <span class="string">'Summer'</span>), (<span class="number">3</span>, <span class="string">'Fall'</span>), (<span class="number">4</span>, <span class="string">'Winter'</span>)]</span><br></pre></td></tr></table></figure><h4 id="普通的for循环"><a href="#普通的for循环" class="headerlink" title="普通的for循环"></a>普通的for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> seq:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, seq[i]</span><br><span class="line"><span class="meta">... </span>    i +=<span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure><h4 id="for循环使用enumerate"><a href="#for循环使用enumerate" class="headerlink" title="for循环使用enumerate()"></a>for循环使用enumerate()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, element</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure><h2 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance()函数"></a>isinstance()函数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><code>isinstance()</code>函数用来判断一个对象是否是一个已知类型，类似<code>type()</code>。</p><blockquote><p> <em><code>isinstance()</code>和<code>type()</code>的区别：</em></p><ul><li><em><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系；</em></li><li><em><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系；</em></li></ul><p><em>如果要判断两个类型是否相同推荐使用<code>isinstance()</code></em></p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isinstance(object, classinfo)</span><br></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>object: 实例对象;</li><li>classinfo: 可以直接或间接是类名、基本类型或者由它们组成的元组；</li></ul><p><em>说明：</em></p><p><em>对于基本类型来说classinfo可以是：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int, float, bool, complex, str(字符串), list, dict(字典), set, tuple</span><br></pre></td></tr></table></figure><p><em>要注意的是，classinfo的字符串是<strong>str</strong>而不是<strong>string</strong>，字典也是简写<strong>dict</strong>。</em></p><p><em>实例：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg=<span class="number">123</span></span><br><span class="line">isinstance(arg, int)    <span class="comment">#输出True</span></span><br><span class="line">isinstance(arg, str)    <span class="comment">#输出False</span></span><br><span class="line">isinstance(arg, string) <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>如果对象的类型与classinfo的类型相同则返回True，否则返回False。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance (a,int)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance (a,str)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance (a,(str,int,list))    <span class="comment"># 是元组中的一个返回 True</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h4 id="type与instance的区别"><a href="#type与instance的区别" class="headerlink" title="type与instance的区别"></a>type与instance的区别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">isinstance(A(), A)    <span class="comment"># returns True</span></span><br><span class="line">type(A()) == A        <span class="comment"># returns True</span></span><br><span class="line">isinstance(B(), A)    <span class="comment"># returns True</span></span><br><span class="line">type(B()) == A        <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中常用的内置函数&quot;&gt;&lt;a href=&quot;#Python中常用的内置函数&quot; class=&quot;headerlink&quot; title=&quot;Python中常用的内置函数&quot;&gt;&lt;/a&gt;Python中常用的内置函数&lt;/h1&gt;&lt;p&gt;Python内置函数(built-in)是随着Python解释器的运行而被创建的。在Python程序中，你可以随时调用这些函数，而且不需要定义。在开发过程中，合理地使用这些内置函数能极大地提升你的开发效率。&lt;/p&gt;
&lt;p&gt;这篇文章是对我在开发过程中经常遇到的内置函数的用法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的列表生成式</title>
    <link href="https://rilzob.com/2018/11/05/Python%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/"/>
    <id>https://rilzob.com/2018/11/05/Python中的列表生成式/</id>
    <published>2018-11-05T13:28:09.197Z</published>
    <updated>2018-11-05T13:31:49.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的列表生成式"><a href="#Python中的列表生成式" class="headerlink" title="Python中的列表生成式"></a>Python中的列表生成式</h1><p>顾名思义，<strong>列表生成式</strong>就是用来生成列表的特定语法形式的表达式。列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。<a id="more"></a></p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><h3 id="基础语法格式"><a href="#基础语法格式" class="headerlink" title="基础语法格式"></a>基础语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable]</span><br></pre></td></tr></table></figure><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>迭代iterable中的每个元素；</li><li>每次迭代都先把结果赋值给iter_var，然后通过exp得到一个新的计算值；</li><li>最后所有通过exp得到的计算值以一个新的列表的形式返回；</li></ul><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable:</span><br><span class="line">    L.append(exp)</span><br></pre></td></tr></table></figure><h3 id="带过滤功能的语法格式"><a href="#带过滤功能的语法格式" class="headerlink" title="带过滤功能的语法格式"></a>带过滤功能的语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable if_exp]</span><br></pre></td></tr></table></figure><h4 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>迭代iterable中的每个元素，每次迭代都先判断if_exp表达式是否成立，即判断将iter_var代入if_exp后表达式的结果，如果为真则进行下一步，如果为假则进行下一次迭代；</li><li>把迭代结果赋值给iter_var，然后通过exp得到一个新的计算值；</li><li>最后把所有通过exp得到的计算值以一个新列表的形式返回；</li></ul><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable:</span><br><span class="line">    if_exp:</span><br><span class="line">        L.append(exp)</span><br></pre></td></tr></table></figure><h3 id="循环嵌套的语法格式"><a href="#循环嵌套的语法格式" class="headerlink" title="循环嵌套的语法格式"></a>循环嵌套的语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp <span class="keyword">for</span> iter_var_A <span class="keyword">in</span> iterable_A <span class="keyword">for</span> iter_var_B <span class="keyword">in</span> iterable_B]</span><br></pre></td></tr></table></figure><h4 id="工作过程-2"><a href="#工作过程-2" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>迭代iterable_A中的每个元素，但是每迭代iterable_A中的一个元素，就把iterable_B中的所有元素都迭代一遍；</li><li>将每次迭代的变量iterable_var_A和iterable_var_B传入表达式exp(当然可以只传入两者之一)，计算出结果；</li><li>最后把所有通过exp得到的结果以一个新的列表的形式返回；</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>其实列表生成式是Python中的一种“语法糖”，也就是说列表生成式是Python提供的一种生成列表的简洁形式，应用列表生成式可以快速生成一个新的list。它最主要的应用场景是：<strong>根据已存在的可迭代对象推导出一个新的list</strong>。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>我们可以对几个生成列表的要求分别通过“不使用列表生成式”和“使用列表生成式”来实现，然后做个对比总结。</p><h3 id="实例1：生成一个从3到10的数字列表"><a href="#实例1：生成一个从3到10的数字列表" class="headerlink" title="实例1：生成一个从3到10的数字列表"></a>实例1：生成一个从3到10的数字列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list1 = list(range(<span class="number">3</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list2 = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h3 id="实例2：生成一个2n-1的数字列表，n为从3到10的数字"><a href="#实例2：生成一个2n-1的数字列表，n为从3到10的数字" class="headerlink" title="实例2：生成一个2n+1的数字列表，n为从3到10的数字"></a>实例2：生成一个2n+1的数字列表，n为从3到10的数字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list3 = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">11</span>):</span><br><span class="line">    list3.append(<span class="number">2</span>*n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list4 = [<span class="number">2</span>*n + <span class="number">1</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h3 id="实例3：过滤出指定的数字列表中的值大于20的元素"><a href="#实例3：过滤出指定的数字列表中的值大于20的元素" class="headerlink" title="实例3：过滤出指定的数字列表中的值大于20的元素"></a>实例3：过滤出指定的数字列表中的值大于20的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">33</span>, <span class="number">26</span>, <span class="number">57</span>, <span class="number">99</span>]</span><br><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list5 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">20</span>:</span><br><span class="line">        list5.append(x)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list6 = [x <span class="keyword">for</span> x <span class="keyword">in</span> L <span class="keyword">if</span> x &lt; <span class="number">20</span>]</span><br></pre></td></tr></table></figure><h3 id="实例4：计算两个集合的全排列，并将结果保存至一个新的列表中"><a href="#实例4：计算两个集合的全排列，并将结果保存至一个新的列表中" class="headerlink" title="实例4：计算两个集合的全排列，并将结果保存至一个新的列表中"></a>实例4：计算两个集合的全排列，并将结果保存至一个新的列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L1 = [<span class="string">'香蕉'</span>, <span class="string">'苹果'</span>, <span class="string">'橙子'</span>]</span><br><span class="line">L2 = [<span class="string">'可乐'</span>, <span class="string">'牛奶'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list7 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L1:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> L2:</span><br><span class="line">        list7.append((x,y))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list8 = [(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> L1 <span class="keyword">for</span> y <span class="keyword">in</span> L2]</span><br></pre></td></tr></table></figure><h3 id="实例5：将一个字典转换成由一组元组组成的列表，元组的格式为-key-value"><a href="#实例5：将一个字典转换成由一组元组组成的列表，元组的格式为-key-value" class="headerlink" title="实例5：将一个字典转换成由一组元组组成的列表，元组的格式为(key,  value)"></a>实例5：将一个字典转换成由一组元组组成的列表，元组的格式为(key,  value)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D = &#123;<span class="string">'Tom'</span>: <span class="number">15</span>, <span class="string">'Jerry'</span>: <span class="number">18</span>, <span class="string">'Peter'</span>: <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list9 = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> D.items():</span><br><span class="line">    list9.append((k, v))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list10 = []</span><br><span class="line">list10 = [(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> D.items()]</span><br></pre></td></tr></table></figure><p>可见，在一些情况下使用列表生成式确实要方便、简洁很多，使用一行代码就搞定了。</p><h2 id="列表生成式与map、filter等高阶函数对比"><a href="#列表生成式与map、filter等高阶函数对比" class="headerlink" title="列表生成式与map、filter等高阶函数对比"></a>列表生成式与map、filter等高阶函数对比</h2><p>列表生成式的功能与之前文章提到的<code>map()</code>和<code>filter()</code>高阶函数功能很像，比如下面两个例子：</p><h3 id="实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样"><a href="#实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样" class="headerlink" title="实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样"></a>实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'TOM'</span>, <span class="string">'Peter'</span>, <span class="number">10</span>, <span class="string">'Jerry'</span>]</span><br><span class="line"><span class="comment"># 用列表生成式实现</span></span><br><span class="line">list1 = [x.lower() <span class="keyword">if</span> isinstance(x, str) <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> L]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用map()函数实现</span></span><br><span class="line">list2 = list(map(<span class="keyword">lambda</span> x : x.lower() <span class="keyword">if</span> isinstance(x, str) <span class="keyword">else</span> x, L))</span><br></pre></td></tr></table></figure><h3 id="实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除"><a href="#实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除" class="headerlink" title="实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除"></a>实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'TOM'</span>, <span class="string">'Peter'</span>, <span class="number">10</span>, <span class="string">'Jerry'</span>]</span><br><span class="line"><span class="comment"># 用列表生成式实现</span></span><br><span class="line">list3 = [x.lower() <span class="keyword">for</span> x <span class="keyword">in</span> L <span class="keyword">if</span> isinstance(x, str)] </span><br><span class="line"><span class="comment"># 注意：这里for x in L相对if isinstance的先后位置，与上一个示例相比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用map()和filter()函数实现</span></span><br><span class="line">list4 = list(map(<span class="keyword">lambda</span> x: x.lower(), filter(<span class="keyword">lambda</span> x: isinstance(x, str), L)))</span><br></pre></td></tr></table></figure><p>对于大部分需求来讲，使用列表生成式和使用高阶函数都能实现。但是<code>map</code>和<code>filter</code>等一些高阶函数在Python3.x中的返回值类型变成了Iterator(迭代器)对象，这对于那些元素数量很大或无限的可迭代对象来说显然是更合适的，因为可以避免不必要的内存空间浪费。</p><blockquote><p>引用文章：</p><ol><li><a href="https://www.cnblogs.com/yyds/p/6281453.html" target="_blank" rel="noopener">Python之列表生成式、生成器、可迭代对象与迭代器 - 云游道士 - 博客园</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431779637539089fd627094a43a8a7c77e6102e3a811000" target="_blank" rel="noopener">列表生成式 - 廖雪峰的官方网站</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的列表生成式&quot;&gt;&lt;a href=&quot;#Python中的列表生成式&quot; class=&quot;headerlink&quot; title=&quot;Python中的列表生成式&quot;&gt;&lt;/a&gt;Python中的列表生成式&lt;/h1&gt;&lt;p&gt;顾名思义，&lt;strong&gt;列表生成式&lt;/strong&gt;就是用来生成列表的特定语法形式的表达式。列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的装饰器</title>
    <link href="https://rilzob.com/2018/11/04/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://rilzob.com/2018/11/04/Python中的装饰器/</id>
    <published>2018-11-04T05:34:51.795Z</published>
    <updated>2018-11-04T05:46:29.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的装饰器"><a href="#Python中的装饰器" class="headerlink" title="Python中的装饰器"></a>Python中的装饰器</h1><p>装饰器本质上是一个<strong>Python函数</strong>，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的<strong>返回值也是一个函数对象</strong>。</p><p>它经常用于有切面需求的场景，比如：插入日志、性能检测、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能无关的雷同代码并继续重用。概括地讲，装饰器的作用就是为已经存在对象添加额外的功能。<a id="more"></a></p><p>先看一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br></pre></td></tr></table></figure><p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line">    logging.info(<span class="string">"foo is running"</span>)</span><br></pre></td></tr></table></figure><p>如果有些函数也有类似的需求，怎么做？都写一个logging在函数内？这样就造成了大量雷同的代码，为了减少重复写代码，可以这么做，重新定义一个函数专门处理日志，日志处理完之后再执行真正的业务代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">    func()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line">use_logging(bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>逻辑上不难理解，但这样的话，我们每次都要将一个函数作为参数传递给<code>use_logging</code>函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行<code>bar()</code>，但是现在不得不改成<code>use_logging(bar)</code>。那么有没有更好的方式呢？当然有，答案就是<strong>装饰器</strong>。</p><h2 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line">    </span><br><span class="line">bar = use_logging(bar)</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>函数<code>use_logging</code>就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像<code>bar</code>被<code>logging</code>包起来，被装饰了。在这个例子中，函数进入和退出时，被称为一个横切面(Aspect)，这种编程方法称为<strong>面向切面的编程(Aspect-Oriented Programming)</strong>。</p><p><strong>@符号是装饰器的语法糖</strong>，在定义函数的时候使用，避免再一次赋值操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line">    </span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>如上所示，使用@符号我们就可以省去<code>bar = use_logging(bar)</code>这一句了，直接调用<code>bar()</code>即可得到想要的结果。如果我们有其他的类似函数，我们就可以继续调用装饰器来修饰函数，而不用重新修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p><p><em>装饰器在Python中使用如此方便都要归功于Python的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他的变量，可以作为返回值，可以被定义在另一个函数内。</em></p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器还有更大的灵活性，例如带参数的装饰器：在上面的装饰器调用中，比如<code>@use_logging</code>，该装饰器唯一的参数就是执行业务的函数。装饰器的语法云溪我们在调用时，提供其他参数比如<code>@decorator(a)</code>。这样，就为装饰器的编写和使用提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</span><br><span class="line">                logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'foo'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"i am %s"</span> % name)</span><br><span class="line">    </span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>上面的<code>use_logging</code>是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我们使用<code>@use_logging(level=&quot;warn&quot;)</code>调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大，高内聚，封装性等优点。使用类装饰器还可以依赖类内部的<code>__call__</code>方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'class decorator running'</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        print(<span class="string">'class decorator ending'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'bar'</span>)</span><br><span class="line">    </span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># class decorator running</span></span><br><span class="line"><span class="comment"># bar</span></span><br><span class="line"><span class="comment"># class decorator ending</span></span><br></pre></td></tr></table></figure><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><p>使用装饰器极大地复用了代码，但是它有个缺点就是原函数的元信息不见了，比如函数的<code>docstring</code>、<code>__name__</code>、参数列表，先看例子：</p><p>装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">"was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''do some math'''</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br></pre></td></tr></table></figure><p>该函数完全等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''do some math'''</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line">f = logged(f)</span><br></pre></td></tr></table></figure><p>不难发现，函数<code>f</code>被<code>with_logging</code>替代了，当然它的<code>docstring</code>、<code>__name__</code>就变成了<code>with_logging</code>函数的信息了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(f.__name__)</span><br><span class="line">print(f.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># with_logging</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure><p>这个问题就比较严重了，好在我们有<code>function.wraps</code>，<code>wraps</code>本身也是一个装饰器，它能把<strong>原函数的元信息拷贝到装饰器函数中</strong>，这使得装饰器函数也有和原函数一样的元信息了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">"was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''do some math'''</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line">print(f.__name__)</span><br><span class="line">print(f.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># f</span></span><br><span class="line"><span class="comment"># do some math</span></span><br></pre></td></tr></table></figure><h2 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a>内置装饰器</h2><p><code>@staticmethod</code>、<code>@classmethod</code>、<code>@property</code></p><p>装饰器的顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure><blockquote><p>引用资料：</p><ol><li><a href="https://www.zhihu.com/question/26930016" target="_blank" rel="noopener">如何理解Python装饰器？ - 知乎</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的装饰器&quot;&gt;&lt;a href=&quot;#Python中的装饰器&quot; class=&quot;headerlink&quot; title=&quot;Python中的装饰器&quot;&gt;&lt;/a&gt;Python中的装饰器&lt;/h1&gt;&lt;p&gt;装饰器本质上是一个&lt;strong&gt;Python函数&lt;/strong&gt;，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的&lt;strong&gt;返回值也是一个函数对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它经常用于有切面需求的场景，比如：插入日志、性能检测、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能无关的雷同代码并继续重用。概括地讲，装饰器的作用就是为已经存在对象添加额外的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的Lambda函数及其用法</title>
    <link href="https://rilzob.com/2018/11/01/Python%E4%B8%AD%E7%9A%84Lambda%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95/"/>
    <id>https://rilzob.com/2018/11/01/Python中的Lambda函数及其用法/</id>
    <published>2018-11-01T11:11:40.177Z</published>
    <updated>2018-11-01T11:17:16.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的Lambda函数及其用法"><a href="#Python中的Lambda函数及其用法" class="headerlink" title="Python中的Lambda函数及其用法"></a>Python中的Lambda函数及其用法</h1><p><strong>Lambda函数</strong>又称为匿名函数，<strong>匿名函数</strong>就是没有名字的函数。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就可以将其定义为匿名函数。</p><p>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<a id="more"></a></p><p>先来看个简单的lambda函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x102bc1c80</span>&gt;</span><br></pre></td></tr></table></figure><p><code>x</code>和<code>y</code>是函数的两个参数，冒号后面的表达式是函数的返回值，很明显这个匿名函数就是在求两个变量的和，但作为一个函数，没有名字如何使用呢？</p><p>这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x, y : x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x102bc2140</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>它等同于常规函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add1</span><br><span class="line">&lt;function add1 at <span class="number">0x102bc1c80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="lambda函数的使用场景-函数式编程"><a href="#lambda函数的使用场景-函数式编程" class="headerlink" title="lambda函数的使用场景(函数式编程)"></a>lambda函数的使用场景(函数式编程)</h2><h3 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h3><p>例如：一个整数列表，要求按照列表中元素的绝对值大小升序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">-4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">-6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=<span class="keyword">lambda</span> x: abs(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>]</span><br></pre></td></tr></table></figure><p>排序函数<code>sorted</code>支持接收一个函数作为参数，该参数作为<code>sorted</code>的排序依据，这里按照列表元素的绝对值进行排序。</p><p>当然，也可以通过普通函数来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> abs(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=foo)</span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>]</span><br></pre></td></tr></table></figure><p>只不过是使用这种方式，代码看起来不够<strong>Pythonic</strong>而已。</p><p><em>lambda：这是Python支持的一种有趣的语法，它允许你快速定义单行的最小函数，可以用在任何需要函数的地方:</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x,y : x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="keyword">lambda</span> x,y:x+y)(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="map-reduce-filter函数"><a href="#map-reduce-filter函数" class="headerlink" title="map,reduce,filter函数"></a>map,reduce,filter函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求1~20的平方</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x:x*x,range(<span class="number">1</span>,<span class="number">21</span>))) </span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>, <span class="number">144</span>, <span class="number">169</span>, <span class="number">196</span>, <span class="number">225</span>, <span class="number">256</span>, <span class="number">289</span>, <span class="number">324</span>, <span class="number">361</span>, <span class="number">400</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求1~20之间的偶数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x:x%<span class="number">2</span> == <span class="number">0</span>,range(<span class="number">1</span>,<span class="number">21</span>))) </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求1~100之和,再加上10000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x+y,range(<span class="number">1</span>,<span class="number">101</span>),<span class="number">10000</span>)</span><br><span class="line"><span class="number">15050</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><em>闭包：一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域也依然能被访问到。</em></p><p>看一个用lambda函数作为闭包的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x+n <span class="comment"># 将匿名函数作为返回值返回</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add2 = add(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add2(<span class="number">15</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>这里的<code>lambda</code>函数就是一个闭包，在全局作用域范围中，<code>add2(15)</code>可以正常执行且返回值为20。之所以返回20是因为在<code>add</code>局部作用域中，变量n的值在闭包的作用下也可以被访问到。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431843456408652233b88b424613aa8ec2fe032fd85a000" target="_blank" rel="noopener">匿名函数 - 廖雪峰的官方网站</a></li><li><a href="https://www.cnblogs.com/huangbiquan/p/8030298.html" target="_blank" rel="noopener">深入理解Lambda函数及其用法 - 碧水幽幽泉 - 博客园</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的Lambda函数及其用法&quot;&gt;&lt;a href=&quot;#Python中的Lambda函数及其用法&quot; class=&quot;headerlink&quot; title=&quot;Python中的Lambda函数及其用法&quot;&gt;&lt;/a&gt;Python中的Lambda函数及其用法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Lambda函数&lt;/strong&gt;又称为匿名函数，&lt;strong&gt;匿名函数&lt;/strong&gt;就是没有名字的函数。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就可以将其定义为匿名函数。&lt;/p&gt;
&lt;p&gt;匿名函数有个限制，就是&lt;strong&gt;只能有一个表达式&lt;/strong&gt;，不用写&lt;code&gt;return&lt;/code&gt;，返回值就是该表达式的结果。&lt;/p&gt;
&lt;p&gt;用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的高阶函数</title>
    <link href="https://rilzob.com/2018/10/29/Python%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://rilzob.com/2018/10/29/Python中的高阶函数/</id>
    <published>2018-10-29T15:06:28.791Z</published>
    <updated>2018-10-30T01:40:04.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的高阶函数"><a href="#Python中的高阶函数" class="headerlink" title="Python中的高阶函数"></a>Python中的高阶函数</h1><p>在熟悉了Python基础知识后，我们已经可以做一些脚本开发，或者简单的程序。然而，当我们开发较为复杂的程序时，仅使用基础知识内容就会显得比较吃力。这时，了解Python中的一些高级特性会使我们的开发过程变得简单和快乐。</p><p>在函数式编程中，我们可以将函数当做变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为<strong>高阶函数(Higher-order-Functions)</strong>。</p><a id="more"></a><p>看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(g, arr)</span>:</span></span><br><span class="line"><span class="keyword">return</span> [g(x) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br></pre></td></tr></table></figure><p>上面的代码中<code>func</code>是一个高阶函数，它接收两个参数，第一个参数是函数，第二个参数是数组，<code>func</code>的功能是将函数g逐个作用于数组arr上，并返回一个新的数组。比如，我们可以这样用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr1 = func(double, list) <span class="comment"># arr1 = [2, 4, 6, 8]</span></span><br><span class="line">arr2 = func(square, list) <span class="comment"># arr2 = [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p>说到高阶函数，就不得不提到<strong>闭包</strong>，这里介绍一下Python中闭包的定义：</p><blockquote><p>如果在一个内部函数里，对外部作用域(但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包(closure)。</p></blockquote><p>就拿此例来说，内部函数<code>double</code>中包含了对函数<code>func</code>中局部变量<code>list</code>的引用，这就是闭包。</p><p><code>map</code> <code>reduce</code> <code>filter</code> <code>sorted</code>是Python中较为常用的内置高阶函数，它们为函数式编程提供了不少便利。</p><p><em>说明：本文介绍的内置高阶函数的定义可能会因为Python版本的不同而有所不同，文章以Python3.x版本中的定义为标准。</em></p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code>函数的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里函数一定要作为map的第一个参数，而不是第二个参数，否则会产生报错。</p><p><strong>解释</strong>：function函数会作用于可迭代对象的每一个元素，生成结果，并返回一个迭代器。更加具体一点说就是<code>map</code>函数接收两个参数，一个是函数，一个是Iterable，<code>map</code>将传入的函数依次作用到Iterable的每个元素，并把结果作为新的Iterator返回。</p><p>举例说明，比如我们一个函数f(x)=x^2，要把这个函数作用在一个list[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用<code>map()</code>实现。</p><p>现在，我们用Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p><code>map</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个Iterator，Iterator是惰性序列，因此需要通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p><p>你可能会想，不需要<code>map</code>函数，写一个循环，也可以计算出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:</span><br><span class="line">    L.append(f(n))</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure><p>的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？明显可读性就差了很多。</p><p>所以，<code>map</code>作为高阶函数，体现了Python的设计原则优雅、明确、简单，<strong>事实上它把运算规则抽象化</strong>。因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把list中的所有数字转化为字符串格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br></pre></td></tr></table></figure><p>只需一行代码。</p><p>看一些简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">&lt;map at <span class="number">0x106adfe48</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))   <span class="comment"># 使用 lambda</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]))</span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>再来看个复杂一点例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> *x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">funcs = [double, triple, square]  <span class="comment"># 列表元素是函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于 [double(4), triple(4), square(4)]</span></span><br><span class="line">value = list(map(<span class="keyword">lambda</span> f: f(<span class="number">4</span>), funcs))</span><br><span class="line">print(value)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure><p>最后我想要说明一点，迭代器有一个特点，就是所有的迭代器对象都可以作为<code>next()</code>内置函数的参数调用，每调用一次，就按角标顺序返回一个值，还是用代码讲吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter = map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：1</span></span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：4</span></span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：9</span></span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：16</span></span><br><span class="line">print(next(iter)) <span class="comment"># 抛出StopIteration 异常</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce</code>函数的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>reduce</code>函数必须接受两个参数，先将iterable的前两个item传给function，即function(item1, item2)，函数的返回值和iterable的下一个item再传给function，即function(function(item1, item2), item3)，如此迭代，直到iterable没有元素，如果有initializer，则作为初始值调用。</p><p>也就是说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br><span class="line"><span class="comment"># 列表中是以从左到右作为优先顺序</span></span><br></pre></td></tr></table></figure><p>看一些例子，就能很快理解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 相当于 ((1 * 2) * 3) * 4</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x - y, [<span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>], <span class="number">20</span>)  <span class="comment"># ((20 - 8) - 5) - 1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> (a &gt; b) <span class="keyword">else</span> b   <span class="comment"># 两两比较，取最大值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(f, [<span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span> <span class="comment"># 把序列[1, 3, 5, 7, 9]变换成整数13579</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code>函数用于过滤元素，它的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：和<code>map</code>类似，<code>filter</code>也接收一个函数和一个序列。但和<code>map</code>不同的是，<code>filter</code>把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。将function依次作用于iterable的每个item上，即function(item)，用function返回值为True的item构成iterator作为<code>filter</code>的最终返回值。</p><p>看一些例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>even_num = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>even_num</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd_num = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd_num</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x &lt; <span class="string">'g'</span>, <span class="string">'hijack'</span>))</span><br><span class="line"><span class="string">'ac'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x: x &lt; <span class="string">'g'</span>, <span class="string">'hijack'</span>)</span><br><span class="line">&lt;filter object at <span class="number">0x1034b4080</span>&gt;   <span class="comment"># python3</span></span><br></pre></td></tr></table></figure><p>可见用<code>filter</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p><p>注意到<code>filter</code>函数返回的同样是一个Iterator，也就是一个惰性序列，所以要强迫<code>filter</code>完成计算结果，需要用<code>list()</code>函数获得所有结果。</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p><code>sorted</code>函数用于对list进行排序，它的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable, *, key=<span class="keyword">None</span>, reverse=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>sorted</code>有两个可选参数，必须指定为关键字参数。将key指定的函数作用于iterable的每一个元素上，并根据key函数返回的结果进行排序，最终返回一个新的排序列表。key默认值为None，即直接比较元素大小。</p><p>reverse是一个布尔值。如果设置为True，则列表元素将按照比较结果相反的方式进行排序。</p><p>看一些例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>])</span><br><span class="line">[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</span><br><span class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</span><br><span class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</span><br></pre></td></tr></table></figure><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且核心代码可以保持得非常简洁。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>可接受其他函数作为参数的函数称为高阶函数；</li><li><code>map</code> <code>reduce</code> <code>filter</code> <code>sorted</code>为函数式编程提供了不少便利，可使代码变得更简洁；</li><li>通过<code>map()</code>来对Iterable中的每个元素进行相同的函数处理最终返回一个Iterator。</li><li><code>reduce()</code>类似栈的思想，先让栈顶的两个元素出栈作为函数的两个参数，再将函数的返回值入栈，然后再让栈顶两个元素出栈，不断循环下去，直到栈里没有元素为止。</li><li><code>filter()</code>的作用是从一个序列中筛选出符合条件的元素。由于<code>filter()</code>使用了惰性计算，所以只有在取<code>filter()</code>结果的时候，才会真正筛选并每次返回下一个筛出的元素。</li><li><code>sorted()</code>也是一个高阶函数。用<code>sorted()</code>排序的关键在于实现一个映射函数。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317849054170d563b13f0fa4ce6ba1cd86e18103f28000" target="_blank" rel="noopener">高阶函数 - 廖雪峰的官方网站</a></li><li><a href="http://wiki.jikexueyuan.com/project/explore-python/Functional/map_reduce_filter.html" target="_blank" rel="noopener">map/reduce/filter - Python 之旅 - 极客学院Wiki</a></li><li><a href="http://wiki.jikexueyuan.com/project/explore-python/Functional/high_order_func.html" target="_blank" rel="noopener">高阶函数 - Python 之旅 - 极客学院Wiki</a></li><li><a href="https://www.jianshu.com/p/bd595a0006cd" target="_blank" rel="noopener">Python笔记(二)：高级特性之高阶函数 - 简书</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的高阶函数&quot;&gt;&lt;a href=&quot;#Python中的高阶函数&quot; class=&quot;headerlink&quot; title=&quot;Python中的高阶函数&quot;&gt;&lt;/a&gt;Python中的高阶函数&lt;/h1&gt;&lt;p&gt;在熟悉了Python基础知识后，我们已经可以做一些脚本开发，或者简单的程序。然而，当我们开发较为复杂的程序时，仅使用基础知识内容就会显得比较吃力。这时，了解Python中的一些高级特性会使我们的开发过程变得简单和快乐。&lt;/p&gt;
&lt;p&gt;在函数式编程中，我们可以将函数当做变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为&lt;strong&gt;高阶函数(Higher-order-Functions)&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中@classmethod和@staticmethod的区别</title>
    <link href="https://rilzob.com/2018/10/27/Python%E4%B8%AD@classmethod%E5%92%8C@staticmethod%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/27/Python中@classmethod和@staticmethod的区别的副本/</id>
    <published>2018-10-27T04:46:02.147Z</published>
    <updated>2018-10-27T04:50:31.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中-classmethod和-staticmethod的区别"><a href="#Python中-classmethod和-staticmethod的区别" class="headerlink" title="Python中@classmethod和@staticmethod的区别"></a>Python中@classmethod和@staticmethod的区别</h1><p>接上一篇介绍<a href="https://rilzob.github.io/2018/10/27/Python%E4%B8%AD@staticmethod%E5%92%8C@classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/" target="_blank" rel="noopener">Python中@staticmethod和@classmethod的用法</a>的文章。虽然<code>@classmethod</code>和<code>@staticmethod</code>非常相似，但两个修饰符的使用情况仍<strong>略有不同</strong>。<a id="more"></a></p><p>从它们的使用上来看：</p><ul><li><code>@classmethod</code>必须引用一个类对象作为第一个参数，即第一个参数需要是表示自身类的cls参数。同时<code>@classmethod</code>因持有cls参数，所以可以调用类的属性，类的方法，实例化对象等，避免硬编码。</li><li><code>@staticmethod</code>则可以完全没有参数，但在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名()。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">"-"</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">date2 = Date.from_string(<span class="string">"27-10-2018"</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">"27-10-2018"</span>)</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>让我们假设这样一个类的例子，用来处理日期信息(这将是我们的样板)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br></pre></td></tr></table></figure><p>显然，这个类可以用来存储关于某些日期的信息(没有时区信息；假设所有日期都以UTC表示)。</p><p>这个类中有<code>__init__</code>，它是Python类实例的初始化方法，它接收参数作为类实例方法，具有第一个非可选参数<code>self</code>(作为对新创建实例的引用)。</p><h3 id="Class-Method"><a href="#Class-Method" class="headerlink" title="Class Method"></a>Class Method</h3><p>我们有一些任务，通过使用<code>@classmethod</code>可以很好地完成它们。</p><p><em>假设我们想要创建许多Date类实例，其日期信息来自外部输入(编码格式为’dd-mm-year’的字符串)，并假设我们必须在项目源代码的不同位置执行此操作。</em></p><p>所以我们这里必须做到：</p><ol><li>解析输入的字符串以接收日、月、年作为三个整数变量或由这些变量组成的三元组。</li><li>通过将上面求到的值传递给初始化调用来创建Date类实例。</li></ol><p>代码看起来会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">day, month, year = map(int, string_date.split(<span class="string">'-'</span>))</span><br><span class="line">date1 = Date(day, month, year)</span><br></pre></td></tr></table></figure><p>如果使用<code>@classmethod</code>修饰符写在类中，将会是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'27-10-2018'</span>)</span><br></pre></td></tr></table></figure><p>让我们更仔细地看看上面的代码实现，并回想一下我们做了什么？</p><ul><li><p>我们在一个地方实现了日期字符串解析函数，现在它可以重用。</p></li><li><p>将日期字符串解析函数封装在类中并且工作正常(当然你可以在其他地方实现日期字符串解析作为单个函数，但这个解决方案更适合OOP范例)。</p></li><li><code>cls</code>是一个保存<strong>类本身</strong>的对象，而不是类的实例。这很酷😎，因为如果我们继承Date类，所有子类也会定义<code>from_string()</code>。</li></ul><h3 id="Static-Method"><a href="#Static-Method" class="headerlink" title="Static Method"></a>Static Method</h3><p><code>@staticmethod</code>确实与<code>@classmethod</code>很相似，但<code>@staticmethod</code>不需要任何强制性参数(如类方法或实例方法)。</p><p>让我们看看下一个任务(下一个用例):</p><p><em>假设我们有一个日期字符串，我们想要以某种方式进行验证它是否符合要求的格式。此任务也需要封装在Date类中，但不需要实例化它。</em></p><p>这里使用<code>@staticmethod</code>就会很有效。让我们看一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">    day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">    <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usage:</span></span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'27-10-2018'</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到<code>is_date</code>是个boolen型变量，而非<code>is_date_valid</code>函数返回的day，month，year三个整型数据。</p><p>因此，我们可以从<code>@staticmethod</code>的使用中看到，我们无法访问类的内容——它基本上只是一个函数，在语法上称为方法，无法访问对象及其内部(字段和其他类方法)。而使用<code>@classmethod</code>却可以做到。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上面的文章已经很全面地总结了<code>@classmethod</code>和<code>@staticmethod</code>的区别。在这里我想强调当你<strong>创建构造函数</strong>时，你应该选择<code>@classmethod</code>而不是<code>@staticmethod</code>的另一个原因。在上面的例子中，使用<code>@classmethod</code> <code>from_string()</code>作为Factory，接收不符合<code>__init__</code>要求的参数创建Date类实例。使用<code>@staticmethod</code>可以完成同样的操作，如下面代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, month, day, year)</span>:</span></span><br><span class="line">    self.month = month</span><br><span class="line">    self.day   = day</span><br><span class="line">    self.year  = year</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125;"</span>.format(self.month, self.day, self.year)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">millenium</span><span class="params">(month, day)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Date(month, day, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">new_year = Date(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2013</span>)               <span class="comment"># Creates a new Date object</span></span><br><span class="line">millenium_new_year = Date.millenium(<span class="number">1</span>, <span class="number">1</span>) <span class="comment"># also creates a Date object. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Proof:</span></span><br><span class="line">new_year.display()           <span class="comment"># "1-1-2013"</span></span><br><span class="line">millenium_new_year.display() <span class="comment"># "1-1-2000"</span></span><br><span class="line"></span><br><span class="line">isinstance(new_year, Date) <span class="comment"># True</span></span><br><span class="line">isinstance(millenium_new_year, Date) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>运行结果显示<code>new_year</code>和<code>millenium_new_year</code>都是Date类实例。</p><p>但是，如果仔细观察就会发现，<code>millenium_new_year</code>是以<strong>硬编码</strong>的方式创建的Date类实例。这意味着即使一个类继承Date类，该子类仍将创建普通的Date对象即父类对象，而不具有该子类本身的任何属性。请参阅以下示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTime</span><span class="params">(Date)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125; - 00:00:00PM"</span>.format(self.month, self.day, self.year)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datetime1 = DateTime(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1990</span>)</span><br><span class="line">datetime2 = DateTime.millenium(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">isinstance(datetime1, DateTime) <span class="comment"># True</span></span><br><span class="line">isinstance(datetime2, DateTime) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">datetime1.display() <span class="comment"># returns "10-10-1990 - 00:00:00PM"</span></span><br><span class="line">datetime2.display() <span class="comment"># returns "10-10-2000" because it's not a DateTime object but a Date object. Check the implementation of the millenium method on the Date class</span></span><br></pre></td></tr></table></figure><p>DateTime类继承Date类，因此具有Date类的<code>millenium()</code>方法。<code>datetime2</code>通过调用DateTime继承来的<code>millenium()</code>方法来创建DateTime类实例。然而代码却显示<code>datetime2</code>并不是DateTime类实例(<code>isinstance(datetime2, DateTime) # False</code>)。怎么回事？<strong>这是因为使用了<code>@staticmethod</code>修饰符</strong>。</p><p>在大多数情况下，这是你不希望出现的。如果你想要的是一个”完整“的类实例，并且是通过调用它的父类方法所创建的话，那么<code>@classmethod</code>就是你所需要的。</p><p>将<code>Date.millenium()</code>重写为(这是上述代码中唯一改变的部分)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">millenium</span><span class="params">(cls, month, day)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cls(month, day, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>确保该类的创建不是通过硬编码。<code>cls</code>可以是任何子类，生成的对象将正确地成为cls的实例。我们来试试吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">datetime1 = DateTime(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1990</span>)</span><br><span class="line">datetime2 = DateTime.millenium(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">isinstance(datetime1, DateTime) <span class="comment"># True</span></span><br><span class="line">isinstance(datetime2, DateTime) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datetime1.display() <span class="comment"># "10-10-1990 - 00:00:00PM"</span></span><br><span class="line">datetime2.display() <span class="comment"># "10-10-2000 - 00:00:00PM"</span></span><br></pre></td></tr></table></figure><p>看吧，用<code>@classmethod</code>替代<code>@staticmethod</code>你不希望出现的情况就会消失。<strong>使用了<code>@staticmethod</code>修饰符定义构造函数就是问题出现的关键。</strong></p><p>文章的内容有点多，可能需要花一些时间进行理解，最后提供一个小示例帮助大家加深记忆一下<code>@classmethod</code>和<code>@staticmethod</code>的<strong>主要不同</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'foo'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'static_foo'</span></span><br><span class="line">        <span class="keyword">print</span> A.bar</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'class_foo'</span></span><br><span class="line">        <span class="keyword">print</span> cls.bar</span><br><span class="line">        cls().foo()</span><br><span class="line"> </span><br><span class="line">A.static_foo()</span><br><span class="line">A.class_foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">static_foo</span><br><span class="line"><span class="number">1</span></span><br><span class="line">class_foo</span><br><span class="line"><span class="number">1</span></span><br><span class="line">foo</span><br></pre></td></tr></table></figure><blockquote><p>引用文章：</p><ol><li><a href="https://blog.csdn.net/handsomekang/article/details/9615239" target="_blank" rel="noopener">飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客</a></li><li><a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">python - Meaning of @classmethod and @staticmethod for beginner? - Stack Overflow</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中-classmethod和-staticmethod的区别&quot;&gt;&lt;a href=&quot;#Python中-classmethod和-staticmethod的区别&quot; class=&quot;headerlink&quot; title=&quot;Python中@classmethod和@staticmethod的区别&quot;&gt;&lt;/a&gt;Python中@classmethod和@staticmethod的区别&lt;/h1&gt;&lt;p&gt;接上一篇介绍&lt;a href=&quot;https://rilzob.github.io/2018/10/27/Python%E4%B8%AD@staticmethod%E5%92%8C@classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python中@staticmethod和@classmethod的用法&lt;/a&gt;的文章。虽然&lt;code&gt;@classmethod&lt;/code&gt;和&lt;code&gt;@staticmethod&lt;/code&gt;非常相似，但两个修饰符的使用情况仍&lt;strong&gt;略有不同&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中@staticmethod和@classmethod的用法</title>
    <link href="https://rilzob.com/2018/10/27/Python%E4%B8%AD@staticmethod%E5%92%8C@classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/27/Python中@staticmethod和@classmethod的用法的副本/</id>
    <published>2018-10-27T01:50:32.730Z</published>
    <updated>2018-10-27T02:01:47.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中-staticmethod和-classmethod的用法"><a href="#Python中-staticmethod和-classmethod的用法" class="headerlink" title="Python中@staticmethod和@classmethod的用法"></a>Python中@staticmethod和@classmethod的用法</h1><p>一般来说，调用某个类的方法，需要预先生成一个实例，再通过实例调用方法。Java中有静态方法，可以使用类直接进行调用。Python中提供了两个修饰符<code>@staticmethod</code>和<code>@classmethod</code>以达到类似效果，使用它们就可以不需要实例化，直接<strong>类名.方法名()</strong>来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类中，同时有利于命名空间的整洁。<a id="more"></a></p><h2 id="staticmethod"><a href="#staticmethod" class="headerlink" title="@staticmethod"></a>@staticmethod</h2><p><code>@staticmethod</code>声明方法为静态方法，直接通过<strong>类名.方法名()</strong>调用。经过<code>@staticmethod</code>修饰的方法，<strong>不需要self参数</strong>，其使用方法和直接调用函数一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接定义一个test()函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"i am a normal method!"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#定义一个类，其中包括一个类方法，采用@staticmethod修饰    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_test</span><span class="params">()</span>:</span> <span class="comment"># 没有self参数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"i am a static method!"</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test()</span><br><span class="line">    T.static_test()</span><br><span class="line">    T().static_test()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">i am a normal method!</span><br><span class="line">i am a static method!</span><br><span class="line">i am a static method!</span><br></pre></td></tr></table></figure><h2 id="classmethod"><a href="#classmethod" class="headerlink" title="@classmethod"></a>@classmethod</h2><p><code>@classmethod</code>声明方法为类方法，直接通过<strong>类名.方法名()</strong>调用。经过<code>@classmethod</code>修饰的方法，<strong>不需要self参数</strong>，但是<strong>需要一个标识类本身的cls参数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_test</span><span class="params">(cls)</span>:</span> <span class="comment"># 必须有cls参数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"i am a class method"</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    T.class_test()</span><br><span class="line">    T().class_test()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">i am a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">i</span> <span class="title">am</span> <span class="title">a</span> <span class="title">class</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure><p><em><code>@classmethod</code>另一个实用的用法：在不改变已经写好的类里面的方法的情况下，对输入的数据进行处理。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出年月日，正常的情况下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year=<span class="number">0</span>, month=<span class="number">0</span>, day=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_date</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"year: %d, month: %d, day: %d"</span> % (self.year, self.month, self.day)</span><br><span class="line">    </span><br><span class="line">year = <span class="number">2018</span></span><br><span class="line">month = <span class="number">10</span></span><br><span class="line">day = <span class="number">27</span></span><br><span class="line"></span><br><span class="line">demo1 = demo1(year, month, day)</span><br><span class="line">print(demo1.out_date())  <span class="comment"># year: 2018, month: 10, day: 27</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户输入的是2018-10-27格式，需要在输出前处理一下，就可以使用classmethod达到想要的效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year=<span class="number">0</span>, month=<span class="number">0</span>, day=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_date</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"year: %d, month: %d, day: %d"</span> % (self.year, self.month, self.day)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_out</span><span class="params">(cls, date_string)</span>:</span></span><br><span class="line">        year, month, day = map(int, date_string.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">return</span> cls(year, month, day)</span><br><span class="line">    </span><br><span class="line">date = <span class="string">"2018-10-27"</span></span><br><span class="line">year = <span class="number">2017</span></span><br><span class="line">month = <span class="number">7</span></span><br><span class="line">day = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    demo2 = demo2.pre_out(date)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    demo2 = demo2(year, month, day)</span><br><span class="line">    </span><br><span class="line">print(demo2.out_date())  <span class="comment"># year: 2018, month: 10, day: 6</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>@staticmethod</code>不需要表示自身对象的self参数和自身类的cls参数，就跟使用函数一样。</li><li><code>@classmethod</code>也不需要self参数，但第一个参数需要是表示自身类的cls参数。</li><li>在Python中类和实例都是对象，都占用了内存空间，合理使用<code>@staticmethod</code>和<code>@classmethod</code>修饰符，就可以不经过实例化直接使用类的方法了。</li></ul><blockquote><p>引用文章：</p><ol><li><a href="https://blog.csdn.net/sinat_34079973/article/details/53502348" target="_blank" rel="noopener">Python @staticmethod@classmethod用法 - sinat_34079973的博客 - CSDN博客</a></li><li><a href="https://blog.csdn.net/handsomekang/article/details/9615239" target="_blank" rel="noopener">飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客</a></li><li><a href="https://www.jianshu.com/p/eea864224e2d" target="_blank" rel="noopener">classmethod的两个实用用法 - 简书</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中-staticmethod和-classmethod的用法&quot;&gt;&lt;a href=&quot;#Python中-staticmethod和-classmethod的用法&quot; class=&quot;headerlink&quot; title=&quot;Python中@staticmethod和@classmethod的用法&quot;&gt;&lt;/a&gt;Python中@staticmethod和@classmethod的用法&lt;/h1&gt;&lt;p&gt;一般来说，调用某个类的方法，需要预先生成一个实例，再通过实例调用方法。Java中有静态方法，可以使用类直接进行调用。Python中提供了两个修饰符&lt;code&gt;@staticmethod&lt;/code&gt;和&lt;code&gt;@classmethod&lt;/code&gt;以达到类似效果，使用它们就可以不需要实例化，直接&lt;strong&gt;类名.方法名()&lt;/strong&gt;来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类中，同时有利于命名空间的整洁。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中super()函数的用法及其说明</title>
    <link href="https://rilzob.com/2018/10/26/Python%E4%B8%ADsuper()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/26/Python中super()函数的用法的副本/</id>
    <published>2018-10-26T14:33:09.515Z</published>
    <updated>2018-11-07T06:54:42.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中super-函数的用法及其说明"><a href="#Python中super-函数的用法及其说明" class="headerlink" title="Python中super()函数的用法及其说明"></a>Python中super()函数的用法及其说明</h1><p>为了调用父类(超类)的一个方法，可以使用<code>super()</code>函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.spam'</span>)</span><br><span class="line">        super().spam()  <span class="comment"># Call parent spam()</span></span><br></pre></td></tr></table></figure><p><strong><code>super()</code>函数的一个常见用法是在<code>__init__()</code>中确保父类被正确的初始化</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.y = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>说明<code>__init__()</code>函数：定义类的时候，若是添加<code>__init__()</code>函数，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初始化。</em></p><p><strong><code>super()</code>的另外一个常见用法出现在覆盖Python特殊方法的代码中</strong>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self._obj = obj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delegate attribute lookup to internal obj</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._obj, name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delegate attribute assignment</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__setattr__(name, value) <span class="comment"># Call original __setattr__</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            setattr(self._obj, name, value)</span><br></pre></td></tr></table></figure><p>实际上，大家对于在Python中如何正确使用<code>super()</code>函数普遍知之甚少。你有时候会看到像下面这样直接调用父类的一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br></pre></td></tr></table></figure><p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。比如，考虑下面的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br></pre></td></tr></table></figure><p>运行这段代码后就会发现<code>Base.__init__</code>被调用两次，如图所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">A.__init__</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">C.__init__</span><br></pre></td></tr></table></figure><p>可能两次调用<code>Base.__init__()</code>没什么坏处，但有时候却不是。另一方面，假设在代码中换成使用<code>super()</code>，结果就很完美了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()  <span class="comment"># Only one call to super() here</span></span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br></pre></td></tr></table></figure><p>运行这个新版本后，你会发现<code>Base.__init__()</code>方法只会被调用一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">A.__init__</span><br><span class="line">C.__init__</span><br></pre></td></tr></table></figure><p>所以说，<code>super()</code>是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序(MRO)、重复调用(钻石继承)等种种问题。</p><p><em>说明：MRO就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表，下面会有更详尽的介绍。</em></p><p>为了弄清它的原理，我们需要花点时间解释下Python是如何实现继承的。对于你定义的每一个类，Python会计算出一个所谓的<strong>方法解析顺序(MRO)列表</strong>。这个MRO列表就是一个简单的所有基类的线性顺序表。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.__mro__</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,</span><br><span class="line">&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p>为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p><p>而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：</p><ul><li>子类会先于父类被检查</li><li>多个父类会根据它们在列表中的顺序被检查</li><li>如果对下一个类存在两个合法的选择，选择第一个父类</li></ul><p>老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。</p><p>当你使用<code>super()</code>函数时，Python会在MRO列表上继续搜索下一个类。只要每个重定义的方法统一使用<code>super()</code>并只调用它一次，那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。这也是为什么在第二个例子中你不会调用两次<code>Base.__init__()</code>的原因。</p><p><code>super()</code>有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line">        super().spam()</span><br></pre></td></tr></table></figure><p>如果你试着直接使用这个类就会出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.spam()</span><br><span class="line">A.spam</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> spam</span><br><span class="line">AttributeError: <span class="string">'super'</span> object has no attribute <span class="string">'spam'</span></span><br></pre></td></tr></table></figure><p>但是，如果你使用多继承的话看看会发生什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'B.spam'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.spam()</span><br><span class="line">A.spam</span><br><span class="line">B.spam</span><br></pre></td></tr></table></figure><p>你可以看到在类A中使用<code>super().spam()</code>实际上调用的是与类A毫无关系的类B中的<code>spam()</code>方法。这个用类C的MRO列表就可以完全解释清楚：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.__mro__</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">object</span>'&gt;)</span></span><br></pre></td></tr></table></figure><p>在定义混入类的时候这样使用<code>super()</code>是很普遍的。</p><p>然而，由于<code>super()</code>可能会调用不是你想要的方法，你应该遵循一些通用原则。首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。这样可以确保<code>super()</code>调用一个非直接父类方法时不会出错。其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。</p><p>在Python社区内对于<code>super()</code>的使用有时候会引来一些争议。尽管如此，如果一切顺利的话，你应该在你最新的代码中使用它。Raymond Hettinger为此写了一篇非常好的文章，有兴趣的话可以去查查看，文章通过大量的例子向我们解释了为什么<code>super()</code>是极好的。</p><p>最后通过一个很好的实例帮助大家加深一下记忆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooParent</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.parent = <span class="string">'I\'m the parent.'</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Parent'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self,message)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"%s from Parent"</span> % message)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(FooParent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类B的对象 FooChild 转换为类 FooParent 的对象</span></span><br><span class="line">        super(FooChild,self).__init__()    </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Child'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self,message)</span>:</span></span><br><span class="line">        super(FooChild, self).bar(message)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Child bar fuction'</span>)</span><br><span class="line">        <span class="keyword">print</span> (self.parent)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fooChild = FooChild()</span><br><span class="line">    fooChild.bar(<span class="string">'HelloWorld'</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">HelloWorld from Parent</span><br><span class="line">Child bar fuction</span><br><span class="line">I&apos;m the parent.</span><br></pre></td></tr></table></figure><blockquote><p>引用文章：</p><ol><li><a href="http://www.runoob.com/python/python-func-super.html" target="_blank" rel="noopener">Python super() 函数 | 菜鸟教程</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html" target="_blank" rel="noopener">8.7 调用父类方法 — python3-cookbook 3.0.0 文档</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中super-函数的用法及其说明&quot;&gt;&lt;a href=&quot;#Python中super-函数的用法及其说明&quot; class=&quot;headerlink&quot; title=&quot;Python中super()函数的用法及其说明&quot;&gt;&lt;/a&gt;Python中super()函数的用法
      
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo使用攻略：添加搜索功能</title>
    <link href="https://rilzob.com/2018/10/26/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/26/Hexo使用攻略：添加搜索功能的副本/</id>
    <published>2018-10-26T02:04:21.695Z</published>
    <updated>2018-10-26T02:07:15.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用攻略：添加搜索功能"><a href="#Hexo使用攻略：添加搜索功能" class="headerlink" title="Hexo使用攻略：添加搜索功能"></a>Hexo使用攻略：添加搜索功能</h1><p>本教程针对的是Mac环境</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当博文越来越多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博文上去了，所以添加一个站内搜索功能是很有必要的。</p><p>Hexo适配多款搜索插件，个人感觉”Local Search”已满足日常需要，所以下面介绍为Hexo添加”Local Search”搜索插件的过程。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在命令行中<code>cd</code>到自己的hexo文件夹下(例：<code>/Users/rilzob/hexo</code>)，执行<code>npm install hexo-generator-searchdb --save</code>命令进行安装，等待安装完成。</p><h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>修改当前目录下的<strong>_config.yml</strong>文件(例：<code>/Users/rilzob/hexo/_config.yml</code>)，新增以下内容到该文件内的任意位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Search</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p><em>注意：每个冒号后面都有空格</em></p><h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>修改主题目录下的<strong>_config.yml</strong>文件(例：<code>/Users/rilzob/hexo/themes/xxx/_config.yml</code>)，找到该文件内的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure><p>代码段，将其修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>即将enable: false修改为enable: true。</p><h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>依旧在命令行中进行操作，在hexo文件夹下依次执行<code>hexo g</code>,<code>hexo server</code>和<code>hexo deploy</code>指令即可。这样搜索功能就添加成功了。</p><blockquote><p>引用文章:</p><p>1.<a href="https://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/" target="_blank" rel="noopener">Hexo博客添加搜索功能 | IT范儿</a></p><p>2.<a href="https://blog.csdn.net/qq_40265501/article/details/80030627" target="_blank" rel="noopener">hexo博客添加搜索功能 - qq_40265501的博客 - CSDN博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo使用攻略：添加搜索功能&quot;&gt;&lt;a href=&quot;#Hexo使用攻略：添加搜索功能&quot; class=&quot;headerlink&quot; title=&quot;Hexo使用攻略：添加搜索功能&quot;&gt;&lt;/a&gt;Hexo使用攻略：添加搜索功能&lt;/h1&gt;&lt;p&gt;本教程针对的是Mac环境&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Hexo" scheme="https://rilzob.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo使用攻略：添加分类及标签</title>
    <link href="https://rilzob.com/2018/10/25/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/25/Hexo使用攻略：添加分类及标签的副本/</id>
    <published>2018-10-25T13:28:41.587Z</published>
    <updated>2018-10-26T01:16:40.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用攻略：添加分类及标签"><a href="#Hexo使用攻略：添加分类及标签" class="headerlink" title="Hexo使用攻略：添加分类及标签"></a>Hexo使用攻略：添加分类及标签</h1><p>本教程针对的是Mac环境</p><h2 id="Hexo创建”分类”选项"><a href="#Hexo创建”分类”选项" class="headerlink" title="Hexo创建”分类”选项"></a>Hexo创建”分类”选项</h2><h3 id="生成”分类”页并添加type属性"><a href="#生成”分类”页并添加type属性" class="headerlink" title="生成”分类”页并添加type属性"></a>生成”分类”页并添加type属性</h3><ol><li><p>打开命令行，<code>cd</code>进入博客所在文件夹。执行命令<code>hexo new page categories</code>，来新建一个页面，并命名为categories。成功后会提示：<code>INFO  Created: ~/hexo/source/categories/index.md</code></p></li><li><p>根据上面的路径找到<strong>index.md</strong>这个文件，打开后默认内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-10-25 20:11:37</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>编辑新创建的页面，添加<code>type: &quot;categories&quot;</code>到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-10-25 20:11:37</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p></li></ol><h3 id="给文章添加”categories”属性"><a href="#给文章添加”categories”属性" class="headerlink" title="给文章添加”categories”属性"></a>给文章添加”categories”属性</h3><ol><li><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: Python</code>表示添加这篇文章到“Python”这个分类中。</p><p>注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Python中*args和**kwargs的用法总结</span><br><span class="line">categories: Python</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>回到hexo文件夹下，依次执行<code>hexo g</code>，<code>hexo server</code>和<code>hexo deploy</code>命令(重新部署)。</p></li></ol><h3 id="在Hexo菜单上添加分类选项"><a href="#在Hexo菜单上添加分类选项" class="headerlink" title="在Hexo菜单上添加分类选项"></a>在Hexo菜单上添加分类选项</h3><ol><li><p><code>cd</code>进<code>/hexo/themes/hexo-theme-next-5.1.4</code>文件夹内，编辑该目录下的<strong>_config.yml</strong>文件(把链接加上)，将源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>即将menu中的<code>categories:/categories || th</code>的注释去掉，然后保存并退出。</p></li><li><p>回到<code>hexo</code>文件夹下，依次执行<code>hexo g</code>，<code>hexo server</code>和<code>hexo deploy</code>命令，即可看到菜单栏中新增了一个Categories选项。</p></li></ol><p>   至此，成功给文章添加分类，点击Index上的Categories可以看到所有的分类情况，再点击该分类就可以看到该分类下的所有文章。当然，前提是添加了categories: xxx字段。</p><h2 id="Hexo创建”标签”选项"><a href="#Hexo创建”标签”选项" class="headerlink" title="Hexo创建”标签”选项"></a>Hexo创建”标签”选项</h2><h3 id="生成”标签”页并添加type属性"><a href="#生成”标签”页并添加type属性" class="headerlink" title="生成”标签”页并添加type属性"></a>生成”标签”页并添加type属性</h3><ol><li><p>打开命令行，<code>cd</code>进入博客所在文件夹。执行命令<code>hexo new page tags</code>，来新建一个页面，并命名为tags。成功后会提示：<code>INFO  Created: ~/hexo/source/tags/index.md</code></p></li><li><p>根据上面的路径找到<strong>index.md</strong>这个文件，打开后默认内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-25 21:11:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>编辑新创建的页面，添加<code>type: &quot;tags&quot;</code>到内容中，主题将自动为这个页面显示所有分类，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-25 21:11:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p></li></ol><h3 id="给文章添加”tags”属性"><a href="#给文章添加”tags”属性" class="headerlink" title="给文章添加”tags”属性"></a>给文章添加”tags”属性</h3><ol><li><p>打开需要添加标签的文章，为其添加tags属性。下方的<code>tags: Django</code>表示添加这篇文章到“Django”这个标签中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Python中*args和**kwargs的用法总结</span><br><span class="line">tags: Django</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>回到hexo文件夹下，依次执行<code>hexo g</code>， <code>hexo server</code>和<code>hexo deploy</code>命令(重新部署)。</p></li></ol><h3 id="在Hexo菜单上添加标签选项"><a href="#在Hexo菜单上添加标签选项" class="headerlink" title="在Hexo菜单上添加标签选项"></a>在Hexo菜单上添加标签选项</h3><ol><li><p><code>cd</code>进<code>/hexo/themes/hexo-theme-next-5.1.4</code>文件夹内，编辑该目录下的<strong>_config.yml</strong>文件(把链接加上)，将源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>即将menu中的<code>tags: /tags/ || tags</code>的注释去掉，然后保存并退出。</p></li><li><p>回到<code>hexo</code>文件夹下，依次执行<code>hexo g</code>，<code>hexo server</code>和<code>hexo deploy</code>命令，即可看到菜单栏中新增了一个tags选项。</p></li></ol><blockquote><p>引用文章：</p><p>1.<a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">Hexo使用攻略-添加分类及标签 | linlif-blog</a></p><p>2.<a href="https://segmentfault.com/q/1010000000618915" target="_blank" rel="noopener">hexo怎么在菜单上添加页面和分类呢？ - SegmentFault 思否</a></p><p>3.<a href="https://whx4j8.github.io/2016/03/16/hexo-next-%E6%B7%BB%E5%8A%A0%E4%B8%BA%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">hexo next 为文章添加分类 | 学而后知不足</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo使用攻略：添加分类及标签&quot;&gt;&lt;a href=&quot;#Hexo使用攻略：添加分类及标签&quot; class=&quot;headerlink&quot; title=&quot;Hexo使用攻略：添加分类及标签&quot;&gt;&lt;/a&gt;Hexo使用攻略：添加分类及标签&lt;/h1&gt;&lt;p&gt;本教程针对的是Mac环境&lt;/
      
    
    </summary>
    
      <category term="Hexo" scheme="https://rilzob.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中*args和**kwargs的用法总结</title>
    <link href="https://rilzob.com/2018/10/25/Python%E4%B8%AD*args%E5%92%8C**kwargs%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/25/Python中*args和**kwargs的用法总结的副本/</id>
    <published>2018-10-25T11:29:45.812Z</published>
    <updated>2018-10-25T12:24:56.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中-args和-kwargs的用法总结"><a href="#Python中-args和-kwargs的用法总结" class="headerlink" title="Python中*args和**kwargs的用法总结"></a>Python中*args和**kwargs的用法总结</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>Python支持可变参数，最简单的方法莫过于使用默认参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_defargs</span><span class="params">(one, two=<span class="number">2</span>)</span>:</span> <span class="comment"># 参数one没有默认值，two的默认值为2</span></span><br><span class="line">    print(<span class="string">'Required argument:'</span>, one)</span><br><span class="line">    print(<span class="string">'Optional argument:'</span>, two)</span><br><span class="line">    </span><br><span class="line">test_defargs(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Required argument: 1</span></span><br><span class="line"><span class="string">Optional argument: 2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">test_defargs(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Required argument: 1</span></span><br><span class="line"><span class="string">Optional argument: 3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>另一种达到可变参数(Variable Argument)的方法：</p><p>使用<code>*args</code>和<code>**kwargs</code>语法。</p><p><code>*args</code>是可变的<strong>位置参数(postional arguments)</strong>列表；</p><p><code>**kwargs</code>是可变的<strong>关键词参数(keyword arguments)</strong>列表；</p><p>并且<u>规定位置参数必须位于关键词参数之前，即<code>*args</code>必须位于<code>**kwargs</code>之前</u>。</p><h2 id="二、位置参数"><a href="#二、位置参数" class="headerlink" title="二、位置参数"></a>二、位置参数</h2><p>以下是用位置参数正确调用函数的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">(name, sex)</span>:</span></span><br><span class="line">sex_dict = &#123;<span class="number">1</span>: <span class="string">'先生'</span>, <span class="number">2</span>: <span class="string">'女士'</span>&#125;</span><br><span class="line">    print(<span class="string">'Hello %s %s, welcome to Python World!'</span> % (name, sex_dict.get(sex, <span class="string">'先生'</span>))) <span class="comment"># if no such a key, print '先生'</span></span><br><span class="line">    </span><br><span class="line">print_hello(<span class="string">'Chen'</span>, <span class="number">2</span>) <span class="comment"># 位置参数要求先后顺序，对应name和sex</span></span><br><span class="line">print_hello(<span class="string">'Chen'</span>, <span class="number">3</span>) <span class="comment"># 两个参数的顺序必须一一对应，且少一个参数都不可以</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Hello Chen 女士, welcome to Python World!</span></span><br><span class="line"><span class="string">Hello Chen 先生, welcome to Python World!</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="三、关键字参数"><a href="#三、关键字参数" class="headerlink" title="三、关键字参数"></a>三、关键字参数</h2><p>用于函数调用，通过“键-值”形式加以指定。</p><p>使用关键字参数可以让函数更加清晰，容易使用，同时也清除了参数的顺序需求。</p><p>以下是用关键字参数正确调用函数的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print_hello(<span class="string">'Chen'</span>, sex=<span class="number">1</span>) <span class="comment"># 有位置参数时，位置参数必须在关键字参数的前面</span></span><br><span class="line"><span class="comment"># print_hello(1, name='Chen') # Python 3.x中这种写法是错误的</span></span><br><span class="line">print_hello(name=<span class="string">'Chen'</span>, sex=<span class="number">1</span>) <span class="comment"># 关键字参数之间不存在先后顺序的,等价于print_hello(sex=1, name='Chen')</span></span><br></pre></td></tr></table></figure><p>以下是错误的调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print_hello(name='Chen', 1) # 有位置参数时，位置参数必须在关键字参数前面</span></span><br><span class="line"><span class="comment"># print_hello(sex=1, 'Chen')</span></span><br></pre></td></tr></table></figure><h2 id="四、可变参数"><a href="#四、可变参数" class="headerlink" title="四、可变参数"></a>四、可变参数</h2><p>顾名思义，可变参数就是传入的参数个数是可变的，可以是任意个。<code>*args</code>和<code>**kwargs</code>两者都是Python中的可变参数。</p><h4 id="1-可变位置参数-args"><a href="#1-可变位置参数-args" class="headerlink" title="1.可变位置参数*args"></a>1.可变位置参数<code>*args</code></h4><p>Python中规定参数前带<code>*</code>的，称为<strong>可变位置参数</strong>，只是我们通常称这个可变位置参数为<code>*args</code>而已，叫其他的也是一样的。</p><p>以数学题为例，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。</p><p>要定义这个函数，必须确定输入的参数。由于参数个数不确定，我们可以首先想到把a，b，c……作为一个list或者tuple传进来，这样函数就可以定义为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure><p>所以，为了方便起见我们把函数的参数改为可变位置函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span> # 可变位置参数</span></span><br><span class="line">sum = 0</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>定义可变位置参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;calc(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;calc()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果已经有一个list或tuple，要调用一个可变位置参数怎么办？可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>这种做法当然是可行的，问题是太繁琐了，所以Python允许在list或tuple前面加一个<code>*</code>，把list或tuple的元素变成可变位置参数传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>总而言之，<code>*args</code>用来表示函数接收可变长度的非关键字参数列表作为函数的输入。我们可以通过以下这个例子进一步理解<code>*args</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args</span><span class="params">(normal_arg, *args)</span>:</span></span><br><span class="line">print(<span class="string">'first normal arg:'</span> + normal_arg)</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(<span class="string">'another arg through *args:'</span> + arg)</span><br><span class="line">    </span><br><span class="line">test_args(<span class="string">"normal"</span>, <span class="string">"python"</span>, <span class="string">"java"</span>, <span class="string">"C#"</span>)</span><br></pre></td></tr></table></figure><p>上面代码的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first normal arg: normal</span><br><span class="line">another arg through *args : python</span><br><span class="line">another arg through *args : java</span><br><span class="line">another arg through *args :C#</span><br></pre></td></tr></table></figure><h4 id="2-可变关键字参数-kwargs"><a href="#2-可变关键字参数-kwargs" class="headerlink" title="2.可变关键字参数**kwargs"></a>2.可变关键字参数<code>**kwargs</code></h4><p>同理，Python中规定参数前带<code><strong> </strong></code>的，称为可变关键字参数<strong>，通常用<code></code></strong>kwargs表示。</p><p><code>**kwargs</code>表示函数接收可变长度的关键字参数字典作为函数的输入。当我们需要函数接收带关键字的参数作为输入的时候，应当使用<code>**kwargs</code>。我们可以通过以下的例子进一步理解<code>**kwargs</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_kwargs</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.iteritems():</span><br><span class="line">            print(<span class="string">"&#123;&#125; = &#123;&#125;"</span>.format(key,value))</span><br><span class="line">        <span class="comment"># Or you can visit kwargs like a dict() object</span></span><br><span class="line">        <span class="comment"># for key in kwargs:</span></span><br><span class="line">        <span class="comment">#    print("&#123;&#125; = &#123;&#125;".format(key, kwargs[key]))</span></span><br><span class="line">        </span><br><span class="line">test_kwargs(name=<span class="string">"python"</span>, value=<span class="string">"5"</span>)</span><br></pre></td></tr></table></figure><p>以上代码的执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = python</span><br><span class="line">value = 5</span><br></pre></td></tr></table></figure><p>以上例子只是<code>*args</code>和<code>**kwargs</code>基本使用的例子。下面再给出一个用<code>*args</code>和<code>**kwargs</code>来定义能够接受列表输入和字典输入的函数的例子。</p><h4 id="3-使用-args和-kwargs来调用函数"><a href="#3-使用-args和-kwargs来调用函数" class="headerlink" title="3.使用*args和**kwargs来调用函数"></a>3.使用<code>*args</code>和<code>**kwargs</code>来调用函数</h4><p>比如我们有如下接受普通输入参数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_func</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">"arg1: "</span> + arg1)</span><br><span class="line">    print(<span class="string">"arg2: "</span> + arg2)</span><br><span class="line">    print(<span class="string">"arg3: "</span> + arg3)</span><br><span class="line"></span><br><span class="line">normal_func(<span class="string">"python"</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>使用<code>*args</code>和<code>**kwargs</code>来调用这个函数的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用*args</span></span><br><span class="line">args_list = (<span class="string">"python"</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">normal_func(*args_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用**kwargs</span></span><br><span class="line">kwargs_dict = &#123;<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg1"</span>: <span class="string">"python"</span>, <span class="string">"arg2"</span>: <span class="number">1</span>&#125;</span><br><span class="line">normal_func(**kwargs_dict)</span><br></pre></td></tr></table></figure><p>以上三段代码的输出均为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arg1: python</span><br><span class="line">arg2: 1</span><br><span class="line">arg3: 3</span><br></pre></td></tr></table></figure><blockquote><p>引用文章：</p><p>1.<a href="https://www.jianshu.com/p/61507f60fa29" target="_blank" rel="noopener">Python中的 *args 和 **kwargs - 简书</a></p><p>2.<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="noopener">函数的参数 - 廖雪峰的官方网站</a></p><p>3.<a href="https://www.jianshu.com/p/be92113116c8" target="_blank" rel="noopener">python参数传递的*args和**kwargs - 简书</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中-args和-kwargs的用法总结&quot;&gt;&lt;a href=&quot;#Python中-args和-kwargs的用法总结&quot; class=&quot;headerlink&quot; title=&quot;Python中*args和**kwargs的用法总结&quot;&gt;&lt;/a&gt;Python中*ar
      
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>通过Hexo将文章上传到git.io的方法</title>
    <link href="https://rilzob.com/2018/10/21/%E9%80%9A%E8%BF%87Hexo%E5%B0%86%E6%96%87%E7%AB%A0%E4%B8%8A%E4%BC%A0%E5%88%B0git.io%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://rilzob.com/2018/10/21/通过Hexo将文章上传到git.io的方法/</id>
    <published>2018-10-21T01:59:43.963Z</published>
    <updated>2018-10-25T12:29:05.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过Hexo将文章上传到git-io的方法"><a href="#通过Hexo将文章上传到git-io的方法" class="headerlink" title="通过Hexo将文章上传到git.io的方法"></a>通过Hexo将文章上传到git.io的方法</h1><ol><li><p>编辑文章，生成markdown文件，并将文章放到<code>/hexo/source/_posts</code>目录下，一个md文件对应一篇博客文章。</p></li><li><p>修改文章头部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: #博客标题</span><br><span class="line">date: #博客发布时间</span><br><span class="line">tags: #博客分类标签</span><br><span class="line">categories: #博客目录</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在命令行中cd到_posts目录下并执行<code>hexo generate</code>命令(生成静态页面)。</p></li><li><p>再执行<code>hexo server</code>命令(本地上传文章)，上传后可以到<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 预览博客效果。</p></li><li><p>最后执行<code>hexo deploy</code>命令，上传文章到github.io上就完成了。</p></li></ol><p>其他Hexo命令：</p><ul><li>hexo clean（清空资源文件，可选操作）</li><li>hexo g （重新生成资源文件）</li></ul><blockquote><p>引用文章:  </p><p>1.<a href="https://blog.csdn.net/u010504064/article/details/78460652" target="_blank" rel="noopener">Hexo 发布文章到git.io步骤 - 程序男的专栏 - CSDN博客</a></p><p>2.<a href="https://blog.csdn.net/wl67920126/article/details/80718362" target="_blank" rel="noopener">hexo发布文章到个人博客上 - wl67920126的博客 - CSDN博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过Hexo将文章上传到git-io的方法&quot;&gt;&lt;a href=&quot;#通过Hexo将文章上传到git-io的方法&quot; class=&quot;headerlink&quot; title=&quot;通过Hexo将文章上传到git.io的方法&quot;&gt;&lt;/a&gt;通过Hexo将文章上传到git.io的方法&lt;/
      
    
    </summary>
    
      <category term="Hexo" scheme="https://rilzob.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Django中path和url的区别</title>
    <link href="https://rilzob.com/2018/10/21/Django%E4%B8%ADpath%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://rilzob.com/2018/10/21/Django中path和url的区别/</id>
    <published>2018-10-21T01:00:29.809Z</published>
    <updated>2018-10-25T13:20:38.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django中path和url的区别"><a href="#Django中path和url的区别" class="headerlink" title="Django中path和url的区别"></a>Django中path和url的区别</h1><p>django中url和path都是配置路径，有什么不同？</p><p>from django.urls import path</p><p>from django.conf.urls import url</p><p>path和url是两个不同的模块，效果都是响应返回界面，path调用的是python第三方模块或框架，而url则是自定义的模块。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^login'</span>, views.login)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>引用自：<a href="https://blog.csdn.net/qq_26079279/article/details/80143365" target="_blank" rel="noopener">Django中path和url的用法总结</a></p></blockquote><p>当然，主要问题在于版本，1.x版本用url，2.x版本用path。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django中path和url的区别&quot;&gt;&lt;a href=&quot;#Django中path和url的区别&quot; class=&quot;headerlink&quot; title=&quot;Django中path和url的区别&quot;&gt;&lt;/a&gt;Django中path和url的区别&lt;/h1&gt;&lt;p&gt;django
      
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
      <category term="Django" scheme="https://rilzob.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>介绍</title>
    <link href="https://rilzob.com/2018/04/25/%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rilzob.com/2018/04/25/介绍/</id>
    <published>2018-04-25T11:47:48.000Z</published>
    <updated>2018-04-25T11:56:34.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rilzob的个人blog"><a href="#Rilzob的个人blog" class="headerlink" title="Rilzob的个人blog"></a>Rilzob的个人blog</h1><p>随便写，随便看</p><h3 id="邮箱："><a href="#邮箱：" class="headerlink" title="邮箱："></a>邮箱：</h3><p><strong> <a href="mailto:watermirrosir@163.com" target="_blank" rel="noopener">watermirrosir@163.com</a> </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rilzob的个人blog&quot;&gt;&lt;a href=&quot;#Rilzob的个人blog&quot; class=&quot;headerlink&quot; title=&quot;Rilzob的个人blog&quot;&gt;&lt;/a&gt;Rilzob的个人blog&lt;/h1&gt;&lt;p&gt;随便写，随便看&lt;/p&gt;
&lt;h3 id=&quot;邮箱：&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
