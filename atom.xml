<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>极氙世界</title>
  <icon>https://www.gravatar.com/avatar/01a8e9aa2bb51f443bf32f125ff052ed</icon>
  <subtitle>追求梦想，永不止步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rilzob.com/"/>
  <updated>2018-11-09T01:25:23.410Z</updated>
  <id>https://rilzob.com/</id>
  
  <author>
    <name>Rilzob</name>
    <email>watermirrorsir@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python中常用的内置函数</title>
    <link href="https://rilzob.com/2018/11/09/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>https://rilzob.com/2018/11/09/Python中常用的内置函数/</id>
    <published>2018-11-09T01:04:38.129Z</published>
    <updated>2018-11-09T01:25:23.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中常用的内置函数"><a href="#Python中常用的内置函数" class="headerlink" title="Python中常用的内置函数"></a>Python中常用的内置函数</h1><p>Python内置函数(built-in)是随着Python解释器的运行而被创建的。在Python程序中，你可以随时调用这些函数，而且不需要定义。在开发过程中，合理地使用这些内置函数能极大地提升你的开发效率。</p><p>这篇文章是对我在开发过程中经常遇到的内置函数的用法总结。<a id="more"></a></p><h2 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate()函数"></a>enumerate()函数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合成一个索引序列，同时列出数据和数据下标，一般用于for循环中。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enumerate(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>sequence: 一个序列、迭代器或其他可迭代对象。</li><li>start: 下标开始位置。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回enumerate(枚举)对象。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">'Spring'</span>), (<span class="number">2</span>, <span class="string">'Summer'</span>), (<span class="number">3</span>, <span class="string">'Fall'</span>), (<span class="number">4</span>, <span class="string">'Winter'</span>)]</span><br></pre></td></tr></table></figure><h4 id="普通的for循环"><a href="#普通的for循环" class="headerlink" title="普通的for循环"></a>普通的for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> seq:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, seq[i]</span><br><span class="line"><span class="meta">... </span>    i +=<span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure><h4 id="for循环使用enumerate"><a href="#for循环使用enumerate" class="headerlink" title="for循环使用enumerate()"></a>for循环使用enumerate()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, element</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure><h2 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance()函数"></a>isinstance()函数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><code>isinstance()</code>函数用来判断一个对象是否是一个已知类型，类似<code>type()</code>。</p><blockquote><p> <em><code>isinstance()</code>和<code>type()</code>的区别：</em></p><ul><li><em><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系；</em></li><li><em><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系；</em></li></ul><p><em>如果要判断两个类型是否相同推荐使用<code>isinstance()</code></em></p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isinstance(object, classinfo)</span><br></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>object: 实例对象;</li><li>classinfo: 可以直接或间接是类名、基本类型或者由它们组成的元组；</li></ul><p><em>说明：</em></p><p><em>对于基本类型来说classinfo可以是：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int, float, bool, complex, str(字符串), list, dict(字典), set, tuple</span><br></pre></td></tr></table></figure><p><em>要注意的是，classinfo的字符串是<strong>str</strong>而不是<strong>string</strong>，字典也是简写<strong>dict</strong>。</em></p><p><em>实例：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg=<span class="number">123</span></span><br><span class="line">isinstance(arg, int)    <span class="comment">#输出True</span></span><br><span class="line">isinstance(arg, str)    <span class="comment">#输出False</span></span><br><span class="line">isinstance(arg, string) <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>如果对象的类型与classinfo的类型相同则返回True，否则返回False。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance (a,int)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance (a,str)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance (a,(str,int,list))    <span class="comment"># 是元组中的一个返回 True</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h4 id="type与instance的区别"><a href="#type与instance的区别" class="headerlink" title="type与instance的区别"></a>type与instance的区别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">isinstance(A(), A)    <span class="comment"># returns True</span></span><br><span class="line">type(A()) == A        <span class="comment"># returns True</span></span><br><span class="line">isinstance(B(), A)    <span class="comment"># returns True</span></span><br><span class="line">type(B()) == A        <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中常用的内置函数&quot;&gt;&lt;a href=&quot;#Python中常用的内置函数&quot; class=&quot;headerlink&quot; title=&quot;Python中常用的内置函数&quot;&gt;&lt;/a&gt;Python中常用的内置函数&lt;/h1&gt;&lt;p&gt;Python内置函数(built-in)是随着Python解释器的运行而被创建的。在Python程序中，你可以随时调用这些函数，而且不需要定义。在开发过程中，合理地使用这些内置函数能极大地提升你的开发效率。&lt;/p&gt;
&lt;p&gt;这篇文章是对我在开发过程中经常遇到的内置函数的用法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的列表生成式</title>
    <link href="https://rilzob.com/2018/11/05/Python%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/"/>
    <id>https://rilzob.com/2018/11/05/Python中的列表生成式/</id>
    <published>2018-11-05T13:28:09.197Z</published>
    <updated>2018-11-05T13:31:49.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的列表生成式"><a href="#Python中的列表生成式" class="headerlink" title="Python中的列表生成式"></a>Python中的列表生成式</h1><p>顾名思义，<strong>列表生成式</strong>就是用来生成列表的特定语法形式的表达式。列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。<a id="more"></a></p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><h3 id="基础语法格式"><a href="#基础语法格式" class="headerlink" title="基础语法格式"></a>基础语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable]</span><br></pre></td></tr></table></figure><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>迭代iterable中的每个元素；</li><li>每次迭代都先把结果赋值给iter_var，然后通过exp得到一个新的计算值；</li><li>最后所有通过exp得到的计算值以一个新的列表的形式返回；</li></ul><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable:</span><br><span class="line">    L.append(exp)</span><br></pre></td></tr></table></figure><h3 id="带过滤功能的语法格式"><a href="#带过滤功能的语法格式" class="headerlink" title="带过滤功能的语法格式"></a>带过滤功能的语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable if_exp]</span><br></pre></td></tr></table></figure><h4 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>迭代iterable中的每个元素，每次迭代都先判断if_exp表达式是否成立，即判断将iter_var代入if_exp后表达式的结果，如果为真则进行下一步，如果为假则进行下一次迭代；</li><li>把迭代结果赋值给iter_var，然后通过exp得到一个新的计算值；</li><li>最后把所有通过exp得到的计算值以一个新列表的形式返回；</li></ul><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable:</span><br><span class="line">    if_exp:</span><br><span class="line">        L.append(exp)</span><br></pre></td></tr></table></figure><h3 id="循环嵌套的语法格式"><a href="#循环嵌套的语法格式" class="headerlink" title="循环嵌套的语法格式"></a>循环嵌套的语法格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp <span class="keyword">for</span> iter_var_A <span class="keyword">in</span> iterable_A <span class="keyword">for</span> iter_var_B <span class="keyword">in</span> iterable_B]</span><br></pre></td></tr></table></figure><h4 id="工作过程-2"><a href="#工作过程-2" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>迭代iterable_A中的每个元素，但是每迭代iterable_A中的一个元素，就把iterable_B中的所有元素都迭代一遍；</li><li>将每次迭代的变量iterable_var_A和iterable_var_B传入表达式exp(当然可以只传入两者之一)，计算出结果；</li><li>最后把所有通过exp得到的结果以一个新的列表的形式返回；</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>其实列表生成式是Python中的一种“语法糖”，也就是说列表生成式是Python提供的一种生成列表的简洁形式，应用列表生成式可以快速生成一个新的list。它最主要的应用场景是：<strong>根据已存在的可迭代对象推导出一个新的list</strong>。</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>我们可以对几个生成列表的要求分别通过“不使用列表生成式”和“使用列表生成式”来实现，然后做个对比总结。</p><h3 id="实例1：生成一个从3到10的数字列表"><a href="#实例1：生成一个从3到10的数字列表" class="headerlink" title="实例1：生成一个从3到10的数字列表"></a>实例1：生成一个从3到10的数字列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list1 = list(range(<span class="number">3</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list2 = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h3 id="实例2：生成一个2n-1的数字列表，n为从3到10的数字"><a href="#实例2：生成一个2n-1的数字列表，n为从3到10的数字" class="headerlink" title="实例2：生成一个2n+1的数字列表，n为从3到10的数字"></a>实例2：生成一个2n+1的数字列表，n为从3到10的数字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list3 = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">11</span>):</span><br><span class="line">    list3.append(<span class="number">2</span>*n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list4 = [<span class="number">2</span>*n + <span class="number">1</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h3 id="实例3：过滤出指定的数字列表中的值大于20的元素"><a href="#实例3：过滤出指定的数字列表中的值大于20的元素" class="headerlink" title="实例3：过滤出指定的数字列表中的值大于20的元素"></a>实例3：过滤出指定的数字列表中的值大于20的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">33</span>, <span class="number">26</span>, <span class="number">57</span>, <span class="number">99</span>]</span><br><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list5 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">20</span>:</span><br><span class="line">        list5.append(x)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list6 = [x <span class="keyword">for</span> x <span class="keyword">in</span> L <span class="keyword">if</span> x &lt; <span class="number">20</span>]</span><br></pre></td></tr></table></figure><h3 id="实例4：计算两个集合的全排列，并将结果保存至一个新的列表中"><a href="#实例4：计算两个集合的全排列，并将结果保存至一个新的列表中" class="headerlink" title="实例4：计算两个集合的全排列，并将结果保存至一个新的列表中"></a>实例4：计算两个集合的全排列，并将结果保存至一个新的列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L1 = [<span class="string">'香蕉'</span>, <span class="string">'苹果'</span>, <span class="string">'橙子'</span>]</span><br><span class="line">L2 = [<span class="string">'可乐'</span>, <span class="string">'牛奶'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list7 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L1:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> L2:</span><br><span class="line">        list7.append((x,y))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list8 = [(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> L1 <span class="keyword">for</span> y <span class="keyword">in</span> L2]</span><br></pre></td></tr></table></figure><h3 id="实例5：将一个字典转换成由一组元组组成的列表，元组的格式为-key-value"><a href="#实例5：将一个字典转换成由一组元组组成的列表，元组的格式为-key-value" class="headerlink" title="实例5：将一个字典转换成由一组元组组成的列表，元组的格式为(key,  value)"></a>实例5：将一个字典转换成由一组元组组成的列表，元组的格式为(key,  value)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D = &#123;<span class="string">'Tom'</span>: <span class="number">15</span>, <span class="string">'Jerry'</span>: <span class="number">18</span>, <span class="string">'Peter'</span>: <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用列表生成式</span></span><br><span class="line">list9 = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> D.items():</span><br><span class="line">    list9.append((k, v))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用列表生成式</span></span><br><span class="line">list10 = []</span><br><span class="line">list10 = [(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> D.items()]</span><br></pre></td></tr></table></figure><p>可见，在一些情况下使用列表生成式确实要方便、简洁很多，使用一行代码就搞定了。</p><h2 id="列表生成式与map、filter等高阶函数对比"><a href="#列表生成式与map、filter等高阶函数对比" class="headerlink" title="列表生成式与map、filter等高阶函数对比"></a>列表生成式与map、filter等高阶函数对比</h2><p>列表生成式的功能与之前文章提到的<code>map()</code>和<code>filter()</code>高阶函数功能很像，比如下面两个例子：</p><h3 id="实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样"><a href="#实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样" class="headerlink" title="实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样"></a>实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'TOM'</span>, <span class="string">'Peter'</span>, <span class="number">10</span>, <span class="string">'Jerry'</span>]</span><br><span class="line"><span class="comment"># 用列表生成式实现</span></span><br><span class="line">list1 = [x.lower() <span class="keyword">if</span> isinstance(x, str) <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> L]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用map()函数实现</span></span><br><span class="line">list2 = list(map(<span class="keyword">lambda</span> x : x.lower() <span class="keyword">if</span> isinstance(x, str) <span class="keyword">else</span> x, L))</span><br></pre></td></tr></table></figure><h3 id="实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除"><a href="#实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除" class="headerlink" title="实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除"></a>实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'TOM'</span>, <span class="string">'Peter'</span>, <span class="number">10</span>, <span class="string">'Jerry'</span>]</span><br><span class="line"><span class="comment"># 用列表生成式实现</span></span><br><span class="line">list3 = [x.lower() <span class="keyword">for</span> x <span class="keyword">in</span> L <span class="keyword">if</span> isinstance(x, str)] </span><br><span class="line"><span class="comment"># 注意：这里for x in L相对if isinstance的先后位置，与上一个示例相比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用map()和filter()函数实现</span></span><br><span class="line">list4 = list(map(<span class="keyword">lambda</span> x: x.lower(), filter(<span class="keyword">lambda</span> x: isinstance(x, str), L)))</span><br></pre></td></tr></table></figure><p>对于大部分需求来讲，使用列表生成式和使用高阶函数都能实现。但是<code>map</code>和<code>filter</code>等一些高阶函数在Python3.x中的返回值类型变成了Iterator(迭代器)对象，这对于那些元素数量很大或无限的可迭代对象来说显然是更合适的，因为可以避免不必要的内存空间浪费。</p><blockquote><p>引用文章：</p><ol><li><a href="https://www.cnblogs.com/yyds/p/6281453.html" target="_blank" rel="noopener">Python之列表生成式、生成器、可迭代对象与迭代器 - 云游道士 - 博客园</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431779637539089fd627094a43a8a7c77e6102e3a811000" target="_blank" rel="noopener">列表生成式 - 廖雪峰的官方网站</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的列表生成式&quot;&gt;&lt;a href=&quot;#Python中的列表生成式&quot; class=&quot;headerlink&quot; title=&quot;Python中的列表生成式&quot;&gt;&lt;/a&gt;Python中的列表生成式&lt;/h1&gt;&lt;p&gt;顾名思义，&lt;strong&gt;列表生成式&lt;/strong&gt;就是用来生成列表的特定语法形式的表达式。列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的装饰器</title>
    <link href="https://rilzob.com/2018/11/04/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://rilzob.com/2018/11/04/Python中的装饰器/</id>
    <published>2018-11-04T05:34:51.795Z</published>
    <updated>2018-11-04T05:46:29.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的装饰器"><a href="#Python中的装饰器" class="headerlink" title="Python中的装饰器"></a>Python中的装饰器</h1><p>装饰器本质上是一个<strong>Python函数</strong>，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的<strong>返回值也是一个函数对象</strong>。</p><p>它经常用于有切面需求的场景，比如：插入日志、性能检测、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能无关的雷同代码并继续重用。概括地讲，装饰器的作用就是为已经存在对象添加额外的功能。<a id="more"></a></p><p>先看一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br></pre></td></tr></table></figure><p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line">    logging.info(<span class="string">"foo is running"</span>)</span><br></pre></td></tr></table></figure><p>如果有些函数也有类似的需求，怎么做？都写一个logging在函数内？这样就造成了大量雷同的代码，为了减少重复写代码，可以这么做，重新定义一个函数专门处理日志，日志处理完之后再执行真正的业务代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">    func()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line">use_logging(bar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>逻辑上不难理解，但这样的话，我们每次都要将一个函数作为参数传递给<code>use_logging</code>函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行<code>bar()</code>，但是现在不得不改成<code>use_logging(bar)</code>。那么有没有更好的方式呢？当然有，答案就是<strong>装饰器</strong>。</p><h2 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line">    </span><br><span class="line">bar = use_logging(bar)</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>函数<code>use_logging</code>就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像<code>bar</code>被<code>logging</code>包起来，被装饰了。在这个例子中，函数进入和退出时，被称为一个横切面(Aspect)，这种编程方法称为<strong>面向切面的编程(Aspect-Oriented Programming)</strong>。</p><p><strong>@符号是装饰器的语法糖</strong>，在定义函数的时候使用，避免再一次赋值操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line">    </span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>如上所示，使用@符号我们就可以省去<code>bar = use_logging(bar)</code>这一句了，直接调用<code>bar()</code>即可得到想要的结果。如果我们有其他的类似函数，我们就可以继续调用装饰器来修饰函数，而不用重新修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p><p><em>装饰器在Python中使用如此方便都要归功于Python的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他的变量，可以作为返回值，可以被定义在另一个函数内。</em></p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器还有更大的灵活性，例如带参数的装饰器：在上面的装饰器调用中，比如<code>@use_logging</code>，该装饰器唯一的参数就是执行业务的函数。装饰器的语法云溪我们在调用时，提供其他参数比如<code>@decorator(a)</code>。这样，就为装饰器的编写和使用提供了更大的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</span><br><span class="line">                logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'foo'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"i am %s"</span> % name)</span><br><span class="line">    </span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># WARNING:root:bar is running</span></span><br><span class="line"><span class="comment"># i am bar</span></span><br></pre></td></tr></table></figure><p>上面的<code>use_logging</code>是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我们使用<code>@use_logging(level=&quot;warn&quot;)</code>调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大，高内聚，封装性等优点。使用类装饰器还可以依赖类内部的<code>__call__</code>方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'class decorator running'</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        print(<span class="string">'class decorator ending'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'bar'</span>)</span><br><span class="line">    </span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># class decorator running</span></span><br><span class="line"><span class="comment"># bar</span></span><br><span class="line"><span class="comment"># class decorator ending</span></span><br></pre></td></tr></table></figure><h2 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h2><p>使用装饰器极大地复用了代码，但是它有个缺点就是原函数的元信息不见了，比如函数的<code>docstring</code>、<code>__name__</code>、参数列表，先看例子：</p><p>装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">"was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''do some math'''</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br></pre></td></tr></table></figure><p>该函数完全等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''do some math'''</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line">f = logged(f)</span><br></pre></td></tr></table></figure><p>不难发现，函数<code>f</code>被<code>with_logging</code>替代了，当然它的<code>docstring</code>、<code>__name__</code>就变成了<code>with_logging</code>函数的信息了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(f.__name__)</span><br><span class="line">print(f.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># with_logging</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure><p>这个问题就比较严重了，好在我们有<code>function.wraps</code>，<code>wraps</code>本身也是一个装饰器，它能把<strong>原函数的元信息拷贝到装饰器函数中</strong>，这使得装饰器函数也有和原函数一样的元信息了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">"was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''do some math'''</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line">print(f.__name__)</span><br><span class="line">print(f.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># f</span></span><br><span class="line"><span class="comment"># do some math</span></span><br></pre></td></tr></table></figure><h2 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a>内置装饰器</h2><p><code>@staticmethod</code>、<code>@classmethod</code>、<code>@property</code></p><p>装饰器的顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure><blockquote><p>引用资料：</p><ol><li><a href="https://www.zhihu.com/question/26930016" target="_blank" rel="noopener">如何理解Python装饰器？ - 知乎</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的装饰器&quot;&gt;&lt;a href=&quot;#Python中的装饰器&quot; class=&quot;headerlink&quot; title=&quot;Python中的装饰器&quot;&gt;&lt;/a&gt;Python中的装饰器&lt;/h1&gt;&lt;p&gt;装饰器本质上是一个&lt;strong&gt;Python函数&lt;/strong&gt;，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的&lt;strong&gt;返回值也是一个函数对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它经常用于有切面需求的场景，比如：插入日志、性能检测、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能无关的雷同代码并继续重用。概括地讲，装饰器的作用就是为已经存在对象添加额外的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的Lambda函数及其用法</title>
    <link href="https://rilzob.com/2018/11/01/Python%E4%B8%AD%E7%9A%84Lambda%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95/"/>
    <id>https://rilzob.com/2018/11/01/Python中的Lambda函数及其用法/</id>
    <published>2018-11-01T11:11:40.177Z</published>
    <updated>2018-11-01T11:17:16.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的Lambda函数及其用法"><a href="#Python中的Lambda函数及其用法" class="headerlink" title="Python中的Lambda函数及其用法"></a>Python中的Lambda函数及其用法</h1><p><strong>Lambda函数</strong>又称为匿名函数，<strong>匿名函数</strong>就是没有名字的函数。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就可以将其定义为匿名函数。</p><p>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。<a id="more"></a></p><p>先来看个简单的lambda函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x102bc1c80</span>&gt;</span><br></pre></td></tr></table></figure><p><code>x</code>和<code>y</code>是函数的两个参数，冒号后面的表达式是函数的返回值，很明显这个匿名函数就是在求两个变量的和，但作为一个函数，没有名字如何使用呢？</p><p>这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x, y : x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x102bc2140</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>它等同于常规函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add1</span><br><span class="line">&lt;function add1 at <span class="number">0x102bc1c80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="lambda函数的使用场景-函数式编程"><a href="#lambda函数的使用场景-函数式编程" class="headerlink" title="lambda函数的使用场景(函数式编程)"></a>lambda函数的使用场景(函数式编程)</h2><h3 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h3><p>例如：一个整数列表，要求按照列表中元素的绝对值大小升序排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">-4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">-6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=<span class="keyword">lambda</span> x: abs(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>]</span><br></pre></td></tr></table></figure><p>排序函数<code>sorted</code>支持接收一个函数作为参数，该参数作为<code>sorted</code>的排序依据，这里按照列表元素的绝对值进行排序。</p><p>当然，也可以通过普通函数来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> abs(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=foo)</span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>]</span><br></pre></td></tr></table></figure><p>只不过是使用这种方式，代码看起来不够<strong>Pythonic</strong>而已。</p><p><em>lambda：这是Python支持的一种有趣的语法，它允许你快速定义单行的最小函数，可以用在任何需要函数的地方:</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x,y : x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="keyword">lambda</span> x,y:x+y)(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="map-reduce-filter函数"><a href="#map-reduce-filter函数" class="headerlink" title="map,reduce,filter函数"></a>map,reduce,filter函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求1~20的平方</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x:x*x,range(<span class="number">1</span>,<span class="number">21</span>))) </span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>, <span class="number">144</span>, <span class="number">169</span>, <span class="number">196</span>, <span class="number">225</span>, <span class="number">256</span>, <span class="number">289</span>, <span class="number">324</span>, <span class="number">361</span>, <span class="number">400</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求1~20之间的偶数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x:x%<span class="number">2</span> == <span class="number">0</span>,range(<span class="number">1</span>,<span class="number">21</span>))) </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求1~100之和,再加上10000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x+y,range(<span class="number">1</span>,<span class="number">101</span>),<span class="number">10000</span>)</span><br><span class="line"><span class="number">15050</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><em>闭包：一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域也依然能被访问到。</em></p><p>看一个用lambda函数作为闭包的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x+n <span class="comment"># 将匿名函数作为返回值返回</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add2 = add(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add2(<span class="number">15</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>这里的<code>lambda</code>函数就是一个闭包，在全局作用域范围中，<code>add2(15)</code>可以正常执行且返回值为20。之所以返回20是因为在<code>add</code>局部作用域中，变量n的值在闭包的作用下也可以被访问到。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431843456408652233b88b424613aa8ec2fe032fd85a000" target="_blank" rel="noopener">匿名函数 - 廖雪峰的官方网站</a></li><li><a href="https://www.cnblogs.com/huangbiquan/p/8030298.html" target="_blank" rel="noopener">深入理解Lambda函数及其用法 - 碧水幽幽泉 - 博客园</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的Lambda函数及其用法&quot;&gt;&lt;a href=&quot;#Python中的Lambda函数及其用法&quot; class=&quot;headerlink&quot; title=&quot;Python中的Lambda函数及其用法&quot;&gt;&lt;/a&gt;Python中的Lambda函数及其用法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Lambda函数&lt;/strong&gt;又称为匿名函数，&lt;strong&gt;匿名函数&lt;/strong&gt;就是没有名字的函数。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就可以将其定义为匿名函数。&lt;/p&gt;
&lt;p&gt;匿名函数有个限制，就是&lt;strong&gt;只能有一个表达式&lt;/strong&gt;，不用写&lt;code&gt;return&lt;/code&gt;，返回值就是该表达式的结果。&lt;/p&gt;
&lt;p&gt;用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的高阶函数</title>
    <link href="https://rilzob.com/2018/10/29/Python%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://rilzob.com/2018/10/29/Python中的高阶函数/</id>
    <published>2018-10-29T15:06:28.791Z</published>
    <updated>2018-10-30T01:40:04.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的高阶函数"><a href="#Python中的高阶函数" class="headerlink" title="Python中的高阶函数"></a>Python中的高阶函数</h1><p>在熟悉了Python基础知识后，我们已经可以做一些脚本开发，或者简单的程序。然而，当我们开发较为复杂的程序时，仅使用基础知识内容就会显得比较吃力。这时，了解Python中的一些高级特性会使我们的开发过程变得简单和快乐。</p><p>在函数式编程中，我们可以将函数当做变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为<strong>高阶函数(Higher-order-Functions)</strong>。</p><a id="more"></a><p>看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(g, arr)</span>:</span></span><br><span class="line"><span class="keyword">return</span> [g(x) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br></pre></td></tr></table></figure><p>上面的代码中<code>func</code>是一个高阶函数，它接收两个参数，第一个参数是函数，第二个参数是数组，<code>func</code>的功能是将函数g逐个作用于数组arr上，并返回一个新的数组。比如，我们可以这样用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr1 = func(double, list) <span class="comment"># arr1 = [2, 4, 6, 8]</span></span><br><span class="line">arr2 = func(square, list) <span class="comment"># arr2 = [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p>说到高阶函数，就不得不提到<strong>闭包</strong>，这里介绍一下Python中闭包的定义：</p><blockquote><p>如果在一个内部函数里，对外部作用域(但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包(closure)。</p></blockquote><p>就拿此例来说，内部函数<code>double</code>中包含了对函数<code>func</code>中局部变量<code>list</code>的引用，这就是闭包。</p><p><code>map</code> <code>reduce</code> <code>filter</code> <code>sorted</code>是Python中较为常用的内置高阶函数，它们为函数式编程提供了不少便利。</p><p><em>说明：本文介绍的内置高阶函数的定义可能会因为Python版本的不同而有所不同，文章以Python3.x版本中的定义为标准。</em></p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code>函数的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里函数一定要作为map的第一个参数，而不是第二个参数，否则会产生报错。</p><p><strong>解释</strong>：function函数会作用于可迭代对象的每一个元素，生成结果，并返回一个迭代器。更加具体一点说就是<code>map</code>函数接收两个参数，一个是函数，一个是Iterable，<code>map</code>将传入的函数依次作用到Iterable的每个元素，并把结果作为新的Iterator返回。</p><p>举例说明，比如我们一个函数f(x)=x^2，要把这个函数作用在一个list[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用<code>map()</code>实现。</p><p>现在，我们用Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p><code>map</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个Iterator，Iterator是惰性序列，因此需要通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p><p>你可能会想，不需要<code>map</code>函数，写一个循环，也可以计算出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:</span><br><span class="line">    L.append(f(n))</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure><p>的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？明显可读性就差了很多。</p><p>所以，<code>map</code>作为高阶函数，体现了Python的设计原则优雅、明确、简单，<strong>事实上它把运算规则抽象化</strong>。因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把list中的所有数字转化为字符串格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br></pre></td></tr></table></figure><p>只需一行代码。</p><p>看一些简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">&lt;map at <span class="number">0x106adfe48</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))   <span class="comment"># 使用 lambda</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]))</span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>再来看个复杂一点例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> *x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">funcs = [double, triple, square]  <span class="comment"># 列表元素是函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于 [double(4), triple(4), square(4)]</span></span><br><span class="line">value = list(map(<span class="keyword">lambda</span> f: f(<span class="number">4</span>), funcs))</span><br><span class="line">print(value)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure><p>最后我想要说明一点，迭代器有一个特点，就是所有的迭代器对象都可以作为<code>next()</code>内置函数的参数调用，每调用一次，就按角标顺序返回一个值，还是用代码讲吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter = map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：1</span></span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：4</span></span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：9</span></span><br><span class="line">print(next(iter)) <span class="comment"># 打印值为：16</span></span><br><span class="line">print(next(iter)) <span class="comment"># 抛出StopIteration 异常</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce</code>函数的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>reduce</code>函数必须接受两个参数，先将iterable的前两个item传给function，即function(item1, item2)，函数的返回值和iterable的下一个item再传给function，即function(function(item1, item2), item3)，如此迭代，直到iterable没有元素，如果有initializer，则作为初始值调用。</p><p>也就是说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br><span class="line"><span class="comment"># 列表中是以从左到右作为优先顺序</span></span><br></pre></td></tr></table></figure><p>看一些例子，就能很快理解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 相当于 ((1 * 2) * 3) * 4</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x - y, [<span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>], <span class="number">20</span>)  <span class="comment"># ((20 - 8) - 5) - 1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> (a &gt; b) <span class="keyword">else</span> b   <span class="comment"># 两两比较，取最大值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(f, [<span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span> <span class="comment"># 把序列[1, 3, 5, 7, 9]变换成整数13579</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code>函数用于过滤元素，它的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：和<code>map</code>类似，<code>filter</code>也接收一个函数和一个序列。但和<code>map</code>不同的是，<code>filter</code>把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。将function依次作用于iterable的每个item上，即function(item)，用function返回值为True的item构成iterator作为<code>filter</code>的最终返回值。</p><p>看一些例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>even_num = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>even_num</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd_num = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd_num</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x &lt; <span class="string">'g'</span>, <span class="string">'hijack'</span>))</span><br><span class="line"><span class="string">'ac'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x: x &lt; <span class="string">'g'</span>, <span class="string">'hijack'</span>)</span><br><span class="line">&lt;filter object at <span class="number">0x1034b4080</span>&gt;   <span class="comment"># python3</span></span><br></pre></td></tr></table></figure><p>可见用<code>filter</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p><p>注意到<code>filter</code>函数返回的同样是一个Iterator，也就是一个惰性序列，所以要强迫<code>filter</code>完成计算结果，需要用<code>list()</code>函数获得所有结果。</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p><code>sorted</code>函数用于对list进行排序，它的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable, *, key=<span class="keyword">None</span>, reverse=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>sorted</code>有两个可选参数，必须指定为关键字参数。将key指定的函数作用于iterable的每一个元素上，并根据key函数返回的结果进行排序，最终返回一个新的排序列表。key默认值为None，即直接比较元素大小。</p><p>reverse是一个布尔值。如果设置为True，则列表元素将按照比较结果相反的方式进行排序。</p><p>看一些例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>])</span><br><span class="line">[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</span><br><span class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</span><br><span class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</span><br></pre></td></tr></table></figure><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且核心代码可以保持得非常简洁。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>可接受其他函数作为参数的函数称为高阶函数；</li><li><code>map</code> <code>reduce</code> <code>filter</code> <code>sorted</code>为函数式编程提供了不少便利，可使代码变得更简洁；</li><li>通过<code>map()</code>来对Iterable中的每个元素进行相同的函数处理最终返回一个Iterator。</li><li><code>reduce()</code>类似栈的思想，先让栈顶的两个元素出栈作为函数的两个参数，再将函数的返回值入栈，然后再让栈顶两个元素出栈，不断循环下去，直到栈里没有元素为止。</li><li><code>filter()</code>的作用是从一个序列中筛选出符合条件的元素。由于<code>filter()</code>使用了惰性计算，所以只有在取<code>filter()</code>结果的时候，才会真正筛选并每次返回下一个筛出的元素。</li><li><code>sorted()</code>也是一个高阶函数。用<code>sorted()</code>排序的关键在于实现一个映射函数。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ol><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317849054170d563b13f0fa4ce6ba1cd86e18103f28000" target="_blank" rel="noopener">高阶函数 - 廖雪峰的官方网站</a></li><li><a href="http://wiki.jikexueyuan.com/project/explore-python/Functional/map_reduce_filter.html" target="_blank" rel="noopener">map/reduce/filter - Python 之旅 - 极客学院Wiki</a></li><li><a href="http://wiki.jikexueyuan.com/project/explore-python/Functional/high_order_func.html" target="_blank" rel="noopener">高阶函数 - Python 之旅 - 极客学院Wiki</a></li><li><a href="https://www.jianshu.com/p/bd595a0006cd" target="_blank" rel="noopener">Python笔记(二)：高级特性之高阶函数 - 简书</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中的高阶函数&quot;&gt;&lt;a href=&quot;#Python中的高阶函数&quot; class=&quot;headerlink&quot; title=&quot;Python中的高阶函数&quot;&gt;&lt;/a&gt;Python中的高阶函数&lt;/h1&gt;&lt;p&gt;在熟悉了Python基础知识后，我们已经可以做一些脚本开发，或者简单的程序。然而，当我们开发较为复杂的程序时，仅使用基础知识内容就会显得比较吃力。这时，了解Python中的一些高级特性会使我们的开发过程变得简单和快乐。&lt;/p&gt;
&lt;p&gt;在函数式编程中，我们可以将函数当做变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为&lt;strong&gt;高阶函数(Higher-order-Functions)&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中@classmethod和@staticmethod的区别</title>
    <link href="https://rilzob.com/2018/10/27/Python%E4%B8%AD@classmethod%E5%92%8C@staticmethod%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/27/Python中@classmethod和@staticmethod的区别的副本/</id>
    <published>2018-10-27T04:46:02.147Z</published>
    <updated>2018-10-27T04:50:31.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中-classmethod和-staticmethod的区别"><a href="#Python中-classmethod和-staticmethod的区别" class="headerlink" title="Python中@classmethod和@staticmethod的区别"></a>Python中@classmethod和@staticmethod的区别</h1><p>接上一篇介绍<a href="https://rilzob.github.io/2018/10/27/Python%E4%B8%AD@staticmethod%E5%92%8C@classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/" target="_blank" rel="noopener">Python中@staticmethod和@classmethod的用法</a>的文章。虽然<code>@classmethod</code>和<code>@staticmethod</code>非常相似，但两个修饰符的使用情况仍<strong>略有不同</strong>。<a id="more"></a></p><p>从它们的使用上来看：</p><ul><li><code>@classmethod</code>必须引用一个类对象作为第一个参数，即第一个参数需要是表示自身类的cls参数。同时<code>@classmethod</code>因持有cls参数，所以可以调用类的属性，类的方法，实例化对象等，避免硬编码。</li><li><code>@staticmethod</code>则可以完全没有参数，但在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名()。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">"-"</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">date2 = Date.from_string(<span class="string">"27-10-2018"</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">"27-10-2018"</span>)</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>让我们假设这样一个类的例子，用来处理日期信息(这将是我们的样板)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br></pre></td></tr></table></figure><p>显然，这个类可以用来存储关于某些日期的信息(没有时区信息；假设所有日期都以UTC表示)。</p><p>这个类中有<code>__init__</code>，它是Python类实例的初始化方法，它接收参数作为类实例方法，具有第一个非可选参数<code>self</code>(作为对新创建实例的引用)。</p><h3 id="Class-Method"><a href="#Class-Method" class="headerlink" title="Class Method"></a>Class Method</h3><p>我们有一些任务，通过使用<code>@classmethod</code>可以很好地完成它们。</p><p><em>假设我们想要创建许多Date类实例，其日期信息来自外部输入(编码格式为’dd-mm-year’的字符串)，并假设我们必须在项目源代码的不同位置执行此操作。</em></p><p>所以我们这里必须做到：</p><ol><li>解析输入的字符串以接收日、月、年作为三个整数变量或由这些变量组成的三元组。</li><li>通过将上面求到的值传递给初始化调用来创建Date类实例。</li></ol><p>代码看起来会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">day, month, year = map(int, string_date.split(<span class="string">'-'</span>))</span><br><span class="line">date1 = Date(day, month, year)</span><br></pre></td></tr></table></figure><p>如果使用<code>@classmethod</code>修饰符写在类中，将会是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'27-10-2018'</span>)</span><br></pre></td></tr></table></figure><p>让我们更仔细地看看上面的代码实现，并回想一下我们做了什么？</p><ul><li><p>我们在一个地方实现了日期字符串解析函数，现在它可以重用。</p></li><li><p>将日期字符串解析函数封装在类中并且工作正常(当然你可以在其他地方实现日期字符串解析作为单个函数，但这个解决方案更适合OOP范例)。</p></li><li><code>cls</code>是一个保存<strong>类本身</strong>的对象，而不是类的实例。这很酷😎，因为如果我们继承Date类，所有子类也会定义<code>from_string()</code>。</li></ul><h3 id="Static-Method"><a href="#Static-Method" class="headerlink" title="Static Method"></a>Static Method</h3><p><code>@staticmethod</code>确实与<code>@classmethod</code>很相似，但<code>@staticmethod</code>不需要任何强制性参数(如类方法或实例方法)。</p><p>让我们看看下一个任务(下一个用例):</p><p><em>假设我们有一个日期字符串，我们想要以某种方式进行验证它是否符合要求的格式。此任务也需要封装在Date类中，但不需要实例化它。</em></p><p>这里使用<code>@staticmethod</code>就会很有效。让我们看一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">    day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">    <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usage:</span></span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'27-10-2018'</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到<code>is_date</code>是个boolen型变量，而非<code>is_date_valid</code>函数返回的day，month，year三个整型数据。</p><p>因此，我们可以从<code>@staticmethod</code>的使用中看到，我们无法访问类的内容——它基本上只是一个函数，在语法上称为方法，无法访问对象及其内部(字段和其他类方法)。而使用<code>@classmethod</code>却可以做到。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上面的文章已经很全面地总结了<code>@classmethod</code>和<code>@staticmethod</code>的区别。在这里我想强调当你<strong>创建构造函数</strong>时，你应该选择<code>@classmethod</code>而不是<code>@staticmethod</code>的另一个原因。在上面的例子中，使用<code>@classmethod</code> <code>from_string()</code>作为Factory，接收不符合<code>__init__</code>要求的参数创建Date类实例。使用<code>@staticmethod</code>可以完成同样的操作，如下面代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, month, day, year)</span>:</span></span><br><span class="line">    self.month = month</span><br><span class="line">    self.day   = day</span><br><span class="line">    self.year  = year</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125;"</span>.format(self.month, self.day, self.year)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">millenium</span><span class="params">(month, day)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Date(month, day, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">new_year = Date(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2013</span>)               <span class="comment"># Creates a new Date object</span></span><br><span class="line">millenium_new_year = Date.millenium(<span class="number">1</span>, <span class="number">1</span>) <span class="comment"># also creates a Date object. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Proof:</span></span><br><span class="line">new_year.display()           <span class="comment"># "1-1-2013"</span></span><br><span class="line">millenium_new_year.display() <span class="comment"># "1-1-2000"</span></span><br><span class="line"></span><br><span class="line">isinstance(new_year, Date) <span class="comment"># True</span></span><br><span class="line">isinstance(millenium_new_year, Date) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>运行结果显示<code>new_year</code>和<code>millenium_new_year</code>都是Date类实例。</p><p>但是，如果仔细观察就会发现，<code>millenium_new_year</code>是以<strong>硬编码</strong>的方式创建的Date类实例。这意味着即使一个类继承Date类，该子类仍将创建普通的Date对象即父类对象，而不具有该子类本身的任何属性。请参阅以下示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTime</span><span class="params">(Date)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125; - 00:00:00PM"</span>.format(self.month, self.day, self.year)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datetime1 = DateTime(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1990</span>)</span><br><span class="line">datetime2 = DateTime.millenium(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">isinstance(datetime1, DateTime) <span class="comment"># True</span></span><br><span class="line">isinstance(datetime2, DateTime) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">datetime1.display() <span class="comment"># returns "10-10-1990 - 00:00:00PM"</span></span><br><span class="line">datetime2.display() <span class="comment"># returns "10-10-2000" because it's not a DateTime object but a Date object. Check the implementation of the millenium method on the Date class</span></span><br></pre></td></tr></table></figure><p>DateTime类继承Date类，因此具有Date类的<code>millenium()</code>方法。<code>datetime2</code>通过调用DateTime继承来的<code>millenium()</code>方法来创建DateTime类实例。然而代码却显示<code>datetime2</code>并不是DateTime类实例(<code>isinstance(datetime2, DateTime) # False</code>)。怎么回事？<strong>这是因为使用了<code>@staticmethod</code>修饰符</strong>。</p><p>在大多数情况下，这是你不希望出现的。如果你想要的是一个”完整“的类实例，并且是通过调用它的父类方法所创建的话，那么<code>@classmethod</code>就是你所需要的。</p><p>将<code>Date.millenium()</code>重写为(这是上述代码中唯一改变的部分)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">millenium</span><span class="params">(cls, month, day)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cls(month, day, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>确保该类的创建不是通过硬编码。<code>cls</code>可以是任何子类，生成的对象将正确地成为cls的实例。我们来试试吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">datetime1 = DateTime(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1990</span>)</span><br><span class="line">datetime2 = DateTime.millenium(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">isinstance(datetime1, DateTime) <span class="comment"># True</span></span><br><span class="line">isinstance(datetime2, DateTime) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datetime1.display() <span class="comment"># "10-10-1990 - 00:00:00PM"</span></span><br><span class="line">datetime2.display() <span class="comment"># "10-10-2000 - 00:00:00PM"</span></span><br></pre></td></tr></table></figure><p>看吧，用<code>@classmethod</code>替代<code>@staticmethod</code>你不希望出现的情况就会消失。<strong>使用了<code>@staticmethod</code>修饰符定义构造函数就是问题出现的关键。</strong></p><p>文章的内容有点多，可能需要花一些时间进行理解，最后提供一个小示例帮助大家加深记忆一下<code>@classmethod</code>和<code>@staticmethod</code>的<strong>主要不同</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'foo'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'static_foo'</span></span><br><span class="line">        <span class="keyword">print</span> A.bar</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'class_foo'</span></span><br><span class="line">        <span class="keyword">print</span> cls.bar</span><br><span class="line">        cls().foo()</span><br><span class="line"> </span><br><span class="line">A.static_foo()</span><br><span class="line">A.class_foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">static_foo</span><br><span class="line"><span class="number">1</span></span><br><span class="line">class_foo</span><br><span class="line"><span class="number">1</span></span><br><span class="line">foo</span><br></pre></td></tr></table></figure><blockquote><p>引用文章：</p><ol><li><a href="https://blog.csdn.net/handsomekang/article/details/9615239" target="_blank" rel="noopener">飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客</a></li><li><a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">python - Meaning of @classmethod and @staticmethod for beginner? - Stack Overflow</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中-classmethod和-staticmethod的区别&quot;&gt;&lt;a href=&quot;#Python中-classmethod和-staticmethod的区别&quot; class=&quot;headerlink&quot; title=&quot;Python中@classmethod和@staticmethod的区别&quot;&gt;&lt;/a&gt;Python中@classmethod和@staticmethod的区别&lt;/h1&gt;&lt;p&gt;接上一篇介绍&lt;a href=&quot;https://rilzob.github.io/2018/10/27/Python%E4%B8%AD@staticmethod%E5%92%8C@classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python中@staticmethod和@classmethod的用法&lt;/a&gt;的文章。虽然&lt;code&gt;@classmethod&lt;/code&gt;和&lt;code&gt;@staticmethod&lt;/code&gt;非常相似，但两个修饰符的使用情况仍&lt;strong&gt;略有不同&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中@staticmethod和@classmethod的用法</title>
    <link href="https://rilzob.com/2018/10/27/Python%E4%B8%AD@staticmethod%E5%92%8C@classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/27/Python中@staticmethod和@classmethod的用法的副本/</id>
    <published>2018-10-27T01:50:32.730Z</published>
    <updated>2018-10-27T02:01:47.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中-staticmethod和-classmethod的用法"><a href="#Python中-staticmethod和-classmethod的用法" class="headerlink" title="Python中@staticmethod和@classmethod的用法"></a>Python中@staticmethod和@classmethod的用法</h1><p>一般来说，调用某个类的方法，需要预先生成一个实例，再通过实例调用方法。Java中有静态方法，可以使用类直接进行调用。Python中提供了两个修饰符<code>@staticmethod</code>和<code>@classmethod</code>以达到类似效果，使用它们就可以不需要实例化，直接<strong>类名.方法名()</strong>来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类中，同时有利于命名空间的整洁。<a id="more"></a></p><h2 id="staticmethod"><a href="#staticmethod" class="headerlink" title="@staticmethod"></a>@staticmethod</h2><p><code>@staticmethod</code>声明方法为静态方法，直接通过<strong>类名.方法名()</strong>调用。经过<code>@staticmethod</code>修饰的方法，<strong>不需要self参数</strong>，其使用方法和直接调用函数一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接定义一个test()函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"i am a normal method!"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#定义一个类，其中包括一个类方法，采用@staticmethod修饰    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_test</span><span class="params">()</span>:</span> <span class="comment"># 没有self参数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"i am a static method!"</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test()</span><br><span class="line">    T.static_test()</span><br><span class="line">    T().static_test()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">i am a normal method!</span><br><span class="line">i am a static method!</span><br><span class="line">i am a static method!</span><br></pre></td></tr></table></figure><h2 id="classmethod"><a href="#classmethod" class="headerlink" title="@classmethod"></a>@classmethod</h2><p><code>@classmethod</code>声明方法为类方法，直接通过<strong>类名.方法名()</strong>调用。经过<code>@classmethod</code>修饰的方法，<strong>不需要self参数</strong>，但是<strong>需要一个标识类本身的cls参数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_test</span><span class="params">(cls)</span>:</span> <span class="comment"># 必须有cls参数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"i am a class method"</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    T.class_test()</span><br><span class="line">    T().class_test()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">i am a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">i</span> <span class="title">am</span> <span class="title">a</span> <span class="title">class</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure><p><em><code>@classmethod</code>另一个实用的用法：在不改变已经写好的类里面的方法的情况下，对输入的数据进行处理。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出年月日，正常的情况下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year=<span class="number">0</span>, month=<span class="number">0</span>, day=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_date</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"year: %d, month: %d, day: %d"</span> % (self.year, self.month, self.day)</span><br><span class="line">    </span><br><span class="line">year = <span class="number">2018</span></span><br><span class="line">month = <span class="number">10</span></span><br><span class="line">day = <span class="number">27</span></span><br><span class="line"></span><br><span class="line">demo1 = demo1(year, month, day)</span><br><span class="line">print(demo1.out_date())  <span class="comment"># year: 2018, month: 10, day: 27</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户输入的是2018-10-27格式，需要在输出前处理一下，就可以使用classmethod达到想要的效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year=<span class="number">0</span>, month=<span class="number">0</span>, day=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_date</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"year: %d, month: %d, day: %d"</span> % (self.year, self.month, self.day)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_out</span><span class="params">(cls, date_string)</span>:</span></span><br><span class="line">        year, month, day = map(int, date_string.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">return</span> cls(year, month, day)</span><br><span class="line">    </span><br><span class="line">date = <span class="string">"2018-10-27"</span></span><br><span class="line">year = <span class="number">2017</span></span><br><span class="line">month = <span class="number">7</span></span><br><span class="line">day = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    demo2 = demo2.pre_out(date)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    demo2 = demo2(year, month, day)</span><br><span class="line">    </span><br><span class="line">print(demo2.out_date())  <span class="comment"># year: 2018, month: 10, day: 6</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>@staticmethod</code>不需要表示自身对象的self参数和自身类的cls参数，就跟使用函数一样。</li><li><code>@classmethod</code>也不需要self参数，但第一个参数需要是表示自身类的cls参数。</li><li>在Python中类和实例都是对象，都占用了内存空间，合理使用<code>@staticmethod</code>和<code>@classmethod</code>修饰符，就可以不经过实例化直接使用类的方法了。</li></ul><blockquote><p>引用文章：</p><ol><li><a href="https://blog.csdn.net/sinat_34079973/article/details/53502348" target="_blank" rel="noopener">Python @staticmethod@classmethod用法 - sinat_34079973的博客 - CSDN博客</a></li><li><a href="https://blog.csdn.net/handsomekang/article/details/9615239" target="_blank" rel="noopener">飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客</a></li><li><a href="https://www.jianshu.com/p/eea864224e2d" target="_blank" rel="noopener">classmethod的两个实用用法 - 简书</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python中-staticmethod和-classmethod的用法&quot;&gt;&lt;a href=&quot;#Python中-staticmethod和-classmethod的用法&quot; class=&quot;headerlink&quot; title=&quot;Python中@staticmethod和@classmethod的用法&quot;&gt;&lt;/a&gt;Python中@staticmethod和@classmethod的用法&lt;/h1&gt;&lt;p&gt;一般来说，调用某个类的方法，需要预先生成一个实例，再通过实例调用方法。Java中有静态方法，可以使用类直接进行调用。Python中提供了两个修饰符&lt;code&gt;@staticmethod&lt;/code&gt;和&lt;code&gt;@classmethod&lt;/code&gt;以达到类似效果，使用它们就可以不需要实例化，直接&lt;strong&gt;类名.方法名()&lt;/strong&gt;来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类中，同时有利于命名空间的整洁。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中super()函数的用法及其说明</title>
    <link href="https://rilzob.com/2018/10/26/Python%E4%B8%ADsuper()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/26/Python中super()函数的用法的副本/</id>
    <published>2018-10-26T14:33:09.515Z</published>
    <updated>2018-11-07T06:54:42.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中super-函数的用法及其说明"><a href="#Python中super-函数的用法及其说明" class="headerlink" title="Python中super()函数的用法及其说明"></a>Python中super()函数的用法及其说明</h1><p>为了调用父类(超类)的一个方法，可以使用<code>super()</code>函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.spam'</span>)</span><br><span class="line">        super().spam()  <span class="comment"># Call parent spam()</span></span><br></pre></td></tr></table></figure><p><strong><code>super()</code>函数的一个常见用法是在<code>__init__()</code>中确保父类被正确的初始化</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.y = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>说明<code>__init__()</code>函数：定义类的时候，若是添加<code>__init__()</code>函数，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初始化。</em></p><p><strong><code>super()</code>的另外一个常见用法出现在覆盖Python特殊方法的代码中</strong>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self._obj = obj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delegate attribute lookup to internal obj</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._obj, name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delegate attribute assignment</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__setattr__(name, value) <span class="comment"># Call original __setattr__</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            setattr(self._obj, name, value)</span><br></pre></td></tr></table></figure><p>实际上，大家对于在Python中如何正确使用<code>super()</code>函数普遍知之甚少。你有时候会看到像下面这样直接调用父类的一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br></pre></td></tr></table></figure><p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。比如，考虑下面的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br></pre></td></tr></table></figure><p>运行这段代码后就会发现<code>Base.__init__</code>被调用两次，如图所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">A.__init__</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">C.__init__</span><br></pre></td></tr></table></figure><p>可能两次调用<code>Base.__init__()</code>没什么坏处，但有时候却不是。另一方面，假设在代码中换成使用<code>super()</code>，结果就很完美了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()  <span class="comment"># Only one call to super() here</span></span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br></pre></td></tr></table></figure><p>运行这个新版本后，你会发现<code>Base.__init__()</code>方法只会被调用一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">A.__init__</span><br><span class="line">C.__init__</span><br></pre></td></tr></table></figure><p>所以说，<code>super()</code>是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序(MRO)、重复调用(钻石继承)等种种问题。</p><p><em>说明：MRO就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表，下面会有更详尽的介绍。</em></p><p>为了弄清它的原理，我们需要花点时间解释下Python是如何实现继承的。对于你定义的每一个类，Python会计算出一个所谓的<strong>方法解析顺序(MRO)列表</strong>。这个MRO列表就是一个简单的所有基类的线性顺序表。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.__mro__</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,</span><br><span class="line">&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p>为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p><p>而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：</p><ul><li>子类会先于父类被检查</li><li>多个父类会根据它们在列表中的顺序被检查</li><li>如果对下一个类存在两个合法的选择，选择第一个父类</li></ul><p>老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。</p><p>当你使用<code>super()</code>函数时，Python会在MRO列表上继续搜索下一个类。只要每个重定义的方法统一使用<code>super()</code>并只调用它一次，那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。这也是为什么在第二个例子中你不会调用两次<code>Base.__init__()</code>的原因。</p><p><code>super()</code>有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line">        super().spam()</span><br></pre></td></tr></table></figure><p>如果你试着直接使用这个类就会出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.spam()</span><br><span class="line">A.spam</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> spam</span><br><span class="line">AttributeError: <span class="string">'super'</span> object has no attribute <span class="string">'spam'</span></span><br></pre></td></tr></table></figure><p>但是，如果你使用多继承的话看看会发生什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'B.spam'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.spam()</span><br><span class="line">A.spam</span><br><span class="line">B.spam</span><br></pre></td></tr></table></figure><p>你可以看到在类A中使用<code>super().spam()</code>实际上调用的是与类A毫无关系的类B中的<code>spam()</code>方法。这个用类C的MRO列表就可以完全解释清楚：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.__mro__</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">object</span>'&gt;)</span></span><br></pre></td></tr></table></figure><p>在定义混入类的时候这样使用<code>super()</code>是很普遍的。</p><p>然而，由于<code>super()</code>可能会调用不是你想要的方法，你应该遵循一些通用原则。首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。这样可以确保<code>super()</code>调用一个非直接父类方法时不会出错。其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。</p><p>在Python社区内对于<code>super()</code>的使用有时候会引来一些争议。尽管如此，如果一切顺利的话，你应该在你最新的代码中使用它。Raymond Hettinger为此写了一篇非常好的文章，有兴趣的话可以去查查看，文章通过大量的例子向我们解释了为什么<code>super()</code>是极好的。</p><p>最后通过一个很好的实例帮助大家加深一下记忆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooParent</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.parent = <span class="string">'I\'m the parent.'</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Parent'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self,message)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"%s from Parent"</span> % message)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(FooParent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类B的对象 FooChild 转换为类 FooParent 的对象</span></span><br><span class="line">        super(FooChild,self).__init__()    </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Child'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self,message)</span>:</span></span><br><span class="line">        super(FooChild, self).bar(message)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Child bar fuction'</span>)</span><br><span class="line">        <span class="keyword">print</span> (self.parent)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fooChild = FooChild()</span><br><span class="line">    fooChild.bar(<span class="string">'HelloWorld'</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">HelloWorld from Parent</span><br><span class="line">Child bar fuction</span><br><span class="line">I&apos;m the parent.</span><br></pre></td></tr></table></figure><blockquote><p>引用文章：</p><ol><li><a href="http://www.runoob.com/python/python-func-super.html" target="_blank" rel="noopener">Python super() 函数 | 菜鸟教程</a></li><li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html" target="_blank" rel="noopener">8.7 调用父类方法 — python3-cookbook 3.0.0 文档</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中super-函数的用法及其说明&quot;&gt;&lt;a href=&quot;#Python中super-函数的用法及其说明&quot; class=&quot;headerlink&quot; title=&quot;Python中super()函数的用法及其说明&quot;&gt;&lt;/a&gt;Python中super()函数的用法
      
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo使用攻略：添加搜索功能</title>
    <link href="https://rilzob.com/2018/10/26/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/26/Hexo使用攻略：添加搜索功能的副本/</id>
    <published>2018-10-26T02:04:21.695Z</published>
    <updated>2018-10-26T02:07:15.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用攻略：添加搜索功能"><a href="#Hexo使用攻略：添加搜索功能" class="headerlink" title="Hexo使用攻略：添加搜索功能"></a>Hexo使用攻略：添加搜索功能</h1><p>本教程针对的是Mac环境</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当博文越来越多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博文上去了，所以添加一个站内搜索功能是很有必要的。</p><p>Hexo适配多款搜索插件，个人感觉”Local Search”已满足日常需要，所以下面介绍为Hexo添加”Local Search”搜索插件的过程。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在命令行中<code>cd</code>到自己的hexo文件夹下(例：<code>/Users/rilzob/hexo</code>)，执行<code>npm install hexo-generator-searchdb --save</code>命令进行安装，等待安装完成。</p><h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>修改当前目录下的<strong>_config.yml</strong>文件(例：<code>/Users/rilzob/hexo/_config.yml</code>)，新增以下内容到该文件内的任意位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Search</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p><em>注意：每个冒号后面都有空格</em></p><h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>修改主题目录下的<strong>_config.yml</strong>文件(例：<code>/Users/rilzob/hexo/themes/xxx/_config.yml</code>)，找到该文件内的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure><p>代码段，将其修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>即将enable: false修改为enable: true。</p><h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>依旧在命令行中进行操作，在hexo文件夹下依次执行<code>hexo g</code>,<code>hexo server</code>和<code>hexo deploy</code>指令即可。这样搜索功能就添加成功了。</p><blockquote><p>引用文章:</p><p>1.<a href="https://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/" target="_blank" rel="noopener">Hexo博客添加搜索功能 | IT范儿</a></p><p>2.<a href="https://blog.csdn.net/qq_40265501/article/details/80030627" target="_blank" rel="noopener">hexo博客添加搜索功能 - qq_40265501的博客 - CSDN博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo使用攻略：添加搜索功能&quot;&gt;&lt;a href=&quot;#Hexo使用攻略：添加搜索功能&quot; class=&quot;headerlink&quot; title=&quot;Hexo使用攻略：添加搜索功能&quot;&gt;&lt;/a&gt;Hexo使用攻略：添加搜索功能&lt;/h1&gt;&lt;p&gt;本教程针对的是Mac环境&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Hexo" scheme="https://rilzob.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo使用攻略：添加分类及标签</title>
    <link href="https://rilzob.com/2018/10/25/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/25/Hexo使用攻略：添加分类及标签的副本/</id>
    <published>2018-10-25T13:28:41.587Z</published>
    <updated>2018-10-26T01:16:40.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用攻略：添加分类及标签"><a href="#Hexo使用攻略：添加分类及标签" class="headerlink" title="Hexo使用攻略：添加分类及标签"></a>Hexo使用攻略：添加分类及标签</h1><p>本教程针对的是Mac环境</p><h2 id="Hexo创建”分类”选项"><a href="#Hexo创建”分类”选项" class="headerlink" title="Hexo创建”分类”选项"></a>Hexo创建”分类”选项</h2><h3 id="生成”分类”页并添加type属性"><a href="#生成”分类”页并添加type属性" class="headerlink" title="生成”分类”页并添加type属性"></a>生成”分类”页并添加type属性</h3><ol><li><p>打开命令行，<code>cd</code>进入博客所在文件夹。执行命令<code>hexo new page categories</code>，来新建一个页面，并命名为categories。成功后会提示：<code>INFO  Created: ~/hexo/source/categories/index.md</code></p></li><li><p>根据上面的路径找到<strong>index.md</strong>这个文件，打开后默认内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-10-25 20:11:37</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>编辑新创建的页面，添加<code>type: &quot;categories&quot;</code>到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-10-25 20:11:37</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p></li></ol><h3 id="给文章添加”categories”属性"><a href="#给文章添加”categories”属性" class="headerlink" title="给文章添加”categories”属性"></a>给文章添加”categories”属性</h3><ol><li><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: Python</code>表示添加这篇文章到“Python”这个分类中。</p><p>注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Python中*args和**kwargs的用法总结</span><br><span class="line">categories: Python</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>回到hexo文件夹下，依次执行<code>hexo g</code>，<code>hexo server</code>和<code>hexo deploy</code>命令(重新部署)。</p></li></ol><h3 id="在Hexo菜单上添加分类选项"><a href="#在Hexo菜单上添加分类选项" class="headerlink" title="在Hexo菜单上添加分类选项"></a>在Hexo菜单上添加分类选项</h3><ol><li><p><code>cd</code>进<code>/hexo/themes/hexo-theme-next-5.1.4</code>文件夹内，编辑该目录下的<strong>_config.yml</strong>文件(把链接加上)，将源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>即将menu中的<code>categories:/categories || th</code>的注释去掉，然后保存并退出。</p></li><li><p>回到<code>hexo</code>文件夹下，依次执行<code>hexo g</code>，<code>hexo server</code>和<code>hexo deploy</code>命令，即可看到菜单栏中新增了一个Categories选项。</p></li></ol><p>   至此，成功给文章添加分类，点击Index上的Categories可以看到所有的分类情况，再点击该分类就可以看到该分类下的所有文章。当然，前提是添加了categories: xxx字段。</p><h2 id="Hexo创建”标签”选项"><a href="#Hexo创建”标签”选项" class="headerlink" title="Hexo创建”标签”选项"></a>Hexo创建”标签”选项</h2><h3 id="生成”标签”页并添加type属性"><a href="#生成”标签”页并添加type属性" class="headerlink" title="生成”标签”页并添加type属性"></a>生成”标签”页并添加type属性</h3><ol><li><p>打开命令行，<code>cd</code>进入博客所在文件夹。执行命令<code>hexo new page tags</code>，来新建一个页面，并命名为tags。成功后会提示：<code>INFO  Created: ~/hexo/source/tags/index.md</code></p></li><li><p>根据上面的路径找到<strong>index.md</strong>这个文件，打开后默认内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-25 21:11:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>编辑新创建的页面，添加<code>type: &quot;tags&quot;</code>到内容中，主题将自动为这个页面显示所有分类，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-25 21:11:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p></li></ol><h3 id="给文章添加”tags”属性"><a href="#给文章添加”tags”属性" class="headerlink" title="给文章添加”tags”属性"></a>给文章添加”tags”属性</h3><ol><li><p>打开需要添加标签的文章，为其添加tags属性。下方的<code>tags: Django</code>表示添加这篇文章到“Django”这个标签中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Python中*args和**kwargs的用法总结</span><br><span class="line">tags: Django</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>回到hexo文件夹下，依次执行<code>hexo g</code>， <code>hexo server</code>和<code>hexo deploy</code>命令(重新部署)。</p></li></ol><h3 id="在Hexo菜单上添加标签选项"><a href="#在Hexo菜单上添加标签选项" class="headerlink" title="在Hexo菜单上添加标签选项"></a>在Hexo菜单上添加标签选项</h3><ol><li><p><code>cd</code>进<code>/hexo/themes/hexo-theme-next-5.1.4</code>文件夹内，编辑该目录下的<strong>_config.yml</strong>文件(把链接加上)，将源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>即将menu中的<code>tags: /tags/ || tags</code>的注释去掉，然后保存并退出。</p></li><li><p>回到<code>hexo</code>文件夹下，依次执行<code>hexo g</code>，<code>hexo server</code>和<code>hexo deploy</code>命令，即可看到菜单栏中新增了一个tags选项。</p></li></ol><blockquote><p>引用文章：</p><p>1.<a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">Hexo使用攻略-添加分类及标签 | linlif-blog</a></p><p>2.<a href="https://segmentfault.com/q/1010000000618915" target="_blank" rel="noopener">hexo怎么在菜单上添加页面和分类呢？ - SegmentFault 思否</a></p><p>3.<a href="https://whx4j8.github.io/2016/03/16/hexo-next-%E6%B7%BB%E5%8A%A0%E4%B8%BA%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">hexo next 为文章添加分类 | 学而后知不足</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo使用攻略：添加分类及标签&quot;&gt;&lt;a href=&quot;#Hexo使用攻略：添加分类及标签&quot; class=&quot;headerlink&quot; title=&quot;Hexo使用攻略：添加分类及标签&quot;&gt;&lt;/a&gt;Hexo使用攻略：添加分类及标签&lt;/h1&gt;&lt;p&gt;本教程针对的是Mac环境&lt;/
      
    
    </summary>
    
      <category term="Hexo" scheme="https://rilzob.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中*args和**kwargs的用法总结</title>
    <link href="https://rilzob.com/2018/10/25/Python%E4%B8%AD*args%E5%92%8C**kwargs%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>https://rilzob.com/2018/10/25/Python中*args和**kwargs的用法总结的副本/</id>
    <published>2018-10-25T11:29:45.812Z</published>
    <updated>2018-10-25T12:24:56.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中-args和-kwargs的用法总结"><a href="#Python中-args和-kwargs的用法总结" class="headerlink" title="Python中*args和**kwargs的用法总结"></a>Python中*args和**kwargs的用法总结</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>Python支持可变参数，最简单的方法莫过于使用默认参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_defargs</span><span class="params">(one, two=<span class="number">2</span>)</span>:</span> <span class="comment"># 参数one没有默认值，two的默认值为2</span></span><br><span class="line">    print(<span class="string">'Required argument:'</span>, one)</span><br><span class="line">    print(<span class="string">'Optional argument:'</span>, two)</span><br><span class="line">    </span><br><span class="line">test_defargs(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Required argument: 1</span></span><br><span class="line"><span class="string">Optional argument: 2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">test_defargs(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Required argument: 1</span></span><br><span class="line"><span class="string">Optional argument: 3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>另一种达到可变参数(Variable Argument)的方法：</p><p>使用<code>*args</code>和<code>**kwargs</code>语法。</p><p><code>*args</code>是可变的<strong>位置参数(postional arguments)</strong>列表；</p><p><code>**kwargs</code>是可变的<strong>关键词参数(keyword arguments)</strong>列表；</p><p>并且<u>规定位置参数必须位于关键词参数之前，即<code>*args</code>必须位于<code>**kwargs</code>之前</u>。</p><h2 id="二、位置参数"><a href="#二、位置参数" class="headerlink" title="二、位置参数"></a>二、位置参数</h2><p>以下是用位置参数正确调用函数的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">(name, sex)</span>:</span></span><br><span class="line">sex_dict = &#123;<span class="number">1</span>: <span class="string">'先生'</span>, <span class="number">2</span>: <span class="string">'女士'</span>&#125;</span><br><span class="line">    print(<span class="string">'Hello %s %s, welcome to Python World!'</span> % (name, sex_dict.get(sex, <span class="string">'先生'</span>))) <span class="comment"># if no such a key, print '先生'</span></span><br><span class="line">    </span><br><span class="line">print_hello(<span class="string">'Chen'</span>, <span class="number">2</span>) <span class="comment"># 位置参数要求先后顺序，对应name和sex</span></span><br><span class="line">print_hello(<span class="string">'Chen'</span>, <span class="number">3</span>) <span class="comment"># 两个参数的顺序必须一一对应，且少一个参数都不可以</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Hello Chen 女士, welcome to Python World!</span></span><br><span class="line"><span class="string">Hello Chen 先生, welcome to Python World!</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="三、关键字参数"><a href="#三、关键字参数" class="headerlink" title="三、关键字参数"></a>三、关键字参数</h2><p>用于函数调用，通过“键-值”形式加以指定。</p><p>使用关键字参数可以让函数更加清晰，容易使用，同时也清除了参数的顺序需求。</p><p>以下是用关键字参数正确调用函数的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print_hello(<span class="string">'Chen'</span>, sex=<span class="number">1</span>) <span class="comment"># 有位置参数时，位置参数必须在关键字参数的前面</span></span><br><span class="line"><span class="comment"># print_hello(1, name='Chen') # Python 3.x中这种写法是错误的</span></span><br><span class="line">print_hello(name=<span class="string">'Chen'</span>, sex=<span class="number">1</span>) <span class="comment"># 关键字参数之间不存在先后顺序的,等价于print_hello(sex=1, name='Chen')</span></span><br></pre></td></tr></table></figure><p>以下是错误的调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print_hello(name='Chen', 1) # 有位置参数时，位置参数必须在关键字参数前面</span></span><br><span class="line"><span class="comment"># print_hello(sex=1, 'Chen')</span></span><br></pre></td></tr></table></figure><h2 id="四、可变参数"><a href="#四、可变参数" class="headerlink" title="四、可变参数"></a>四、可变参数</h2><p>顾名思义，可变参数就是传入的参数个数是可变的，可以是任意个。<code>*args</code>和<code>**kwargs</code>两者都是Python中的可变参数。</p><h4 id="1-可变位置参数-args"><a href="#1-可变位置参数-args" class="headerlink" title="1.可变位置参数*args"></a>1.可变位置参数<code>*args</code></h4><p>Python中规定参数前带<code>*</code>的，称为<strong>可变位置参数</strong>，只是我们通常称这个可变位置参数为<code>*args</code>而已，叫其他的也是一样的。</p><p>以数学题为例，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。</p><p>要定义这个函数，必须确定输入的参数。由于参数个数不确定，我们可以首先想到把a，b，c……作为一个list或者tuple传进来，这样函数就可以定义为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure><p>所以，为了方便起见我们把函数的参数改为可变位置函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span> # 可变位置参数</span></span><br><span class="line">sum = 0</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>定义可变位置参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;calc(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;calc()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果已经有一个list或tuple，要调用一个可变位置参数怎么办？可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>这种做法当然是可行的，问题是太繁琐了，所以Python允许在list或tuple前面加一个<code>*</code>，把list或tuple的元素变成可变位置参数传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>总而言之，<code>*args</code>用来表示函数接收可变长度的非关键字参数列表作为函数的输入。我们可以通过以下这个例子进一步理解<code>*args</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args</span><span class="params">(normal_arg, *args)</span>:</span></span><br><span class="line">print(<span class="string">'first normal arg:'</span> + normal_arg)</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(<span class="string">'another arg through *args:'</span> + arg)</span><br><span class="line">    </span><br><span class="line">test_args(<span class="string">"normal"</span>, <span class="string">"python"</span>, <span class="string">"java"</span>, <span class="string">"C#"</span>)</span><br></pre></td></tr></table></figure><p>上面代码的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first normal arg: normal</span><br><span class="line">another arg through *args : python</span><br><span class="line">another arg through *args : java</span><br><span class="line">another arg through *args :C#</span><br></pre></td></tr></table></figure><h4 id="2-可变关键字参数-kwargs"><a href="#2-可变关键字参数-kwargs" class="headerlink" title="2.可变关键字参数**kwargs"></a>2.可变关键字参数<code>**kwargs</code></h4><p>同理，Python中规定参数前带<code><strong> </strong></code>的，称为可变关键字参数<strong>，通常用<code></code></strong>kwargs表示。</p><p><code>**kwargs</code>表示函数接收可变长度的关键字参数字典作为函数的输入。当我们需要函数接收带关键字的参数作为输入的时候，应当使用<code>**kwargs</code>。我们可以通过以下的例子进一步理解<code>**kwargs</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_kwargs</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.iteritems():</span><br><span class="line">            print(<span class="string">"&#123;&#125; = &#123;&#125;"</span>.format(key,value))</span><br><span class="line">        <span class="comment"># Or you can visit kwargs like a dict() object</span></span><br><span class="line">        <span class="comment"># for key in kwargs:</span></span><br><span class="line">        <span class="comment">#    print("&#123;&#125; = &#123;&#125;".format(key, kwargs[key]))</span></span><br><span class="line">        </span><br><span class="line">test_kwargs(name=<span class="string">"python"</span>, value=<span class="string">"5"</span>)</span><br></pre></td></tr></table></figure><p>以上代码的执行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = python</span><br><span class="line">value = 5</span><br></pre></td></tr></table></figure><p>以上例子只是<code>*args</code>和<code>**kwargs</code>基本使用的例子。下面再给出一个用<code>*args</code>和<code>**kwargs</code>来定义能够接受列表输入和字典输入的函数的例子。</p><h4 id="3-使用-args和-kwargs来调用函数"><a href="#3-使用-args和-kwargs来调用函数" class="headerlink" title="3.使用*args和**kwargs来调用函数"></a>3.使用<code>*args</code>和<code>**kwargs</code>来调用函数</h4><p>比如我们有如下接受普通输入参数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_func</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">"arg1: "</span> + arg1)</span><br><span class="line">    print(<span class="string">"arg2: "</span> + arg2)</span><br><span class="line">    print(<span class="string">"arg3: "</span> + arg3)</span><br><span class="line"></span><br><span class="line">normal_func(<span class="string">"python"</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>使用<code>*args</code>和<code>**kwargs</code>来调用这个函数的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用*args</span></span><br><span class="line">args_list = (<span class="string">"python"</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">normal_func(*args_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用**kwargs</span></span><br><span class="line">kwargs_dict = &#123;<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg1"</span>: <span class="string">"python"</span>, <span class="string">"arg2"</span>: <span class="number">1</span>&#125;</span><br><span class="line">normal_func(**kwargs_dict)</span><br></pre></td></tr></table></figure><p>以上三段代码的输出均为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arg1: python</span><br><span class="line">arg2: 1</span><br><span class="line">arg3: 3</span><br></pre></td></tr></table></figure><blockquote><p>引用文章：</p><p>1.<a href="https://www.jianshu.com/p/61507f60fa29" target="_blank" rel="noopener">Python中的 *args 和 **kwargs - 简书</a></p><p>2.<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="noopener">函数的参数 - 廖雪峰的官方网站</a></p><p>3.<a href="https://www.jianshu.com/p/be92113116c8" target="_blank" rel="noopener">python参数传递的*args和**kwargs - 简书</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python中-args和-kwargs的用法总结&quot;&gt;&lt;a href=&quot;#Python中-args和-kwargs的用法总结&quot; class=&quot;headerlink&quot; title=&quot;Python中*args和**kwargs的用法总结&quot;&gt;&lt;/a&gt;Python中*ar
      
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>通过Hexo将文章上传到git.io的方法</title>
    <link href="https://rilzob.com/2018/10/21/%E9%80%9A%E8%BF%87Hexo%E5%B0%86%E6%96%87%E7%AB%A0%E4%B8%8A%E4%BC%A0%E5%88%B0git.io%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://rilzob.com/2018/10/21/通过Hexo将文章上传到git.io的方法/</id>
    <published>2018-10-21T01:59:43.963Z</published>
    <updated>2018-10-25T12:29:05.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过Hexo将文章上传到git-io的方法"><a href="#通过Hexo将文章上传到git-io的方法" class="headerlink" title="通过Hexo将文章上传到git.io的方法"></a>通过Hexo将文章上传到git.io的方法</h1><ol><li><p>编辑文章，生成markdown文件，并将文章放到<code>/hexo/source/_posts</code>目录下，一个md文件对应一篇博客文章。</p></li><li><p>修改文章头部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: #博客标题</span><br><span class="line">date: #博客发布时间</span><br><span class="line">tags: #博客分类标签</span><br><span class="line">categories: #博客目录</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在命令行中cd到_posts目录下并执行<code>hexo generate</code>命令(生成静态页面)。</p></li><li><p>再执行<code>hexo server</code>命令(本地上传文章)，上传后可以到<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 预览博客效果。</p></li><li><p>最后执行<code>hexo deploy</code>命令，上传文章到github.io上就完成了。</p></li></ol><p>其他Hexo命令：</p><ul><li>hexo clean（清空资源文件，可选操作）</li><li>hexo g （重新生成资源文件）</li></ul><blockquote><p>引用文章:  </p><p>1.<a href="https://blog.csdn.net/u010504064/article/details/78460652" target="_blank" rel="noopener">Hexo 发布文章到git.io步骤 - 程序男的专栏 - CSDN博客</a></p><p>2.<a href="https://blog.csdn.net/wl67920126/article/details/80718362" target="_blank" rel="noopener">hexo发布文章到个人博客上 - wl67920126的博客 - CSDN博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过Hexo将文章上传到git-io的方法&quot;&gt;&lt;a href=&quot;#通过Hexo将文章上传到git-io的方法&quot; class=&quot;headerlink&quot; title=&quot;通过Hexo将文章上传到git.io的方法&quot;&gt;&lt;/a&gt;通过Hexo将文章上传到git.io的方法&lt;/
      
    
    </summary>
    
      <category term="Hexo" scheme="https://rilzob.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Django中path和url的区别</title>
    <link href="https://rilzob.com/2018/10/21/Django%E4%B8%ADpath%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://rilzob.com/2018/10/21/Django中path和url的区别/</id>
    <published>2018-10-21T01:00:29.809Z</published>
    <updated>2018-10-25T13:20:38.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django中path和url的区别"><a href="#Django中path和url的区别" class="headerlink" title="Django中path和url的区别"></a>Django中path和url的区别</h1><p>django中url和path都是配置路径，有什么不同？</p><p>from django.urls import path</p><p>from django.conf.urls import url</p><p>path和url是两个不同的模块，效果都是响应返回界面，path调用的是python第三方模块或框架，而url则是自定义的模块。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^login'</span>, views.login)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>引用自：<a href="https://blog.csdn.net/qq_26079279/article/details/80143365" target="_blank" rel="noopener">Django中path和url的用法总结</a></p></blockquote><p>当然，主要问题在于版本，1.x版本用url，2.x版本用path。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django中path和url的区别&quot;&gt;&lt;a href=&quot;#Django中path和url的区别&quot; class=&quot;headerlink&quot; title=&quot;Django中path和url的区别&quot;&gt;&lt;/a&gt;Django中path和url的区别&lt;/h1&gt;&lt;p&gt;django
      
    
    </summary>
    
      <category term="Python" scheme="https://rilzob.com/categories/Python/"/>
    
    
      <category term="Django" scheme="https://rilzob.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>介绍</title>
    <link href="https://rilzob.com/2018/04/25/%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rilzob.com/2018/04/25/介绍/</id>
    <published>2018-04-25T11:47:48.000Z</published>
    <updated>2018-04-25T11:56:34.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rilzob的个人blog"><a href="#Rilzob的个人blog" class="headerlink" title="Rilzob的个人blog"></a>Rilzob的个人blog</h1><p>随便写，随便看</p><h3 id="邮箱："><a href="#邮箱：" class="headerlink" title="邮箱："></a>邮箱：</h3><p><strong> <a href="mailto:watermirrosir@163.com" target="_blank" rel="noopener">watermirrosir@163.com</a> </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rilzob的个人blog&quot;&gt;&lt;a href=&quot;#Rilzob的个人blog&quot; class=&quot;headerlink&quot; title=&quot;Rilzob的个人blog&quot;&gt;&lt;/a&gt;Rilzob的个人blog&lt;/h1&gt;&lt;p&gt;随便写，随便看&lt;/p&gt;
&lt;h3 id=&quot;邮箱：&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
