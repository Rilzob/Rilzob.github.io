<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="读书笔记,C/C++," />





  <link rel="alternate" href="/atom.xml" title="极氙世界" type="application/atom+xml" />






<meta name="description" content="本章的讲解围绕向量结构的高效实现而逐步展开，包括其作为抽象数据类型的接口规范以及对应的算法，尤其是高效维护动态向量的技巧。此外，还针对有序向量，系统介绍经典的查找与排序算法，并就其性能做一分析对比，这也是本章的难点与重点所在。最后，还引入复杂度下界的概念，并通过建立比较树模型，针对基于比较式算法给出复杂度下界的统一界定方法。">
<meta name="keywords" content="读书笔记,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 向量">
<meta property="og:url" content="https://rilzob.com/2019/03/24/数据结构第二章 向量/index.html">
<meta property="og:site_name" content="极氙世界">
<meta property="og:description" content="本章的讲解围绕向量结构的高效实现而逐步展开，包括其作为抽象数据类型的接口规范以及对应的算法，尤其是高效维护动态向量的技巧。此外，还针对有序向量，系统介绍经典的查找与排序算法，并就其性能做一分析对比，这也是本章的难点与重点所在。最后，还引入复杂度下界的概念，并通过建立比较树模型，针对基于比较式算法给出复杂度下界的统一界定方法。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-28T15:10:30.488Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第二章 向量">
<meta name="twitter:description" content="本章的讲解围绕向量结构的高效实现而逐步展开，包括其作为抽象数据类型的接口规范以及对应的算法，尤其是高效维护动态向量的技巧。此外，还针对有序向量，系统介绍经典的查找与排序算法，并就其性能做一分析对比，这也是本章的难点与重点所在。最后，还引入复杂度下界的概念，并通过建立比较树模型，针对基于比较式算法给出复杂度下界的统一界定方法。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rilzob.com/2019/03/24/数据结构第二章 向量/"/>





  <title>第二章 向量 | 极氙世界</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/Rilzob" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">极氙世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">追求梦想，永不止步</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rilzob.com/2019/03/24/数据结构第二章 向量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rilzob">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="极氙世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第二章 向量</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-24T09:54:35+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机科学与技术/" itemprop="url" rel="index">
                    <span itemprop="name">计算机科学与技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机科学与技术/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>  本章的讲解围绕向量结构的高效实现而逐步展开，包括其作为抽象数据类型的接口规范以及对应的算法，尤其是高效维护动态向量的技巧。此外，还针对有序向量，系统介绍经典的查找与排序算法，并就其性能做一分析对比，这也是本章的难点与重点所在。最后，还引入复杂度下界的概念，并通过建立比较树模型，针对基于比较式算法给出复杂度下界的统一界定方法。<br><a id="more"></a></p>
<ul>
<li>数据结构是数据项的结构化集合。数据结构划分为<strong>线性结构、半线性结构和非线性结构</strong>三大类。</li>
<li>最为基本的线性结构统称为<strong>序列(sequence)</strong>，根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可进一步地将序列分为<strong>向量(Vector)</strong>和<strong>列表(List)</strong>。</li>
<li>在向量中，所有数据项的物理存放位置与其逻辑次序完全吻合，此时的逻辑次序也称作<strong>秩(Rank)</strong>。而在列表中，逻辑上相邻的数据项在物理上未必相邻，而是采用间接定址的方式通过封装后的位置(position)相互引用。</li>
</ul>
<h1 id="从数组到向量"><a href="#从数组到向量" class="headerlink" title="从数组到向量"></a>从数组到向量</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>具体地，数组A[]中的每一个元素都唯一对应于某一下标编号，记作A[0,n) = {A[0], A[1], .., A[n-1]}。其中，对于任何 0 ≤ i &lt; j &lt; n，A[i]都是A[j]的<strong>前驱(predecessor)</strong>，A[j]都是A[i]的<strong>后继(successor)</strong>。特别地，对于任何i ≥ 1，A[i-1]称作A[i]的<strong>直接前驱(immediate predecessor)</strong>；对于任何i ≤ n - 2，A[i+1]称作A[i]的<strong>直接后继(immediate successor)</strong>。任一元素的所有前驱构成其<strong>前缀(prefix)</strong>，所有后继构成其<strong>后缀(suffix)</strong>。 </li>
<li>具体地，若数组A[]存放空间的起始位置为A，且每个元素占用s个单位的空间，则元素A[i]对应的物理地址为：<strong>A + i * s</strong>，因其中元素的物理地址与其下标之间满足这种线性关系，故亦称作<strong>线性数组(linear array)</strong>。</li>
</ul>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><ul>
<li>以此前介绍的线性递归为例，运行过程中所出现过的所有递归实例，按照相互调用的关系可构成一个线性序列。在此序列中，各递归实例的秩反映了它们各自被创建的时间先后，每一递归实例的秩等于早于它出现的实例总数。反过来，通过r亦可唯一确定$e = v_r$。这是向量特有的元素访问方式，称作<strong>循秩访问(call-by-rank)</strong>。</li>
<li>向量的特点：不限定同一向量中的各元素都属于同一基本类型，它们本身可以是来自于更具一般性的某一类的对象。另外，各元素也不见得同时具有某一数值属性，故而并不保证它们之间能够相互比较大小。</li>
</ul>
<h1 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h1><p>  向量结构在内部维护一个元素类型为<code>T</code>的私有数组<code>_elem[]</code>：其容量由私有变量<code>_capacity</code>指示；有效元素的数量(即向量当前的实际规模)，则有<code>_size</code>指示。此外还进一步地约定，在向量元素的秩、数组单元的逻辑编号以及物理地址之间，具有如下对应关系：<br><em>向量中秩为r的元素，对应于内部数组中的<code>_elem[r]</code>，其物理地址为<code>_elem+r</code></em></p>
<h2 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h2><p>  默认的构造方法是，首先根据创建者指定的初始容量，向系统申请空间，以创建内部私有数组<code>_elem[]</code>；若容量未明确指定，则使用默认值<code>DEFAULT_CAPACITY</code>。接下来，鉴于初生的向量尚不包含任何元素，故将指示规模的变量<code>_size</code>初始化为0。<br>整个过程顺序进行，没有任何迭代，故若忽略用于分配数组空间的时间，共需常数时间。</p>
<h2 id="基于复制的构造方法"><a href="#基于复制的构造方法" class="headerlink" title="基于复制的构造方法"></a>基于复制的构造方法</h2><p>  向量的另一典型创建方式，是以某个已有的向量或数组为蓝本，进行(局部或整体的)克隆。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector_constructor_by_copying.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 元素类型</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom(T <span class="keyword">const</span> *A, Rank lo, Rank hi) &#123; <span class="comment">// 以数组区间A[lo,hi)为蓝本复制向量</span></span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span> * (hi - lo) ]; _size = <span class="number">0</span>; <span class="comment">// 分配空间，规模清零</span></span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) <span class="comment">// A[lo, hi)内的元素逐一</span></span><br><span class="line">        _elem[_size++] = A[lo++]; <span class="comment">// 复制至_elem[0, hi-lo)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  <code>copyFrom()</code>首先根据待复制区间的边界，换算出新向量的初始规模；再以<strong>双倍</strong>的容量，为内部数组<code>_elem[]</code>申请空间。最后通过一趟迭代，完成区间<code>A[lo, hi)</code> <strong>(注意这里是左闭右开)</strong> 内各元素的顺次复制。<br>若忽略开辟新空间所需的时间，运行时间应正比于区间宽度，即$O(hi - lo) = O(size)$。</p>
<p>  需强调的是，由于向量内部含有动态分配的空间，默认的运算符”=”不足以支持向量之间的直接赋值(因为向量内存储数据的数据类型并非全是基本数据类型)。<br>为适应此类赋值操作的需求，重载向量的赋值运算符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector_assignment.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Vector&lt;T&gt;&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>=(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V) &#123; <span class="comment">// 重载</span></span><br><span class="line">    <span class="keyword">if</span> (_elem) <span class="keyword">delete</span> [] _elem; <span class="comment">// 释放原有内容</span></span><br><span class="line">    copyFrom(V.elem, <span class="number">0</span>, V.size()); <span class="comment">// 整体复制</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用，以便链式赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h2><p>与析构函数不同，同一对象只能有一个析构函数，不得重载。<br>向量对象的析构过程，只需释放用于存放元素的内部数组<code>_elem[]</code>，将其占用的空间交还操作系统。<code>_capacity</code>和<code>_size</code>之类的内部变量无需做任何处理，它们将作为向量对象自身的一部分被系统回收，此后既无需也无法被引用。<br>若不计系统用于空间回收的时间，整个析构过程只需O(1)时间。</p>
<h1 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h1><h2 id="静态空间管理"><a href="#静态空间管理" class="headerlink" title="静态空间管理"></a>静态空间管理</h2><ul>
<li>内部数组所占物理空间的容量，若在向量的生命期内不允许调整，则称作<strong>静态空间管理策略</strong>。</li>
<li>向量实际规模与其内部数组容量的比值(即_size/_capacity)，亦称作<strong>装填因子(load factor)</strong>。</li>
</ul>
<p><em>如何才能保证向量的装填因子既不致于超过1，也不致于太接近于0？</em><br>为此，需要改用动态空间管理策略。其中一种有效的方法，即使用所谓的可扩充向量。</p>
<h2 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h2><p>  <strong>可扩充向量(extendable vector)</strong> 的原理：若内部数组仍有空余，则操作可照常执行。每经一次插入(删除)，可用空间都会减少(增加)一个单元。一旦空间耗尽，就动态地扩大内部数组的容量。这里的难点及关键在于：<br><em>如何实现扩容？新的容量取作多少才算适宜？</em></p>
<p>  一种可行的方法，我们需要另行申请一个容量更大的数组B[]，并将原数组中的成员集体搬迁至新的空间，此后访客顺利地插入新元素e而不致溢出。当然，原数组所占的空间，需要及时释放并归还操作系统。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>基于以上策略的扩容算法<code>expand()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector_expand.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123; <span class="comment">// 向量空间不足时扩容</span></span><br><span class="line">    <span class="keyword">if</span>(_size &lt; _capacity) <span class="keyword">return</span>; <span class="comment">// 尚未满员时，不必扩容</span></span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; <span class="comment">// 不低于最小容量</span></span><br><span class="line">    T* oldElem = _elem; _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>]; <span class="comment">// 容量加倍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">        _elem[i] = oldElem[i]; <span class="comment">// 复制原向量内容(T为基本类型，或已重载赋值操作符'='）</span></span><br><span class="line">    <span class="keyword">delete</span> [] oldElem; <span class="comment">// 释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  请注意，新数组的地址由操作系统分配，与原数据区没有直接的关系。这种情况下，若直接饮用数组，往往会导致共同指向原数组的其他指针失效，称为野指针 <strong>(wild pointer)</strong>；而封装为向量后，即可继续准确地引用各元素，从而有效地避免野指针的风险。</p>
<p>  <strong>这里的关键在于，新数组的容量总是取作原数组的两倍</strong>————这正是上述后一问题的答案。取作二倍的目的是预留一些空间后，使得将来足够长的时间内，不会因为有必要扩容而打断我们的计算过程。下面介绍通过分摊分析对用于扩容的时间成本进行分析。</p>
<h2 id="分摊分析-amortized-analysis"><a href="#分摊分析-amortized-analysis" class="headerlink" title="分摊分析(amortized analysis)"></a>分摊分析(amortized analysis)</h2><h3 id="分摊复杂度"><a href="#分摊复杂度" class="headerlink" title="分摊复杂度"></a>分摊复杂度</h3><p>  对可扩充向量的足够多次连续操作，并将其间所消耗的时间，分摊至所有的操作。如此分摊平均至单词操作的时间成本，称作<strong>分摊运行时间(amortized running time)。</strong><br>  注意这一指标与<strong>平均运行时间(average running time)</strong> 有着本质的区别。后者是按照某种假定的概率分布，对各种情况下所需执行时间的加权平均，故亦称作期望运行时间(expected running time)。而前者则要求，参与分摊的操作必须构成和来自一个真实可行的操作序列，而且该序列还必须足够地长。<br>  相对而言，<u>分摊复杂度可以针对计算成本和效率，做出更为客观而准确的设计</u>(优点)。比如在这里，在任何一个可扩充向量的生命期内，在任何足够长的连续操作序列中，以任何固定间隔连续出现上述最坏情况的概率均为0，故常规的平均复杂度根本不具任何参考意义。</p>
<h3 id="O-1-分摊时间"><a href="#O-1-分摊时间" class="headerlink" title="O(1)分摊时间"></a>O(1)分摊时间</h3><p>  假定数组的初始容量为某一常数N。既然是估计复杂度的上界，故不妨设向量的初始规模也为N——即将溢出。另外不难看出，除插入操作外，向量其余的接口操作既不会直接导致溢出，也不会增加伺候溢出的可能性，因此不妨考察最坏的情况，假设在伺候需要连续地进行n次<code>insert()</code>操作，n &gt;&gt; N。首先定义如下函数：<br><em>size(n) = 连续插入n个元素后向量的规模</em><br><em>capacity(n) = 连续插入n个元素后数组的容量</em><br><em>T(n) = 为连续插入n个元素而花费于扩容的时间</em><br>  其中，向量规模从N开始随着操作的进程逐步递增，故有：$size(n) = N + n$<br>  既然不致溢出，故装填因子绝不会超出100%。同时，这里的扩容采用了“懒惰”策略——只有在的确即将发生溢出时，才不得不将容量加倍——因此装填因子也始终不低于50%。<br>概括起来，始终应有：<br>$size(n) ≤ capacity(n) ≤ 2 * size(n)$<br>考虑到N为常数，故有：<br>$capacity(n) = Θ(size(n)) = Θ(n)$<br>  容量以2为比例按指数速度增长，在容量达到capacity(n)之前，共做过$Θ(log_2n)$次扩容，每次扩容所需时间线性正比于当时的容量(或规模)，且同样以2为比例按指数速度增长。因此，消耗于扩容的时间累计不过：<br>$T(n) = 2N + 4N + 8N + … + capacity(n) &lt; 2 * capacity(n) = Θ(n)$<br>  将其分摊到其间的连续n次操作，单次操作所需的分摊运行时间应为$O(1)$。</p>
<h3 id="其它扩容策略"><a href="#其它扩容策略" class="headerlink" title="其它扩容策略"></a>其它扩容策略</h3><p>  早期可扩充向量多采用另一策略：一旦有必要，则追加固定数目的单元。实际上，无论采用的固定常数多大，在最坏情况下，此类数组单次操作的分摊时间复杂度都高达$Ω(n)$。</p>
<h2 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector_shrink.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::shrink() &#123; <span class="comment">// 装填因子过小时压缩向量所占空间</span></span><br><span class="line">    <span class="keyword">if</span>(_capacity &lt; DEFAULT_CAPACITY &lt;&lt; <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 不致收缩到DEFAULT_CAPACITY以下</span></span><br><span class="line">    <span class="keyword">if</span>(_size &lt;&lt; <span class="number">2</span> &gt; _capacity) <span class="keyword">return</span>; <span class="comment">// 以25%为界</span></span><br><span class="line">    T* oldElem = _elem; _elem = <span class="keyword">new</span> T[_capacity &gt;&gt;= <span class="number">1</span>]; <span class="comment">// 容量减半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        _elem[i] = oldElem[i]; <span class="comment">// 复制原向量内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] oldElem; <span class="comment">// 释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  与<code>expand()</code>操作类似，尽管单次<code>shrink()</code>操作需要线性量级$Ω(n)$的时间，但其分摊复杂度亦为$O(1)$。</p>
<h1 id="常规向量"><a href="#常规向量" class="headerlink" title="常规向量"></a>常规向量</h1><h2 id="直接引用元素"><a href="#直接引用元素" class="headerlink" title="直接引用元素"></a>直接引用元素</h2><p>  重载操作符”[]”，使向量ADT访问元素的方式与数组直接通过下标访问元素的方式(形如”A[i]”)相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector_bracket.h </span><br><span class="line">代码<span class="number">2.6</span> 重载向量操作符[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span> <span class="comment">// 重载下标操作符</span></span><br><span class="line">&#123; <span class="keyword">return</span> _elem[r];&#125; <span class="comment">// assert: 0 &lt;= r &lt; _size</span></span><br></pre></td></tr></table></figure></p>
<h2 id="置乱器"><a href="#置乱器" class="headerlink" title="置乱器"></a>置乱器</h2><h3 id="置乱算法"><a href="#置乱算法" class="headerlink" title="置乱算法"></a>置乱算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">permute.h</span><br><span class="line">代码<span class="number">2.7</span> 向量整体置乱算法permute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(Vector&lt;T&gt;&amp; V)</span></span>&#123; <span class="comment">//随机置乱向量，使各元素等概率出现在各位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = V.size(); i &gt; <span class="number">0</span>; i--) <span class="comment">// 自后向前</span></span><br><span class="line">        swap(V[i<span class="number">-1</span>], V[rand() % i]); <span class="comment">// V[i-1]与V[0,i)中某一随机元素交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  该算法从置乱区间的末元素开始，逆序地向前逐一处理各元素。对每一个当前元素V[i - 1]，先通过调用<code>rand()</code>函数在[0, i)之间等概率地随机选取一个元素，再令二者互换位置。注意，这里的交换操作<code>swap()</code>，隐含了三次基于重载操作符”[]”的赋值。<br>每经过一步这样的迭代，置乱区间都会向前拓展一个单元。因此经过O(n)步迭代后，即实现了整个向量的置乱。</p>
<p>  从理论上讲，使用这里的<code>permute()</code>算法，不仅可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率相等。</p>
<h3 id="区间置乱接口"><a href="#区间置乱接口" class="headerlink" title="区间置乱接口"></a>区间置乱接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector_unsort.h</span><br><span class="line">代码<span class="number">2.8</span> 向量区间置乱接口unsort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::unsort(Rank lo, Rank hi) &#123; <span class="comment">// 等概率随机置乱区间[lo,hi)</span></span><br><span class="line">    T* V = _elem + lo; <span class="comment">// 将子向量_elem[lo,hi)视作另一向量V[0,hi-lo)</span></span><br><span class="line">    <span class="keyword">for</span> (Rank i = hi - lo; i &gt; <span class="number">0</span> ; i--) &#123; <span class="comment">// 自后向前</span></span><br><span class="line">        swap(V[i<span class="number">-1</span>], V[rand() % i]); <span class="comment">// 将V[i-1]与V[0, i)中某一元素随机交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过该接口，可以均匀地置乱任一向量区间[lo, hi)内的元素，故通用性有所提高。可见，只要将该区间等效地视作另一向量V，即可从形式上完整地套用以上<code>permute()</code>算法的流程。<br>尽管如此，还要特别留意代码2.7和代码2.8之间的细微差异：后者是通过下标，直接访问内部数组的元素；而前者则是借助重载的操作符”[]”，通过秩间接地访问向量的元素。</p>
<h2 id="判等器与比较器"><a href="#判等器与比较器" class="headerlink" title="判等器与比较器"></a>判等器与比较器</h2><p>  从算法的角度来看，”判断两个对象是否相等”与”判断两个对象的相对大小”都是至关重要的操作，它们直接控制者算法执行的分支方向。这两种操作之间既有联系也有区别，不能相互替代。比如，有些对象只能比对但不能比较；反之，支持比较的对象未必支持比对。不过，出于简化的考虑，在很多场合并不需要严格地将二者区分开来。<br>  算法实现的简洁性和通用性，在很大程度上体现于：针对整数等特定数据类型的某种实现，可否推广至可比较或可比对的任何数据类型，而不必关心如何定义以及判定其大小或相等关系。若能如此，就可以将比对和比较操作的具体实现剥离出来，直接讨论算法流程本身。<br>  为此，通常可以采用两种方法。其一，将比对操作和比较操作分别分装成通用的判等器和比较器。其二，在定义对应的数据类型时，通过重载”&lt;”和”==”之类的操作符，给出大小和相等关系的具体定义及其判别方法。<br>  在一些复杂的数据结构中，内部元素本身的类型可能就是指向其它对象的指针；而从外部更多关注的，则往往是其所指对象的大小。若不加处理而直接根据指针的数值(即被指对象的物理地址)进行比较，则所得结果将毫无意义。</p>
<h2 id="无序查找"><a href="#无序查找" class="headerlink" title="无序查找"></a>无序查找</h2><h3 id="判等器"><a href="#判等器" class="headerlink" title="判等器"></a>判等器</h3><p>仅支持比对，但未必支持比较的向量，称作<strong>无序向量(unsorted vector)。</strong></p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>逐个比对的查找方式，称作<strong>顺序查找(sequential search)。</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector_find.h</span><br><span class="line">代码<span class="number">2.10</span> 无序向量元素查找接口find()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 无序向量的顺序查找：返回最后一个元素e的位置；失败时，返回lo - 1</span></span><br><span class="line">Rank Vector&lt;T&gt;::find(T <span class="keyword">const</span> &amp;e, Rank lo, Rank hi) <span class="keyword">const</span> &#123; <span class="comment">// assert: 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">    <span class="keyword">while</span> ((lo &lt; hi--) &amp;&amp; (e != _elem[hi])); <span class="comment">// 从后向前，顺序查找</span></span><br><span class="line">    <span class="keyword">return</span> hi; <span class="comment">// 若hi &lt; lo, 则意味着失败；否则hi即命中元素的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中若干细微之处，需要体会。比如，当同时多个命中元素时，本书统一约定返回其中秩最大者——故这里采用了<strong>自后向前</strong>的查找次序。如此，一旦命中即可立即返回，从而省略掉不必要的比对。另外，查找失败时约定统一返回-1。这不仅简化了对查找失败情况的判别，同时也使此时的返回结果更加易于理解——只要假想者在秩为-1处植入一个与任何对象对相等的哨兵元素，则返回该元素的秩当且仅当查找失败。<br>  最后一处需要留意。while循环的控制逻辑由两部分组成，首先判断是否已抵达通配符，再判断当前元素与目标元素是否相等。利用了C/C++语言中逻辑表达式的短路求值特性，在前一判断非真厚循环会立即终止，而不致因试图引用已越界的秩(-1)而出错。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>  最坏情况，查找终止于首元素<code>_elem[lo]</code>，运行时间为O(hi - lo) = O(n)。最好情况下，查找命中于末元素<code>_elem[hi - 1]</code>，仅需O(1)时间。对于规模相同、内部组成不同的输入，渐进运行时间却有本质区别，故此类算法也称作<strong>输入敏感的(input sensitive)</strong> 算法。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector_insert.h</span><br><span class="line">代码<span class="number">2.11</span> 向量元素插入接口insert()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 将e作为秩为r元素插入</span></span><br><span class="line">Rank Vector&lt;T&gt;::insert(Rank r, <span class="keyword">const</span> T &amp;e) &#123; <span class="comment">// assert: 0 &lt;= r &lt;= size</span></span><br><span class="line">    expand(); <span class="comment">// 若有必要，扩容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; r; i--) &#123;</span><br><span class="line">        _elem[i] = _elem[i<span class="number">-1</span>]; <span class="comment">// 自后向前，后继元素顺次后移一个单元</span></span><br><span class="line">    &#125;</span><br><span class="line">    _elem[r] = e; _size++; <span class="comment">// 置入新元素并更新容量</span></span><br><span class="line">    <span class="keyword">return</span> r; <span class="comment">// 返回秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  插入前首先调用<code>expand()</code>算法核对是否即将溢出，若有必要，则加倍扩容。为保证数组元素的物理地址连续，随后需要将后缀<code>_elem[r, _size)</code>（若非空)整体后移一个单元。这些后继元素<strong>自后向前</strong>的搬迁次序不能颠倒，否则会因元素被覆盖而造成数据丢失(自后向前的原因)。在单元<code>_elem[r]</code>腾出之后，方可将待插入对象e置入其中。</p>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>  时间主要消耗于后继元素的后移，线性正比于后缀的长度，故总体为$O(  size - r + 1)$。<br>  新插入元素越靠后(前)所需时间越短(长)。特别地，r取最大值_size时为最好情况，只需$O(1)$时间；r取最小值0时，需要$O(size)$时间。一般地，若插入位置等概率分布，则平均运行时间为$O(size) = O(n)$，线性正比于向量的实际规模。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>  删除操作重载有两个接口，<code>remove(lo, hi)</code>用以删除区间[lo, hi)内的元素，而<code>remove(r)</code>用以删除秩为r的单个元素。乍看起来，利用后者即可实现前者：令r从hi - 1到lo递减，反复调用<code>remove(r)</code>。实际可行的思路恰好相反，<strong>应将单元素删除视作区间删除的特例</strong>，并基于后者实现前者(单元素删除与区间删除的关系)。如此可将移动操作的总次数控制在$O(m)$以内，而与待删除区间的宽度无关。</p>
<h3 id="区间删除：remove-lo-hi"><a href="#区间删除：remove-lo-hi" class="headerlink" title="区间删除：remove(lo, hi)"></a>区间删除：<code>remove(lo, hi)</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector_removeInterval.h</span><br><span class="line">代码<span class="number">2.12</span> 向量区间删除接口remove(lo, hi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::remove(Rank lo, Rank hi) &#123; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 出于效率考虑，单独处理退化情况，比如remove(0, 0)</span></span><br><span class="line">    <span class="keyword">while</span> (hi &lt; _size) _elem[lo++] = _elem[hi++] ; <span class="comment">// [hi, _size)顺次前移hi - lo个单元</span></span><br><span class="line">    _size = lo; <span class="comment">// 更新规模，直接丢弃尾部[lo, _size = hi)区间</span></span><br><span class="line">    shrink(); <span class="comment">// 若有必要，则缩容</span></span><br><span class="line">    <span class="keyword">return</span> hi - lo; <span class="comment">// 返回被删除元素的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  设[lo, hi)为向量的合法区间，则其后缀[hi, n)需整体前移hi - lo个单元。与插入算法同理，这里后继元素<strong>自前往后</strong>的移动次序也不能颠倒。</p>
<h3 id="单元素删除：remove-r"><a href="#单元素删除：remove-r" class="headerlink" title="单元素删除：remove(r)"></a>单元素删除：<code>remove(r)</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector_remove.h</span><br><span class="line">代码<span class="number">2.13</span> 向量单元素删除接口remove()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T Vector&lt;T&gt;::remove(Rank r) &#123; <span class="comment">// 删除向量中秩为r的元素, 0 &lt;= r &lt;= size</span></span><br><span class="line">    T e = _elem[r]; <span class="comment">// 备份被删除元素</span></span><br><span class="line">    remove(r, r + <span class="number">1</span>); <span class="comment">// 调用区间删除算法，等效于对区间[r, r+1)的删除</span></span><br><span class="line">    <span class="keyword">return</span> e; <span class="comment">// 返回被删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p><code>remove(lo, hi)</code>的计算成本，主要消耗于后续元素的前移，线性正比于后缀的长度，总体不过$O(m+1) =  O(size - hi + 1)$。区间删除操作所需的时间，应该仅取决于后继元素的数目，而与被删除区间本社你的宽度无关。特别地，基于该接口实现的单元素删除接口<code>remove(r)</code>需耗时$O(size - r)$。也就是说，被删除元素在向量中的位置越靠后(前)所需时间越短(长)，最好为$O(1)$，最坏为$O(n) = O(size)$。</p>
<h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector_deduplicate.h</span><br><span class="line">代码<span class="number">2.14</span> 无序向量清除重复元素接口depulicate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; <span class="comment">// 删除无序向量中重复元素(高效版)</span></span><br><span class="line">    <span class="keyword">int</span> oldSize = _size; <span class="comment">// 记录原规模</span></span><br><span class="line">    Rank i = <span class="number">1</span>; <span class="comment">// 从_elem[1]开始</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; _size) <span class="comment">// 自前向后逐一考察各元素_elem[i]</span></span><br><span class="line">        ( find( _elem[i], <span class="number">0</span>, i) &lt; <span class="number">0</span>) ? <span class="comment">// 在其前缀中寻找与之雷同者(至多一个)</span></span><br><span class="line">        i++ : remove(i); <span class="comment">// 若无雷同则继续考察其后继，否则删除雷同者</span></span><br><span class="line">    <span class="keyword">return</span> oldSize - _size; <span class="comment">// 向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  该算法自前往后逐一考察各元素<code>_elem[i]</code>，并通过调用<code>find()</code>接口，在其前缀中寻找与之雷同者。若找到，则随即删除；否则，转而考察当前元素的后继。</p>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>  算法的正确性由以下不变性保证:</p>
<p><em>在while循环中，在当前元素的前缀<code>_elem[0, i)</code>内，所有元素彼此互异。</em></p>
<p>  初次进入循环时i=1，只有唯一的前驱<code>_elem[0]</code>，故不变性自然满足。<br>  假设在转至元素e = <code>_elem[i]</code>之前不变性一直成立。于是，经过针对该元素的一步迭代之后，无非两种结果：<br>  1)若元素e的前缀<code>_elem[0, i)</code>中不含与之雷同的元素，则在做过i++之后，新的前缀<code>_elem[0, i)</code>将继续满足不变性，而且其规模增加一个单位。<br>  2)反之，若含存在与e雷同的元素，则由此前一直满足的不变性可知，这样的雷同元素不超过一个。因此在删除e之后，前缀<code>_elem[0, i)</code>依旧保持不变性。</p>
<h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><p>  这里所需的时间，主要消耗于<code>find()</code>和<code>remove()</code>两个接口，前一部分时间应先行正比于查找区间的宽度，即前驱的总数；后一部分时间应线性正比于后继的总数。因此，每步迭代所需时间为$O(n)$，总体复杂度应为$O(n^2)$。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector_traverse.h</span><br><span class="line">代码<span class="number">2.15</span> 向量遍历接口traverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::traverse(<span class="keyword">void</span> (*visit)(T &amp;)) &#123; <span class="comment">// 借助函数指针机制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        visit(_elem[i]); <span class="comment">// 遍历向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">// 元素类型、操作器</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST &amp;visit) &#123; <span class="comment">// 借助函数对象机制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        visit(_elem[i]); <span class="comment">// 遍历向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>traverse()</code>遍历的过程，就是<strong>自前向后</strong>逐一对各元素实施同一基本操作。而具体采用何种操作，可通过两种方式指定。前一种方式借助函数指针<code>*visit()</code>指定某一函数，该函数只有一个参数，其类型为对向量元素的引用，故通过该函数即可直接访问或修改向量元素。另外，也可以函数对象的形式，指定具体的遍历操作。这类对象的操作符”()”经重载之后，在形式上等效于一个函数接口，故此得名。<br>  相比较而言，后一形式的功能更强，适用范围更广。比如，函数对象的形式支持对向量元素的关联修改。也就是说，对各元素的修改不仅可以相互独立地进行，也可以根据某个(些)元素的数值相应地修改另一元素。前一形式也可实现这类功能，但要繁琐很多。</p>
<h3 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h3><p>  遍历操作本身只包含一层线性的循环迭代，故除了向量规模的因素外，遍历所需时间应线性正比于所统一指定的基本操作所需的时间。</p>
<h1 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h1><p>  若向量<code>S[0, n)</code>中的所有元素不仅按线性次序存放，而且其数值大小也按此次序单调分布，则称作<strong>有序向量(sorted vector)</strong>。有序向量不要求元素互异，故通常约定其中的元素自前(左)向后(右)构成一个非降序列，即对任意$0 ≤ i &lt; j &lt; n$都有$S[i] ≤ S[j]$。</p>
<h2 id="有序性甄别"><a href="#有序性甄别" class="headerlink" title="有序性甄别"></a>有序性甄别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector_disordered.h</span><br><span class="line">代码<span class="number">2.17</span> 有序向量甄别算法disordered()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::disordered() <span class="keyword">const</span> &#123; <span class="comment">// 返回向量中逆序相邻元素对的总数</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _size; i++) &#123; <span class="comment">// 逐一检查_size - 1对相邻元素</span></span><br><span class="line">        <span class="keyword">if</span> (_elem[i - <span class="number">1</span>] &gt; _elem[i]) n++; <span class="comment">// 逆序则计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n; <span class="comment">// 向量有序当且仅当n = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  顺序扫描整个向量，逐一比较每一对相邻元素——向量已经有序，当且仅当它们都是顺序的。</p>
<h2 id="唯一化-1"><a href="#唯一化-1" class="headerlink" title="唯一化"></a>唯一化</h2><h3 id="低效版"><a href="#低效版" class="headerlink" title="低效版"></a>低效版</h3><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector_uniquify_slow.h</span><br><span class="line">代码<span class="number">2.18</span> 有序向量uniquify()接口的平凡实现</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123; <span class="comment">// 有序向量重复元素剔除算法(低效版)</span></span><br><span class="line">    <span class="keyword">int</span> oldSize = _size; <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// 当前比对元素的秩，起始于首元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; _size) <span class="comment">// 从前向后，逐一比对各对相邻元素</span></span><br><span class="line">        _elem[i<span class="number">-1</span>] == _elem[i] ? remove(i) : i++; <span class="comment">// 若雷同，则删除后者；否则，转至后一元素</span></span><br><span class="line">    <span class="keyword">return</span> oldSize - _size; <span class="comment">// 向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正确性-1"><a href="#正确性-1" class="headerlink" title="正确性"></a>正确性</h4><p>  其正确性基于如下事实：有序向量中的重复元素必然前后紧邻。于是，可以自前向后地逐一检查各对相邻元素:若二者雷同则调用<code>remove()</code>接口删除靠后者，否则转向下一对相邻元素。如此，扫描结束后向量中将不再含有重复元素。</p>
<h4 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h4><p>  运行时间主要消耗于while循环，共需迭代<code>_size - 1 = n - 1</code>步。此外，在最坏情况下，每次循环都需要执行一次<code>remove()</code>操作，由前面可知<code>remove()</code>操作的复杂度线性正比于被删除元素的后继元素总数。因此，当大量甚至所有元素均雷同时，用于所有这些<code>remove()</code>操作的时间总量将高达：<br>  $(n - 2) + (n - 3) + … + 2 + 1 = O(n^2)$<br>  与向量未排序时相同，说明该方法未能充分利用此时向量的有序性。</p>
<h3 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h3><p>  低效版唯一化过程复杂度过高的根源是，在对<code>remove()</code>接口的各次调用中，同一元素可能作为后继元素向前移动多次，且每次仅移动一个单元。<br>  因为此时的每组重复元素都必然前后紧邻地集中分布，所以可以区间为单位成批地删除前后紧邻的各组重复元素，并将其后继元素(若存在)统一地大跨度前移。具体地，若<code>V[lo, hi)</code>为一组相邻的重复元素，则所有的后继元素<code>V[hi, _size)</code>可统一地整体前移hi - lo - 1个单元。</p>
<h3 id="高效版"><a href="#高效版" class="headerlink" title="高效版"></a>高效版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector_uniquify.h</span><br><span class="line">代码<span class="number">2.19</span> 有序向量uniquify()接口的高效实现</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123; <span class="comment">// 有序向量重复元素剔除算法(高效版)</span></span><br><span class="line">    Rank i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 各对互异"相邻"元素的秩</span></span><br><span class="line">    <span class="keyword">while</span> (++j &lt; _size) <span class="comment">// 逐一扫描，直至末元素</span></span><br><span class="line">        <span class="keyword">if</span> (_elem[i] != _elem[j]) <span class="comment">// 跳过雷同者</span></span><br><span class="line">            _elem[++i] = _elem[j]; <span class="comment">// 发现不同元素时，向前移至紧邻于前者后侧</span></span><br><span class="line">    _size = ++i; shrink(); <span class="comment">// 直接截除尾部多余元素</span></span><br><span class="line">    <span class="keyword">return</span> j - i; <span class="comment">// 向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  既然各组重复元素必然彼此相邻地构成一个子区间，故只需依次保留各区间的起始元素。于是，这里引入了变量i和j。每经过若干次移动，i和j都将分别指向下一对相邻子区间的首元素；在将后者转移至前者的后继位置之后(相比低效版这里是元素的复制而不是前移，因此不需要<code>remove()</code>操作)，即可重复上述过程。</p>
<h3 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h3><p>  while循环的每一次迭代，仅需对元素数值做一次比较，向后移动一到两个位置指针，并至多向前复制一个元素，故只需常数时间。而在整个算法过程中，每经过一次迭代秩j都必须加1，鉴于j不能超过向量的规模n，故共需迭代n次。由此可知，<code>uniquify()</code>算法的时间复杂度应为$O(n)$，较之<code>uniquify_slow()</code>的$O(n^2)$,整整提高了一个线性因子。<br>  反过来，在遍历所有元素之前不可能确定是否有重复元素，故就渐进复杂度而言，能在$O(n)$时间内完成向量的唯一化已属最优。能做到这一点的关键在于向量已经排序。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="二分查找-版本A"><a href="#二分查找-版本A" class="headerlink" title="二分查找(版本A)"></a>二分查找(版本A)</h2><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector_search_binary_a.h</span><br><span class="line">代码 <span class="number">2.21</span> 二分查找算法(版本A)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找算法(版本A):在有序向量的区间[lo,hi)内查找元素e, 0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)&#123; <span class="comment">// 每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>; <span class="comment">// 以中点为轴点</span></span><br><span class="line">        <span class="keyword">if</span> (e &lt; A[mi]) hi = mi; <span class="comment">// 深入前半段[lo, mi)继续查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mi] &lt; e) lo = mi + <span class="number">1</span>; <span class="comment">// 深入后半段(mi, hi)继续查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mi; <span class="comment">// 在mi处命中</span></span><br><span class="line">    &#125; <span class="comment">// 成功查找可以提前终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 查找失败</span></span><br><span class="line">&#125; <span class="comment">// 有多个命中元素时，不能保证返回秩最大者；查找失败时，简单返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure>
<p>  为在有序向量区间[lo, hi)内查找元素e，该算法以中点$mi = (lo + hi)/2$为界，将其大致平均地分为前、后两个子向量。随后通过一至两次比较操作，确定问题转化的方向。通过快捷的整数移位操作回避了相对更加耗时的除法运算。另外，通过引入lo、hi和mi等变量，将减治算法通常的递归模式改成了迭代模式。</p>
<h3 id="复杂度-7"><a href="#复杂度-7" class="headerlink" title="复杂度"></a>复杂度</h3><p>  以上算法采取的策略可概括为，以”当前区间内居中的元素”作为目标元素的试探对象。从应对最坏情况的保守角度来看，这一策略是最优的——每一步迭代之后无论沿着哪个方向深入，新问题的规模都将缩小一半。因此，这一策略也称作<strong>二分查找(binary search)。</strong><br>  随着迭代的不断深入，有效的查找区间宽度将按1/2的比例以几何级数的速度递减。于是，经过至多$log_2(hi -lo)$步迭代后，算法必然终止。鉴于每步迭代仅需常数时间，故总体时间复杂度不超过:$O(log_2(hi - lo)) = O(logn)$。<br>  与之前的顺序查找算法$O(n)$复杂度相比，$O(logn)$几乎改进了一个线性因子。</p>
<h3 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h3><p>  以上迭代过程所涉及的计算，主要分为两类：元素的大小比较、秩的算术运算及其赋值。虽然二者均属于$O(1)$复杂度的基本操作，但元素的秩无非是(无符号)的整数，而向量元素的类型则通常更为复杂，甚至复杂到未必能够保证在常数时间内完成(习题【2-17】)。因此就时间复杂度的常系数而言，前一类计算的权重远远高于后者，而查找算法的整体效率也更主要地取决于所执行的元素大小比较操作的次数，即所谓<strong>查找长度(search length)</strong>。</p>
<h4 id="成功查找长度"><a href="#成功查找长度" class="headerlink" title="成功查找长度"></a>成功查找长度</h4><p>  对于长度为n的有序向量，共有n种可能的成功查找，分别对应于某一元素。实际上，每一种成功查找所对应的查找长度，仅取决于n以及目标元素所对应的秩，而与元素的具体数值无关。<br>  为了估计出一半情况下的成功查找长度，不失一般性地，仍在等概率条件下考察长度为$n = 2^k - 1$的有序向量，并将其对应的平均成功查找长度记作$C_{average}(k)$，将所有元素对应的查找长度总和记作$C(k) = C_{average}(k) \cdot (2^k - 1)$。<br>  特别地，当k = 1时向量长度n = 1，成功查找仅有一种情况，故有边界条件:<br>  $C_{average}(1) = C(1) = 2​$<br>  以下采用递推分析法。对于长度为$n = 2^k - 1$的有序向量，每步迭代都有三种可能的分支:经过1次成功的比较后，转化为一个规模为$2^{k-1}-1$的新问题；经2次失败的比较后，终止于向量中的某一元素，并确认在此处成功命中；经1次失败的比较另加1次成功的比较后，转化为另一个规模为$2^{k-1} -1​$的新问题。<br>  根据以上递推分析的结论，可得递推式如下:<br>$$<br>\begin{aligned}<br>C(k)&amp; = [C(k-1) + (2^{k-1} -1 )] + 2 + [C(k-1) + 2 \times (2^{k-1} -1 )] \\<br>&amp; = 2 \cdot C(k-1) + 3 \cdot 2^{k-1} - 1<br>\end{aligned}<br>$$<br>  若令：<br>  $F(k) = C(k) - 3k \cdot 2^{k-1} - 1$<br>  则有:<br>  $F(1) = -2​$<br>$$<br>\begin{aligned}<br>  F(k) &amp; = 2 \cdot F(k - 1) = 2^2 \cdot F(k - 2) = 2^3 \cdot F(k - 3) = … \\<br>  &amp; = 2^{k-1} \cdot F(1) = -2^k<br>  \end{aligned}<br>$$<br>  于是：<br>$$<br>\begin{aligned}<br>  C(k) &amp; = F(k) + 3k \times 2^{k-1} + 1 \\<br>  &amp; = -2^k + 3k \times 2^{k-1} + 1 \\<br>  &amp; = (3k/2 -1) \cdot (2^k - 1) + 3k/2<br>  \end{aligned}<br>$$<br>  进而：<br>$$<br>  \begin{aligned}<br>  C_{average}(k) &amp; = C(k) / (2^k - 1) \\<br>  &amp; = 3k/2 - 1 + 3k/2/(2^k - 1) \\<br>  &amp; = 3k/2 - 1 + O(\varepsilon) \\<br>  \end{aligned}<br>$$<br>  也就是说，若忽略末尾趋于收敛的波动项，平均查找长度应为：<br>  $O(1.5k) = O(1.5 \cdot log_2n)​$</p>
<h4 id="失败查找长度"><a href="#失败查找长度" class="headerlink" title="失败查找长度"></a>失败查找长度</h4><p>  按照上述代码，失败查找的终止条件必然是”lo ≥ hi”，也就是说，只有在有效区间宽度缩减至0时，查找方以失败告终。因此，失败查找的时间复杂度应为确定的$Θ(logn)$。<br>  仿照以上对平均成功查找长度的递推分析方法，不难证明(习题【2-20】)，一般情况下的平均失败查找长度亦为$O(1.5 \cdot log_2n)$。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>  尽管二分查找算法(版本A)即便在最坏情况下也可保证$O(logn)$的渐进时间复杂度，但就其常系数1.5而言仍有改进余地。下面介绍Fibonacci查找将完成这改进。</p>
<h2 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h2><h3 id="递推方程"><a href="#递推方程" class="headerlink" title="递推方程"></a>递推方程</h3><p>  递推方程法既是复杂度分析的重要方法，也是优化算法时确定突破口的有力武器。<br>  最终求解所得到的平均复杂度，主要取决于$(2_{k-1} - 1)$和$2 \times (2_{k-1} - 1)$两项，其中的$(2_{k-1} - 1)$为子向量的宽度，而系数1和2则是算法为深入前、后子向量，所需做的比较操作次数。以此前的二分查找算法版本A为例，之所以存在均衡性方面的缺陷，根源来自于这两项的大小不相匹配。<br>  基于这一理解，发现解决问题的思路不外乎两种：<br>  <em>其一，调整前、后区域的宽度，适当地加长(缩短)前(后)子向量；</em><br>  <em>其二，统一沿两个方向深入所需要执行的比较次数，比如都统一为一次；</em></p>
<h3 id="黄金分割"><a href="#黄金分割" class="headerlink" title="黄金分割"></a>黄金分割</h3><p>  简化起见，设向量长度n = fib(k) - 1<br>  <code>fibsearch(e, 0, n)</code>查找可以mi = fib(k - 1) - 1作为前、后子向量的切分点。如此，前、后子向量的长度将分别是：<br>  $fib(k-1) - 1$<br>  $fib(k-2) - 1 = (fib(k) - 1) - (fib(k - 1) - 1) - 1$<br>  于是，无论朝哪个方向深入，新向量的长度从形式上都依然是某个Fibonacci数减一，故这一处理手法可以反复套用，直至因在S[mi]处命中或向量长度收缩至零而终止。这种查找算法，亦称作<strong>Fibonacci查找(Fibonaccian search)</strong>。</p>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector_search_fibonaccin.h</span><br><span class="line">代码 <span class="number">2.22</span> Fibonacci查找算法</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci查找算法(版本A):在有序向量的区间[lo, hi)内查找元素e, 0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="function">Fib <span class="title">fib</span><span class="params">(hi - lo)</span></span>; <span class="comment">// 用O(log_phi(n = hi - lo)时间创建Fib数列</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)&#123; <span class="comment">// 每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line">        <span class="keyword">while</span> (hi - lo &lt; fib.get()) fib.prev(); <span class="comment">// 通过向前顺序查找(分摊O(1))——至多迭代几次</span></span><br><span class="line">        Rank mi = lo + fib.get() - <span class="number">1</span>; <span class="comment">// 确定形如Fib(k) - 1 的轴点</span></span><br><span class="line">        <span class="keyword">if</span> (e &lt; A[mi]) hi = mi; <span class="comment">// 深入前半段[lo, mi)继续查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mi] &lt; e) lo = mi + <span class="number">1</span>; <span class="comment">// 深入后半段(mi, hi)继续查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mi; <span class="comment">// 在mi处命中</span></span><br><span class="line">    &#125;<span class="comment">// 成功查找可以提前终止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 查找失败</span></span><br><span class="line">&#125; <span class="comment">// 有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure>
<p>  算法主体框架与二分查找大致相同，主要区别在于以黄金分割点取代中点作为切分点。为此，需要借助Fib对象(习题【1-22】)，实现对Fibonacci数的高效设置与获取。<br>  尽管以下的分析多以长度为fib(k) - 1的向量为例，但这一实现完全可适用于长度任意的向量中的任意子向量。为此，只需在进入循环之前调用构造器Fib(n = hi - lo)，将初始长度设置为”不小于n的最小Fibonacci项”。这一步所需花费的$O(log_{\phi}n)$时间，分摊到后续的$O(log_{\phi}n)$步迭代中，并不影响算法整体的渐进复杂度。</p>
<h3 id="定量分析"><a href="#定量分析" class="headerlink" title="定量分析"></a>定量分析</h3><p>  Fibonacci查找算法最好、最坏情况的成功查找长度与二分算法的结论完全一致。<br>  依然将长度为n = fib(k) - 1的有序向量的平均成功查找长度记作$C_{average}(k)$，将所有元素对应的查找长度总和记作$C(k) = C_{average}(k) \cdot (fib(k) - 1)$。<br>  同理，可得边界条件及递推式如下:<br>  $C_{average}(2) = C(2) = 0$<br>  $C_{average}(3) = C(3) = 2$<br>$$<br>\begin{aligned}<br>  C(k) &amp; = [C(k-1) + (fib(k-1) - 1)] + 2 + [C(k-2) + 2 \times (fib(k-2) - 1)] \\<br>  &amp; = C(k - 2) + C(k - 1) + fib(k - 2) + fib(k) - 1<br>  \end{aligned}<br>$$<br>  结合以上边界条件，可以解得:<br>  (令$F(k) = -C(k) + k \cdot fib(k) + 1$，则有$F(0) = 1$，$F(1) = 2$，$F(k) = F(k-1) + F(k-2)$)<br>$$<br>\begin{aligned}<br>  C(k) &amp; = k \cdot fib(k) - fib(k + 2) + 1 \\<br>  &amp; = (k - \phi^2) \cdot fib(k) + 1 + O(\mathcal{E})<br>  \end{aligned}<br>$$<br>其中，$\phi = (\sqrt{5} + 1) / 2 = 1.618$<br>  于是<br>$$<br>\begin{aligned}<br>  C(k) &amp; = C(k) / (fib(k) - 1)\\<br>  &amp; = k - \phi^2 + 1 + (k - \phi^2) / (fib(k) - 1) + O(\mathcal{E}) \\<br>  &amp; = k - \phi^2 + 1 + O(\mathcal{E}) \\<br>  \end{aligned}<br>$$<br>  忽略末尾趋于收敛的波动项，平均查找长度的增长趋势为:<br>  $O(k) = O(log_{\phi}n) = O(log_{\phi}2 \cdot log_2n) = O(1.44 \cdot log_2n)$<br>  较之之前二分查找算法(版本A)的$O(1.5 \cdot log2n)$，效率略有提高。</p>
<h2 id="二分查找-版本B"><a href="#二分查找-版本B" class="headerlink" title="二分查找(版本B)"></a>二分查找(版本B)</h2><h3 id="从三分支对应两分支"><a href="#从三分支对应两分支" class="headerlink" title="从三分支对应两分支"></a>从三分支对应两分支</h3><p>  为了解决二分查找算法版本A的不均衡性，Fibonacci查找算法已通过采用黄金分割点，在一定程度上降低了时间复杂度的常系数。<br>  还有另一更为直接的方法，即令以上两项的常系数同时等于1。也就是说，无论朝哪个方向深入，都只需做1次元素的大小比较。相应地，算法在每步迭代中(或递归层次上)都只有两个分支方向，而不再是三个。<br>  具体过程与二分查找算法的版本A基本类似。不同之处是，在每个切分点<code>A[mi]</code>处，仅做一次元素比较。具体地，若目标元素小于<code>A[mi]</code>，则深入前端子向量<code>A[lo, mi]</code>继续查找；否则，深入后端子向量<code>A[mi, hi)</code>继续查找。</p>
<h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector_search_binary_b.h</span><br><span class="line">代码 <span class="number">2.23</span> 二分查找算法(版本B)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找算法(版本B)：在有序向量的区间[lo, hi)内查找元素e, 0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> &lt; hi - lo)&#123; <span class="comment">// 每步迭代仅需做一次比较，有两个分支；成功查找不能提前终止</span></span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>; <span class="comment">// 以中点为轴点</span></span><br><span class="line">        (e &lt; A[mi]) ? hi = mi : lo = mi; <span class="comment">// 经比较后确定深入[lo, mi)或[mi, hi)</span></span><br><span class="line">    &#125; <span class="comment">// 出口时hi = lo + 1, 查找区间仅含一个元素A[lo]</span></span><br><span class="line">    <span class="keyword">return</span> (e == A[lo]) ? lo : <span class="number">-1</span>; <span class="comment">// 查找成功时返回对应的秩；否则统一返回-1</span></span><br><span class="line">&#125;<span class="comment">// 有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure>
<p>  注意与二分查找版本A的差异。首先，每一步迭代只需判断是否e &lt; A[mi]，即可相应地更新有效查找区间的右边界(hi = mi)或左边界(lo = mi)。另外，只有等到区间的宽度已不足2个单元时迭代才会终止，最后再通过一次比对判断查找是否成功。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>  尽管版本B中的后端子向量需要加入<code>A[mi]</code>，但得益于mi总是位于中央位置，整个算法$O(logn)$的渐进复杂度不受任何影响。<br>  版本B中只有在向量有效区间宽度缩短至1个单元时算法才会终止，而不能像版本A一旦命中就能及时返回。因此，最好情况下的效率有所倒退。作为补偿，最坏情况下的效率相应地有所提高。实际上无论是成功查找或失败查找，版本B各分支的查找长度更加接近，故整体性能更趋稳定。</p>
<h2 id="二分查找-版本C"><a href="#二分查找-版本C" class="headerlink" title="二分查找(版本C)"></a>二分查找(版本C)</h2><h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector_search_binary_c.h</span><br><span class="line">代码 <span class="number">2.24</span> 二分查找算法(版本C)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找算法(版本C)：在有序向量的区间[lo, hi)内查找元素e, 0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)&#123; <span class="comment">// 每步迭代仅需做一次比较判断，有两个分支</span></span><br><span class="line">        Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">// 以中点为轴点</span></span><br><span class="line">        ( e &lt; A[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>; <span class="comment">// 经比较后确定深入[lo, mi)或(mi, hi)</span></span><br><span class="line">    &#125;<span class="comment">// 成功查找不能提前终止</span></span><br><span class="line">    <span class="keyword">return</span> --lo; <span class="comment">// 循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125; <span class="comment">// 有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败位置</span></span><br></pre></td></tr></table></figure>
<p>  该版本的主体结构与版本B一致，故不难理解，二者的时间复杂度相同。</p>
<h3 id="正确性-2"><a href="#正确性-2" class="headerlink" title="正确性"></a>正确性</h3><p>  版本C与版本B的差异，主要有三点。首先，只有当有效区间的宽度缩短至0(而不是1)时，查找方告终止。另外，在每次转入后端分支时，子向量的左边界取作mi + 1而不是mi。<br>  通过数学归纳可以证明，版本C中的循环体，具有如下不变性:</p>
<p>  <em>A[0, lo)中的元素皆不大于e；A[hi, n)中的元素皆大于e</em></p>
<p>  首先迭代时，lo = 0且hi = n，A[hi, n)均空，不变性自然成立。<br>  设在某次进入循环时以上不变性成立，以下无非两种情况。若e &lt; A[mi]，在令hi = mi并使A[hi, n)向左扩展之后，该区间内的元素皆不小于A[mi]，也仍然大于e。反之，若A[mi] ≤ e，在令lo = mi + 1并使A[0, lo)向右拓展之后，该区间内的元素皆不大于A[mi]，也仍然不大于e。上述不变性得以延续。<br>  循环终止时，lo = hi。考察此时的元素A[lo - 1]和A[lo]:作为A[lo, n) = A[hi, n)内的第一个元素，A[lo]必大于e。也就是说A[lo - 1]即是原向量中不大于e的最后一个元素。因此在循环结束后，无论成功与否，只需返回lo - 1即可——这也是版本C与版本B的第三点差异。</p>
<h1 id="排序与下界"><a href="#排序与下界" class="headerlink" title="排序与下界"></a>排序与下界</h1><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性在很多场合都能极大地提高计算的效率。</p>
<h2 id="排序及其分类"><a href="#排序及其分类" class="headerlink" title="排序及其分类"></a>排序及其分类</h2><p>在解决许多应用问题时一种普遍采用的策略是，首先将向量转换为有序向量，再调用有序向量支持的各种高效算法。</p>
<h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><p>排序算法有多种，可从多个角度对其进行分类。</p>
<ol>
<li>根据其处理数据的规模与存储的特点不同，可分为：</li>
</ol>
<ul>
<li>内部排序算法</li>
<li>外部排序算法<br>前者处理的数据规模相对不大，内存足以容纳；后者处理的数据规模很大，必须借助外部甚至分布式存储器，在排序计算过程的任一时刻，内存中只能容纳其中一小部分数据。</li>
</ul>
<ol start="2">
<li>根据输入形式的不同，可分为：</li>
</ol>
<ul>
<li>离线算法(offline algorithm)</li>
<li>在线算法(online algorithm)<br>前一情况下，待排序的数据以批处理的形式整体给出；而在网络计算之类的环境中，待排序的数据通常需要实时生成，在排序算法启动后数据才陆续到达。</li>
</ul>
<ol start="3">
<li>针对所依赖的体系结构不同，又可分为：</li>
</ol>
<ul>
<li>串行排序算法</li>
<li>并行排序算法</li>
</ul>
<ol start="4">
<li>根据排序算法是否采用随机策略，可分为：</li>
</ol>
<ul>
<li>确定式</li>
<li>随机式</li>
</ul>
<p>本书讨论的范围，主要集中于确定式串行脱机的内部排序算法。</p>
<h2 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h2><p>  一般地，任一问题在最坏情况下的最低计算成本，即为该问题的<strong>复杂度下界(lower bound)</strong>。一旦某一算法的性能达到这一下界，即意味着它已是<strong>最坏情况下最优的(worst-case optimal)</strong>。<br>  以下结合比较树模型，介绍界定问题复杂度下界的一种重要方法。</p>
<h2 id="比较树"><a href="#比较树" class="headerlink" title="比较树"></a>比较树</h2><h3 id="基于比较的分支"><a href="#基于比较的分支" class="headerlink" title="基于比较的分支"></a>基于比较的分支</h3><p>  用节点(圆圈)表示算法过程中的不同状态，用有向边表示不同状态之间的相互转换，就可以将算法转化为树形结构。<br>  这一转化方法也可以推广并应用于其他算法。一般地树根结点对应算法入口处的起始状态；内部节点对应过程中的某步计算，通常属于基本操作；叶节点则对应经一系列计算后某次运行的终止状态。如此借助这一树形结构，可以涵盖对应算法所有可能的执行流程。</p>
<h3 id="比较树-1"><a href="#比较树-1" class="headerlink" title="比较树"></a>比较树</h3><p>  算法所有可能的执行过程，都可涵盖于这一树形结构中。具体地，该树具有以下性质：</p>
<ol>
<li>每一内部节点各对应于一次比对(称量)操作；</li>
<li>内部节点的左、右分支，分别对应于在两种比对结果(是否等重)下的执行方向；</li>
<li>叶节点(或等效地，根到叶节点的路径)对应于算法某次执行的完整过程及输出；</li>
<li>反过来，算法的每一运行过程都对应于从根到某一叶节点的路径。</li>
</ol>
<p>按上述规则与算法相对应的树，称作<strong>比较树(comparison tree)</strong>。<br>无论什么算法，只要其中的分支完全取决于不同变量或常量的比对或比较结果，则该算法所有可能的执行过程都可表示和概括为一棵比较树。反之，凡可如此描述的算法，都可称作基于<strong>比较式算法(comparison-based algorithm)</strong>，简称<strong>CBA式算法</strong>。<br>  CBA式算法在最坏情况下的最低执行成本，可由对应的比较树界定。</p>
<h2 id="估计下界"><a href="#估计下界" class="headerlink" title="估计下界"></a>估计下界</h2><h3 id="最小树高"><a href="#最小树高" class="headerlink" title="最小树高"></a>最小树高</h3><p>  考察任一CBA式算法，设CT(A)为与之对应的一棵比较树。<br>  根据比较树的性质，算法A每一次运行所需的时间，将取决于对应叶节点到根节点的距离(称作叶节点的深度)；而算法A在最坏情况下的运行时间，将取决于比较树中所有叶节点的最大深度(称作该树的高度，记作$h(CT(A))$)。因此就渐进的意义而言，算法A的时间复杂度应不低于$\Omega(h(CT(A)))$。<br>  如何估计这些比较树的最小高度？<br>  为此，只需考察书中所含叶节点(可能的输出结果)的数目。具体地，在一棵高度为h的二叉树中，叶节点的数目不可能多余$2^h$。因此反过来，若某一问题的输出结果不少于N种，则比较树中叶节点也不可能少于N个，树高h不可能低于$log_2N$(习题【7-3】)</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>  任一CBA式排序算法所对应比较树的高度应为:<br>  $h ≥ \lceil log_3(n!) \rceil = \lceil log_3e \cdot ln(n!) \rceil = \Omega(nlogn)$<br>  因此最坏情况下CBA排序算法至少需要$\Omega(nlogn)$时间，其中n为待排序元素数目。<br>  需要强调的是，这一$\Omega(nlogn)$下界是针对比较树模型而言的。事实上还有很多不属此类的排序算法，并且其中一些算法在最坏情况下的运行时间，有可能低于这一下界，但与上述结论并不矛盾。</p>
<h1 id="排序器"><a href="#排序器" class="headerlink" title="排序器"></a>排序器</h1><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><h3 id="起泡排序-1"><a href="#起泡排序-1" class="headerlink" title="起泡排序"></a>起泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector_bubblesort.h</span><br><span class="line">代码 <span class="number">2.26</span> 向量的起泡排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 向量的起泡排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort(Rank lo, Rank hi) &#123; <span class="comment">// assert: 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">    <span class="keyword">while</span> (!bubble(lo, hi--)); <span class="comment">// 逐趟做扫描交换，直至全序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  反复调用单趟扫描交换算法，直至逆序现象完全消除。</p>
<h3 id="扫描交换"><a href="#扫描交换" class="headerlink" title="扫描交换"></a>扫描交换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector_bubble.h</span><br><span class="line">代码 <span class="number">2.27</span> 单趟扫描交换</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; <span class="comment">// 一趟扫描交换</span></span><br><span class="line">    <span class="keyword">bool</span> sorted = <span class="literal">true</span>; <span class="comment">// 整体有序标志</span></span><br><span class="line">    <span class="keyword">while</span> (++lo &lt; hi) <span class="comment">// 自左向右，逐一检查各对相邻元素</span></span><br><span class="line">        <span class="keyword">if</span> (_elem[lo - <span class="number">1</span>] &gt; _elem[lo])&#123; <span class="comment">// 若逆序，则</span></span><br><span class="line">            sorted = <span class="literal">false</span>; <span class="comment">// 意味着尚未整体有序，并需要</span></span><br><span class="line">            swap (_elem[lo - <span class="number">1</span>], _elem[lo]); <span class="comment">// 通过交换使局部有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted; <span class="comment">// 返回有序标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  依次比对各对相邻元素，每当发现逆序即令二者彼此交换；一旦经过某趟扫描后未发现任何逆序的相邻元素，即意味着排序任务已经完成，则通过返回标志”sorted”，以便主算法及时终止。</p>
<h3 id="重复元素与稳定性"><a href="#重复元素与稳定性" class="headerlink" title="重复元素与稳定性"></a>重复元素与稳定性</h3><p>  <strong>稳定性(stability)</strong>是对排序算法更为细致的要求，重在考察算法对重复元素的处理效果。具体地，在将向量A转换为有序向量S之后，设$A[i]$对应于$S[k_i]$。若对于A中每一对重复元素$A[i] = A[j]$(相应地$S[k_i] = S[k_j]$)，都有i &lt; j当且仅当$k_i &lt; k_j$，则称该排序算法是<strong>稳定算法(stable algorithm)</strong>。简而言之，稳定算法的特征是，重复元素之间的相对次序在排序前后保持一致。反之，不具有这一特征的排序算法都是<strong>不稳定算法(unstable algorithm)</strong>。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="有序向量的两路归并"><a href="#有序向量的两路归并" class="headerlink" title="有序向量的两路归并"></a>有序向量的两路归并</h3><p>  <strong>二路归并</strong>，就是将两个有序序列合并成一个有序序列。归并排序所需的时间，也主要决定于各趟二路归并所需时间的总和。<br>  二路归并属于迭代式算法。每步迭代中，只需比较两个待归并向量的首元素，将小者取出并追加到输出向量的末尾，该元素在原向量中的后继则成为新的首元素。如此往复，直到，某一向量为空。最后，将另一非空的向量整体接至输出向量的末尾。</p>
<h3 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector_mergesort.h</span><br><span class="line">代码 <span class="number">2.28</span> 向量的归并排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort(Rank lo, Rank hi) &#123; <span class="comment">// 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 单元素区间自然有序，否则...</span></span><br><span class="line">    <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">// 以中点为界</span></span><br><span class="line">    mergeSort(lo, mi); mergeSort(mi, hi); <span class="comment">// 分别排序</span></span><br><span class="line">    merge(lo, mi, hi); <span class="comment">// 归并排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  均匀地将向量<code>S[lo, hi)</code>划分成两个子向量。借助以上的二路归并算法，通过递归调用将二者分别转换为有序向量，得到与原向量S对应的整个有序向量。<br>  这里递归终止条件是当前向量长度：$n = hi -lo = 1$<br>  仅含单个元素的向量必然有序，这一处理分支自然也就可以作为递归基。</p>
<h3 id="二路归并接口的实现"><a href="#二路归并接口的实现" class="headerlink" title="二路归并接口的实现"></a>二路归并接口的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector_merge.h</span><br><span class="line">代码 <span class="number">2.29</span> 有序向量的二路归并</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 有序向量的归并</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge(Rank lo, Rank mi, Rank hi) &#123; <span class="comment">// 各自有序的子向量[lo, mi)和[mi, hi)</span></span><br><span class="line">    T* A = _elem + lo; <span class="comment">// 合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br><span class="line">    <span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">// 前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line">    <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; B[i] = A[i++]); <span class="comment">// 复制前子向量</span></span><br><span class="line">    <span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">// 后子向量C[0, lc) = _elem[mi, hi)</span></span><br><span class="line">    <span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; (j &lt; lb) || (k &lt; lc);)&#123; <span class="comment">// B[j]和C[k]中的小者续至A末尾</span></span><br><span class="line">        <span class="keyword">if</span> ((j &lt; lb) &amp;&amp; (!(k &lt; lc) || (B[j] &lt;= C[k]))) A[i++] = B[j++];</span><br><span class="line">        <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (!(j &lt; lb) || (C[k] &lt; B[j]))) A[i++] = C[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] B; <span class="comment">//释放临时空间B</span></span><br><span class="line">&#125; <span class="comment">// 归并后得到完整的有序向量</span></span><br></pre></td></tr></table></figure>
<p>  约定参与归并的子向量在原向量中总是前、后相邻的，故借助三个入口参数即可界定其范围<code>[lo, mi)</code>和<code>[mi, hi)</code>。另外，为保证归并向量所得的子向量能够原地保存以便继续参与更高层的归并，这里使用了临时数组<code>B[]</code>存放前一向量<code>[lo, mi)</code>的副本(习题【2-28】)。</p>
<h3 id="归并时间"><a href="#归并时间" class="headerlink" title="归并时间"></a>归并时间</h3><p>  二路归并算法<code>merge()</code>的渐进时间成本，取决于其中循环迭代的总次数。<br>  每经过一次迭代，<code>B[i]</code>和<code>C[k]</code>之间的小者都会被移出并接至A的末尾(习题【2-29】和习题【2-30】)。这意味，每经过一次迭代，总和s = j + k都会加一。<br>  考察这一总和s在迭代过程中的变化。初始时，有s = 0 + 0 = 0;而在迭代期间，始终有:<br>  $s &lt; lb + lc = (mi - lo) + (hi - mi) = hi - lo$<br>因此，迭代次数及所需时间均不超过$O(hi - mi) = O(n)$。<br>  反之，按照算法的流程控制逻辑，无论子向量的内部元素组成及其相对大小如何，只有待到s = hi - lo时迭代方能终止。因此，该算法在最好情况下仍需$\Omega(n)$时间，概括而言应为$\Theta(n)$。</p>
<h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><p>  二路归并只需线性时间的结论，并不限于相邻且等长的子向量。实际上，即便子向量在物理地址空间上并非前后衔接，且长度相差悬殊，该算法也依然可行且仅需线性时间。<br>  更重要地，这一算法框架也可应用于列表——而且同样可以达到线性的时间效率。</p>
<h3 id="排序时间"><a href="#排序时间" class="headerlink" title="排序时间"></a>排序时间</h3><p>  归并排序算法的时间复杂度采用递推方程分析法，为此首先将归并排序算法处理长度为n的向量所需时间记作$T(n)$。根据算法构思与流程，为对长度为n的向量归并排序，需递归地对长度各为n/2的两个子向量做归并排序，再花费线性时间做一次二路归并。如此，可得到如下递推关系：<br>  $T(n) = 2 \times T(n/2) + O(n)$<br>  另外，当子向量长度缩短到1时，递归即可终止并直接返回该向量。故有边界条件<br>  $T(1) = O(1)$<br>  联立以上递推式，可以解得(习题【2-26】)<br>  $T(n) = O(nlogn)$<br>  也就是说，归并算法可在$O(nlogn)$时间内对长度为n的向量完成排序。因二路归并算法的效率稳定在$\Theta(n)$，故更准确地讲，归并排序算法的时间复杂度应为$\Theta(nlogn)$。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/17/启动、中断、异常和系统调用/" rel="next" title="启动、中断、异常和系统调用">
                <i class="fa fa-chevron-left"></i> 启动、中断、异常和系统调用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/26/数据结构第三章 列表/" rel="prev" title="第三章 列表">
                第三章 列表 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.jpeg"
                alt="Rilzob" />
            
              <p class="site-author-name" itemprop="name">Rilzob</p>
              <p class="site-description motion-element" itemprop="description">一蓑烟雨任平生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/rilzob" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:watermirrorsir@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/a-shui-rilzob" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.zzndb.com.cn/" title="zz-db" target="_blank">zz-db</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从数组到向量"><span class="nav-number">1.</span> <span class="nav-text">从数组到向量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向量"><span class="nav-number">1.2.</span> <span class="nav-text">向量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造与析构"><span class="nav-number">2.</span> <span class="nav-text">构造与析构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认构造方法"><span class="nav-number">2.1.</span> <span class="nav-text">默认构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于复制的构造方法"><span class="nav-number">2.2.</span> <span class="nav-text">基于复制的构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#析构方法"><span class="nav-number">2.3.</span> <span class="nav-text">析构方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态空间管理"><span class="nav-number">3.</span> <span class="nav-text">动态空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态空间管理"><span class="nav-number">3.1.</span> <span class="nav-text">静态空间管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可扩充向量"><span class="nav-number">3.2.</span> <span class="nav-text">可扩充向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩容"><span class="nav-number">3.3.</span> <span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分摊分析-amortized-analysis"><span class="nav-number">3.4.</span> <span class="nav-text">分摊分析(amortized analysis)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分摊复杂度"><span class="nav-number">3.4.1.</span> <span class="nav-text">分摊复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#O-1-分摊时间"><span class="nav-number">3.4.2.</span> <span class="nav-text">O(1)分摊时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它扩容策略"><span class="nav-number">3.4.3.</span> <span class="nav-text">其它扩容策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缩容"><span class="nav-number">3.5.</span> <span class="nav-text">缩容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常规向量"><span class="nav-number">4.</span> <span class="nav-text">常规向量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直接引用元素"><span class="nav-number">4.1.</span> <span class="nav-text">直接引用元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#置乱器"><span class="nav-number">4.2.</span> <span class="nav-text">置乱器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#置乱算法"><span class="nav-number">4.2.1.</span> <span class="nav-text">置乱算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间置乱接口"><span class="nav-number">4.2.2.</span> <span class="nav-text">区间置乱接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判等器与比较器"><span class="nav-number">4.3.</span> <span class="nav-text">判等器与比较器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无序查找"><span class="nav-number">4.4.</span> <span class="nav-text">无序查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判等器"><span class="nav-number">4.4.1.</span> <span class="nav-text">判等器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序查找"><span class="nav-number">4.4.2.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">4.4.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度"><span class="nav-number">4.4.4.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入"><span class="nav-number">4.5.</span> <span class="nav-text">插入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度-1"><span class="nav-number">4.5.2.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除"><span class="nav-number">4.6.</span> <span class="nav-text">删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#区间删除：remove-lo-hi"><span class="nav-number">4.6.1.</span> <span class="nav-text">区间删除：remove(lo, hi)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单元素删除：remove-r"><span class="nav-number">4.6.2.</span> <span class="nav-text">单元素删除：remove(r)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度-2"><span class="nav-number">4.6.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#唯一化"><span class="nav-number">4.7.</span> <span class="nav-text">唯一化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-2"><span class="nav-number">4.7.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确性"><span class="nav-number">4.7.2.</span> <span class="nav-text">正确性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度-3"><span class="nav-number">4.7.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历"><span class="nav-number">4.8.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-3"><span class="nav-number">4.8.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度-4"><span class="nav-number">4.8.2.</span> <span class="nav-text">复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#有序向量"><span class="nav-number">5.</span> <span class="nav-text">有序向量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性甄别"><span class="nav-number">5.1.</span> <span class="nav-text">有序性甄别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#唯一化-1"><span class="nav-number">5.2.</span> <span class="nav-text">唯一化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#低效版"><span class="nav-number">5.2.1.</span> <span class="nav-text">低效版</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-4"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正确性-1"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">正确性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度-5"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进思路"><span class="nav-number">5.2.2.</span> <span class="nav-text">改进思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高效版"><span class="nav-number">5.2.3.</span> <span class="nav-text">高效版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度-6"><span class="nav-number">5.2.4.</span> <span class="nav-text">复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">5.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找-版本A"><span class="nav-number">5.4.</span> <span class="nav-text">二分查找(版本A)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-5"><span class="nav-number">5.4.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度-7"><span class="nav-number">5.4.2.</span> <span class="nav-text">复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找长度"><span class="nav-number">5.4.3.</span> <span class="nav-text">查找长度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成功查找长度"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">成功查找长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#失败查找长度"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">失败查找长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不足"><span class="nav-number">5.4.4.</span> <span class="nav-text">不足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fibonacci查找"><span class="nav-number">5.5.</span> <span class="nav-text">Fibonacci查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递推方程"><span class="nav-number">5.5.1.</span> <span class="nav-text">递推方程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#黄金分割"><span class="nav-number">5.5.2.</span> <span class="nav-text">黄金分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-6"><span class="nav-number">5.5.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定量分析"><span class="nav-number">5.5.4.</span> <span class="nav-text">定量分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找-版本B"><span class="nav-number">5.6.</span> <span class="nav-text">二分查找(版本B)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从三分支对应两分支"><span class="nav-number">5.6.1.</span> <span class="nav-text">从三分支对应两分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-7"><span class="nav-number">5.6.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">5.6.3.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找-版本C"><span class="nav-number">5.7.</span> <span class="nav-text">二分查找(版本C)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-8"><span class="nav-number">5.7.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确性-2"><span class="nav-number">5.7.2.</span> <span class="nav-text">正确性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序与下界"><span class="nav-number">6.</span> <span class="nav-text">排序与下界</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性"><span class="nav-number">6.1.</span> <span class="nav-text">有序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序及其分类"><span class="nav-number">6.2.</span> <span class="nav-text">排序及其分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法分类"><span class="nav-number">6.2.1.</span> <span class="nav-text">排序算法分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下界"><span class="nav-number">6.3.</span> <span class="nav-text">下界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较树"><span class="nav-number">6.4.</span> <span class="nav-text">比较树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于比较的分支"><span class="nav-number">6.4.1.</span> <span class="nav-text">基于比较的分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较树-1"><span class="nav-number">6.4.2.</span> <span class="nav-text">比较树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#估计下界"><span class="nav-number">6.5.</span> <span class="nav-text">估计下界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最小树高"><span class="nav-number">6.5.1.</span> <span class="nav-text">最小树高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">6.5.2.</span> <span class="nav-text">排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序器"><span class="nav-number">7.</span> <span class="nav-text">排序器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#起泡排序"><span class="nav-number">7.1.</span> <span class="nav-text">起泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#起泡排序-1"><span class="nav-number">7.1.1.</span> <span class="nav-text">起泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扫描交换"><span class="nav-number">7.1.2.</span> <span class="nav-text">扫描交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复元素与稳定性"><span class="nav-number">7.1.3.</span> <span class="nav-text">重复元素与稳定性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">7.2.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有序向量的两路归并"><span class="nav-number">7.2.1.</span> <span class="nav-text">有序向量的两路归并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分治策略"><span class="nav-number">7.2.2.</span> <span class="nav-text">分治策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二路归并接口的实现"><span class="nav-number">7.2.3.</span> <span class="nav-text">二路归并接口的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并时间"><span class="nav-number">7.2.4.</span> <span class="nav-text">归并时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推广"><span class="nav-number">7.2.5.</span> <span class="nav-text">推广</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序时间"><span class="nav-number">7.2.6.</span> <span class="nav-text">排序时间</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rilzob</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
</body>
</html>
