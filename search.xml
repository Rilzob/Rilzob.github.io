<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[推荐系统实践读书笔记（一）]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第1章 好的推荐系统在研究如何设计推荐系统前，了解什么是好的推荐系统至关重要。只有了解了优秀的推荐系统的特征，我们才能在设计推荐系统时根据实际情况进行取舍。 本章分3个步骤回答这个问题： 首先介绍了什么是推荐系统、推荐系统的主要任务、推荐系统和分类目录以及搜索引擎的区别等； 然后按照不同领域分门别类地介绍目前业界常见的个性化推荐应用； 最后介绍推荐系统的评测，通过介绍评测指标给出“好”的定义，从而最终解答“什么是好的推荐系统”这个问题。 1.1 什么是推荐系统推荐系统产生的背景随着信息技术和互联网的发展，人们逐渐从信息匮乏的时代走入了信息过载(overload)的时代。在这个时代，无论是信息消费者还是信息产生着都遇到了很大的挑战：作为信息消费者，如何从大量信息中找到自己感兴趣的信息是一件非常困难的的事情；作为信息产生者，如何让自己生产的信息脱颖而出，受到广大用户的关注，也是一件非常困难的事情。推荐系统就是解决这一矛盾的重要工具。 推荐系统的任务推荐系统的任务就是联系用户和信息，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。 推荐系统与搜索引擎的异同众所周知，为了解决信息过载的问题，最具代表的解决方案是分类目录(雅虎)和搜索引擎(谷歌)。最初的分类目录网站将著名的网站分门别类，从而方便用户根据类别查找网站，然而随着互联网规模的不断扩大，门户网站也只能覆盖少量的热门网站，越来越不满足用户的需求。因此搜索引擎诞生了。但是搜索引擎需要用户主动提供准确的关键词来寻找信息，因此不能解决用户的很多其他需求，比如用户无法提供准确的关键词时，搜索引擎就无能为力了。 和搜索引擎一样，推荐系统也是一种帮助用户快速发现有用信息的工具。但和搜索引擎不同的是，推荐系统不需要用户提供明确的需求，而是通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐能够满足他们兴趣和需求的信息。因此从某种意义上说，推荐系统和搜索引擎对于用户来说是两个互补的工具。搜索引擎满足了用户有明确目的时的主动查找需求，而推荐系统能够在用户没有明确目的的时候他们发现感兴趣的新内容。 生活中常见的推荐过程以看电影为例： 向朋友咨询。这种方式在推荐系统中称为社会化推荐(social recommendation)，即让好友给自己推荐物品。 寻找与自己之前看过的电影在内容上相似的电影。这种推荐方式在推荐系统中称为基于内容的推荐(content-based filtering)。 查看排行榜，看看别人都在看什么电影又或者看看和自己兴趣相近的人看什么电影。这种方式称为基于协同过滤(collaborative filtering)的推荐。 从上面三种方法可以看出，推荐算法的本质是通过一定的方式将用户和物品联系起来，而不同的推荐系统利用了不同的方式。 1.2 个性化推荐系统的应用在互联网的各类网站中都可以看到推荐系统的应用，而个性化推荐系统在这些网站中的主要作用是通过分析大量用户行为日志，给不同用户提供不同的个性化页面展示，以提高网站的点击率和转化率。 尽管不同的网站使用不同的推荐系统技术，但总地来说，几乎所有推荐系统应用都是由前台的展示页面、后台的日志系统、推荐算法系统3部分构成。 1.2.1 电子商务著名的电子商务网站亚马逊(Amazon)是个性化推荐系统的积极应用者和推广者。Amazon的推荐系统融入到了其各类产品中，其中最主要的应用是个性化商品推荐列表和相关商品的推荐列表。 个性化推荐列表基于物品的推荐算法(item-based method)该算法给用户用户推荐那些和他们之前喜欢的物品相似的物品。 个性化推荐列表组成部分 推荐结果的标题、缩略图以及其他内容属性。 推荐结果的平均分。 推荐理由。并且允许用户修正这一推荐 基于好友的推荐算法该算法按照用户在Facebook的好友关系，给用户推荐他们的好友在亚马逊上喜欢的物品。基于该种推荐算法生成的推荐列表的组成部分与基于物品的推荐列表类似，只不过这里的推荐理由换成了喜欢过相关物品的用户好友的头像。 相关推荐列表Amazon有两种相关商品列表： 包含购买了这个商品的用户也经常购买的其他商品 包含浏览过这个商品的用户经常购买的其他商品 这两种相关推荐列表的区别就是使用了不同用户行为计算物品的相关性。 此外，相关推荐列表最重要的应用就是打包销售(cross selling)。 1.2.2 电影和视频网站代表公司Netflix、Youtube、Hulu。其中Netflix和Youtube的算法与Amazon的算法类似，也是基于物品的推荐算法，即给用户推荐和他们曾经喜欢的视频相似的视频。 1.2.3 个性化音乐网络电台个性化推荐的成功应用需要两个条件： 存在信息过载。因为如果用户可以很容易地从所有物品中找到喜欢的物品，就不需要个性化推荐了。 用户大部分时候没有特别明确的需求。因为用户如果有明确的需求，可以直接通过搜索引擎找到感兴趣的物品。 在这两个条件下，个性化网络电台无疑是最合适的个性化推荐产品。目前有很多知名的个性化音乐网络电台。国际上著名的有Pandora和Last.fm，国内的代表则是网易云音乐。这三种应用虽然都是个性化网络电台，但背后的技术却不太一样。 PandoraPandora背后的音乐推荐系统主要来自于一个叫做音乐基因工程的项目。Pandora的算法主要基于内容，其音乐家和研究人员亲自听了上万首来自不同歌手的歌，然后对歌曲的不同特性(比如旋律、节奏、编曲和歌词等)进行标注，这些标注被称为音乐的基因。然后，Pandora会根据专家标注的基因计算歌曲的相似度，并给用户推荐和他之前喜欢的音乐在基因上相似的其他音乐。 Last.fmLast.fm记录了所有用户的听歌记录以及用户对歌曲的反馈，在这一基础上计算出不同用户在歌曲上的喜好相似度，从而给用户推荐和他有相似听歌爱好的其他用户喜欢的歌曲。同时，Last.fm也建立了一个社交网络，让用户能够和其他用户建立联系，同时也能让用户给好友推荐自己喜欢的歌曲。和Pandora相比，Last.fm没有使用专家标注，而是主要利用用户行为计算歌曲的相似度。 音乐推荐的特点2011年的Recsys大会专门要求了Pandora和研究人员对音乐推荐系统进行了演讲。演讲人总结了音乐推荐的如下特点： 物品空间大； 消费每首歌的代价很小； 物品种类丰富； 听一首歌耗时很少； 物品重用率很高； 用户充满激情； 上下文相关； 次序很重要； 很多播放列表资源； 不需要用户全神贯注； 高度社会化； 上面这些特点决定了音乐是一种非常适合用来推荐的物品。因此，尽管现在很多推荐系统都是作为一个应用存在与网站中，比如Amazon的商品推荐和Netflix的电影推荐，但唯有音乐推荐系统可以支持独立的个性化推荐网站，比如Pandora、Last.fm和豆瓣网络电台。 1.2.4 社交网络社交网络中的个性化推荐主要应用于3个方面： 利用用户的社交网络信息对用户进行个性化的物品推荐； 信息流的会话推荐； 给用户推荐好友； 1.2.5 个性化阅读个性化阅读同样符合前面提出的需要个性化推荐的两个因素：首先，互联网上的文章很多，用户面临信息过载的问题；其次，用户很多时候并没有必须看某篇具体文章的需求，他们只是想通过阅读特定领域的文章了解这些领域的动态。 Google ReaderGoogle Reader是一款流行的社会化阅读工具。它允许用户关注自己感兴趣的人，然后看到所关注用户分享的文章。 Zite和Google Reader不同，个性化阅读工具Zite则是收集用户对文章的偏好信息。在每篇文章右侧，Zite都允许用户给出喜欢或不喜欢的反馈，然后通过分析用户的反馈数据不停地更新用户的个性化文章列表。 DiggDigg是一家著名的新闻阅读网站。Digg首先根据用户的Digg历史计算用户之间的兴趣相似度，然后给用户推荐和他兴趣相似的用户喜欢的文章。 1.2.6 基于位置的服务随着移动设备的飞速发展，用户的位置信息已经非常容易获取，而位置是一种很重要的上下文信息，基于位置给用户推荐离他近的且他感兴趣的服务，用户就更有可能去消费。 Foursquare基于位置的服务往往和社交网络结合在一起。其中Foursquare推出了探索功能，给用户推荐好友在附近的行为。 1.2.7 个性化邮件使对用户重要的邮件能够让用户优先浏览。 Tapestry目前在文献中能够查到的第一个推荐系统Tapestry就是一个个性化邮件推荐系统，它通过分析用户阅读邮件的历史行为和习惯对新邮件进行重新排序，从而提高用户的工作效率。 1.2.8 个性化广告个性化广告投放目前已经成为了一门独立的学科——计算广告，但该学科和推荐系统在很多基础理论和方法上是相通的，比如它们的目的都是联系用户和物品，只是在个性化广告中，物品就是广告。 个性化广告投放和狭义个性化推荐的区别个性化推荐着重于帮助用户找到可能令他们感兴趣的物品，而广告推荐着重于帮助广告找到可能对它们感兴趣的用户，即一个是以用户为核心，而另一个是以广告为核心。 个性化广告投放技术目前个性化广告投放技术主要分为3种： 上下文广告。通过分析用户正在浏览的网页内容，投放和网页内容相关的广告。代表系统是谷歌的Adsense。 搜索广告。通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告。 个性化展示广告。我们经常在很多网站看到大量的展示广告(就是那些大的横幅图片)，它们是根据用户的兴趣，对不同用户投放不同的展示广告。 Yahoo发表了大量个性化广告方面的论文，而最成功的则是Facebook。 1.3 推荐系统评测一个完整的推荐系统一般存在3个参与方：用户、物品提供者和提供推荐系统的网站。同时好的推荐系统设计，能够让推荐系统本身收集到高质量的用户反馈，不断完善推荐的质量，增加用户和网站的交互，提高网站的收入。因此在评测一个推荐算法时，需要同时考虑三方的利益，一个好的推荐系统是能够令三方共赢的系统。在推荐系统的早期研究中，很多人将好的推荐系统定义为能够作出准确预测的推荐系统。但是，后来很多研究表明，准确的预测并不代表好的推荐。举个极端点的例子，某推荐系统预测明天太阳将从东方升起，虽然预测准确率为100%，却是一种没有意义的预测。所以，好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西。为了全面评测推荐系统对三方利益的影响，本章从不同角度出发，提出不同的指标。 1.3.1 推荐系统实验方法首先介绍计算和获得这些指标的主要实验方法。推荐系统中主要有3种评测推荐效果的实验方法，即离线实验(offline experiment)、用户调查(user study)和在线实验(online experiment)。 离线实验离线实验的方法离线实验的方法一般由如下几个步骤构成： 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集； 将数据集按照一定的规则分成训练集和测试集； 在训练集上训练用户兴趣模型，在测试集上进行预测； 通过事先定义的离线指标评测算法评测在测试集上的预测结果。 从上面的步骤可以看到，推荐系统的离线实验都是在数据集上完成的，也就是说它不需要一个实际的系统来供它实验，而只要有一个从实验系统日志中提取的数据集即可。 离线实验的优缺点这种实验方法的好处是不需要真实用户参与，可以直接快速地计算出来，从而方便、快速地测试大量不同的算法。它的主要缺点是无法获得很多商业上关注的指标，如点击率、转化率等，而找到和商业指标非常相关的离线指标也是很困难的事情。 用户调查用户调查是推荐系统评测的一个重要工具，很多离线时没有办法评测的与用户主观感受有关的指标都可以通过用户调查获得。 用户调查的方法用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。 用户调查的优缺点它的优点是可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。缺点是招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。此外，在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。 在线实验在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试，将它和旧的算法进行比较。 在线实验的方法AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同用户的各种不同的评测指标比较不同算法。 网站http://www.abtests.com/给出了很多通过实际AB测试提高网站用户满意度的例子，从中我们可以学习到如何进行合理的AB测试。 在线实验的优缺点AB测试的优点是可以公平获得不同算法实际在线时的性能指标，包括商业上关注的指标。AB测试的缺点主要是周期比较长，必须进行长期的实验才能得到可靠的结果。因此一般不会用AB测试测试所有的算法，而只是用它测试那些在离线实验和用户调查中表现很好的算法。其次，一个大型网站的AB测试系统的设计也是一项复杂的工程。 一般来说，一个新的推荐算法最终上线，需要完成上面所说的3个实验。 首先，需要通过离线实验证明它在很多离线指标上优于现有的算法。 然后，需要通过用户调查确定它的用户满意度不低于现有的算法。 最后，通过在线的AB测试确定它在我们关心的指标上优于现有的算法。 1.3.2 评测指标1.用户满意度 用户作为推荐系统的重要参与者，其满意度是评测推荐系统的最重要指标。但是，用户满意度没有办法离线计算，只能通过用户调查或在线实验方式获得。 用户调查获得用户满意度主要是通过调查问卷的形式。用户对推荐系统的满意度分为不同的层次。因此在设计问卷时需要考虑到用户各方面的感受，这样用户才能针对问题给出自己准确的回答。 在在线系统中，用户满意度主要通过一些对用户行为的统计得到。更一般的情况下，我们可以用点击率、用户停留时间和转化率等指标度量用户的满意度。 2.预测准确度 预测准确度度量一个推荐系统或者推荐算法预测用户行为的能力。 计算方法：在计算该指标时需要有一个离线的数据集，该数据集包含用户的历史行为记录。然后，将该数据集通过时间分为训练集和测试集。最后，通过在训练集上建立用户的行为和兴趣模型预测用户在测试集上的行为，并计算预测行为和测试集上实际行为的重合度作为预测准确度。 不同的研究方向有不同的预测准确度指标。 评分预测 预测用户对物品评分的行为称为评分预测。 评分预测的预测准确度一般通过均方根误差(RMSE)和平均绝对误差(MAE)计算。对于测试集中的一个用户u和物品i，令$$r_{ui}$$是用户u对物品i的实际评分，而$$\hat r_{ui}$$是推荐算法给出的预测评分，那么RMSE的定义为：$$RMSE = \frac {\sqrt{\sum_{u,i \in T} (r_{ui} - \hat r_{ui})^2}}{|T|}$$ MAE采用绝对值计算预测误差，它的定义为：$$MAE=\frac{\sum_{u,i \in T}|r_{ui}-\hat r_{ui}|} {|T|}$$ 假设我们用一个列表records存放用户评分数据，令records[i] = [u,i,rui,pui]，其中rui是用户u对物品i的实际评分，pui是算法预测出来的用户u对物品i的评分，下面代码实现了RME和MAE的计算过程。 12345def RMSE(records): return math.sqrt(sum([(rui - pui) * (rui - pui) for u,i,rui,pui in records])/float(len(records)))def MAE(records): return sum([abs(rui-pui) for u,i,rui,pui in records])/float(len(records)) 关于RMSE和MAE这两个指标的优缺点，Netflix认为RMSE加大了对预测不准的用户物品评分的惩罚(平方项的惩罚)，因而对系统的评测更加苛刻。研究表明，如果评分系统是基于基数建立的(即用户给的评分都是整数)，那么对预测结果取整可能会降低MAE的误差。 TopN推荐网站在提供推荐服务时，一般是给用户一个个性化的推荐列表，这种推荐叫做TopN推荐。TopN推荐的预测准确率一般通过准确率(precision)/召回率(recall)度量。$$R(u)$$是根据用户在训练集上的行为给用户作出的推荐列表，而$$T(u)$$是用户在测试集上的行为列表。那么，推荐结果的召回率定义为：$$Recall=\frac {\sum_{u \in U} |R(u) \cap T(u)|}{\sum_{u \in U} |T(u)|} $$推荐结果的准确率定义为：$$Precision=\frac {\sum_{u \in U} |R(u) \cap T(u)|}{\sum_{u \in U} |R(u)|} $$下面的Python代码同时计算出了一个推荐算法的准确率和召回率： 12345678910def PrecisionRecall(test, N): hit = 0 n_recall = 0 n_precision = 0 for user, items in test.items(): rank = Recommend(user, N) hit += len(rank &amp; item) # hit是推荐列表与行为列表相交的部分 n_recall += len(items) n_precision += N return [hit/(1.0*n_recall),hit/(1.0*n_precision)] 有的时候，为了全面评测TopN推荐的准确率和召回率，一般会选取不同的推荐列表长度N，计算出一组准确率和召回率，然后画出准确率/召回率曲线(precision/recall curve)。 关于评分预测和TopN推荐的讨论评分预测一直是推荐系统研究的热点，绝大多数推荐系统的研究都是基于用户评分数据的评分预测。这主要是因为，一方面推荐系统的早期研究组GroupLens的研究主要就是基于电影评分 数据MovieLens进行的，其次，Netflix大赛也主要面向评分预测问题。因而，很多研究人员都将 研究精力集中在优化评分预测的RMSE上。 对此，亚马逊前科学家Greg Linden有不同的看法。2009年, 他在Communications of the ACM 网站发表了一篇文章 (“What is a Good Recommendation Algorithm？”,参见http://cacm.acm.org/blogs/blog-cacm/22925-what-is-a-goodrecommendation-algorithm/fulltext/) ，指出电影推荐的目的是找到用户最有可能感兴趣的电影，而不是预测用户看了电影后会给电影什么样的评分。因此，TopN推荐更符合实际的应用需求。也许有一部电影用户看了之后会给很高的分数，但用户看的可能性非常小。因此，预测用户是否会看一部电影， 应该比预测用户看了电影后会给它什么评分更加重要。因此，本书主要也是讨论TopN推荐。 3.覆盖度覆盖度(coverage)描述一个推荐系统对物品长尾的发掘能力。覆盖率有不同的定义方法，最简单的定义为推荐系统能够推荐出来的物品占总物品集合的比例。假设系统的用户集合为$$U$$，推荐系统给每个用户推荐一个长度为N的物品列表$$R(u)$$。那么推荐系统的覆盖率可以通过下面的公式计算：$$Coverage=\frac{| \bigcup_{u \in U} R(u)|}{|I|}$$从上面的定义可以看到，覆盖率是一个内容提供商会关心的指标。一个好的推荐系统不仅需要有比较高的用户满意度，也要有较高的覆盖率。但是上面的定义过于粗略。覆盖率为100%的系统可以有无数的物品流行度分布。为了更细致地描述推荐系统发掘长尾的能力，需要统计推荐列表中不同物品出现次数的分布。如果所有的物品都出现在推荐列表中，且出现的次数差不多，那么推荐系统发掘长尾的能力就很好。因此，可以通过研究物品在推荐列表中出现次数的分布描述推荐系统挖掘长尾的能力。如果这个分布比较平，那么说明推荐系统的覆盖率较高，而如果这个分布较陡峭，说明推荐系统的覆盖率较低。在信息论和经济学中有两个著名的指标可以用来定义覆盖率。第一个是信息熵：$$H = -\sum_{i=1}^n p(i) \log p(i)$$这里$$p(i)$$是物品i的流行度除以所有物品的流行度之和。第二个是基尼系数(Gini Index)：$$G = \frac{1}{n-1} \sum_{j=1}^n (2j-n-1)p(i_j)$$这里$$i_j$$是按照物品流行度$$p()$$从小到大排序的物品列表中第j个物品。下面代码用来计算给定物品流行度分布后的基尼系数：1234567def GiniIndex(p): j = 1 n = len(p) G = 0 for item, weight in sorted(p.items(), key=itemgetter(1)): G += (2 * j - n - 1) * weight return G / float(n - 1) 社会学领域有一个著名的马太效应，即所谓强者更强，弱者更弱的效应。推荐系统的初衷是希望消除马太效应，使得各种物品都能被展示给对它们感兴趣的某一类人群。但是，很多研究表明现在主流的推荐算法（比如协同过滤算法）是具有马太效应的。评测推荐系统是否具有马太效应的简单办法就是使用基尼系数。如果G1是从初始用户行为中计算出的物品流行度的基尼系数，G2是从推荐列表中计算出的物品流行度的基尼系数，那么如果G2 &gt; G1，就说明推荐算法具有马太效应。 4.多样性为了满足用户广泛的兴趣，推荐列表需要能够覆盖用户不同的兴趣领域，即推荐结果需要具有多样性。多样性推荐列表的好处用一句俗话表述就是“不在一棵树上吊死”。尽管用户的兴趣在较长的时间跨度中是一样的，但具体到用户访问推荐系统的某一刻，其兴趣往往是单一的，那么如果推荐列表只能覆盖用户的一个兴趣点，而这个兴趣点不是用户这个时刻的兴趣点，推荐列表就不会让用户满意。反之，如果推荐列表比较多样，覆盖了用户绝大多数的兴趣点，那么就会增加用户找到感兴趣物品的概率。因此给用户的推荐列表也需要满足用户广泛的兴趣，即具有多样性。多样性描述了推荐列表中物品两两之间的不相似性。因此，多样性和相似性是对应的。假设$$s(i,j) \in [0,1]$$定义了物品i和j之间的相似度，那么用户u的推荐列表$$R(u)$$的多样性定义如下：$$Diversity=1-\frac {\sum_{i,j \in R(u),i \neq j} s(i,j)}{\frac{1}{2}|R(u)|(|R(u)|-1)}$$而推荐系统的整体多样性可以定义为所有用户推荐列表多样性的平均值：$$Diversity=\frac{1}{|U|} \sum_{u \in U}Diversity(R(u))$$从上面的定义可以看到，不同的物品相似度度量函数s(i, j)可以定义不同的多样性。如果用内容相似度描述物品间的相似度，我们就可以得到内容多样性函数，如果用协同过滤的相似度函数描述物品间的相似度，就可以得到协同过滤的多样性函数。 5.新颖性新颖的推荐是指给用户推荐那些他们以前没有听说过的物品。在一个网站中实现新颖性的最简单办法是，把那些用户之前在网站中对其有过行为的物品从推荐列表中过滤掉。O’scar Celma在博士论文“Music Recommendation and Discovery in the Long Tail”(参见“Music Recommendation and Discovery in the Long Tail”，地址为http://mtg.upf.edu/static/media/PhD_ocelma.pdf) 中研究了新颖度的评测。评测新颖度的最简单方法是利用推荐结果的平均流行度，因为越不热门的物品越可能让用户觉得新颖。因此，如果推荐结果中物品的平均热门程度较低，那么推荐结果就可能有比较高的新颖性。但是，用推荐结果的平均流行度度量新颖性比较粗略，因为不同用户不知道的东西是不同的。因此，要准确地统计新颖性需要做用户调查。最近几年关于多样性和新颖性的研究越来越受到推荐系统研究人员的关注。ACM的推荐系统会议在2011年有一个专门的研讨会讨论推荐的多样性和新颖性。 (参见“International Workshop on Novelty and Diversity in Recommender Systems”，地址为http://ir.ii.uam.es/divers2011/) 该研讨会的组织者认为，通过牺牲精度来提高多样性和新颖性是很容易的，而困难的是如何在不牺牲精度的情况下提高多样性和新颖性。关心这两个指标的读者可以关注一下这个研讨会最终发表的论文。 6.惊喜度惊喜度（serendipity）是最近这几年推荐系统领域最热门的话题。惊喜度和新颖度作为推荐系统的指标，它们之间的区别并非两个词在中文里含义的区别而是意义上的区别。可以举一个例子说明这两种指标的区别。假设一名用户喜欢周星驰的电影，然后我们给他推荐了一部叫做《临歧》的电影（该电影是1983年由刘德华、周星驰、梁朝伟合作演出的，很少有人知道这部有周星驰出演的电影），而该用户不知道这部电影，那么可以说这个推荐具有新颖性。但是，这个推荐并没有惊喜度，因为该用户一旦了解了这个电影的演员，就不会觉得特别奇怪。但如果我们给用户推荐张艺谋导演的《红高粱》，假设这名用户没有看过这部电影，那么他看完这部电影后可能会觉得很奇怪，因为这部电影和他的兴趣一点关系也没有，但如果用户看完电影后觉得这部电影很不错，那么就可以说这个推荐是让用户惊喜的。这个例子的原始版本来自于Guy Shani的论文(参见Guy Shani和 Asela Gunawardana的“Evaluating Recommendation Systems”) ，他的基本意思就是，如果推荐结果和用户的历史兴趣不相似，但却让用户觉得满意，那么就可以说推荐结果的惊喜度很高，而推荐的新颖性仅仅取决于用户是否听说过这个推荐结果。目前并没有什么公认的惊喜度指标定义方式，这里只给出一种定性的度量方式。上面提到，令用户惊喜的推荐结果是和用户历史上喜欢的物品不相似，但用户却觉得满意的推荐。那么，定义惊喜度需要首先定义推荐结果和用户历史上喜欢的物品的相似度，其次需要定义用户对推荐结果的满意度。前面也曾提到，用户满意度只能通过问卷调查或者在线实验获得，而推荐结果和用户历史上喜欢的物品相似度一般可以用内容相似度定义。也就是说，如果获得了一个用户观看电影的历史，得到这些电影的演员和导演集合A，然后给用户推荐一个不属于集合A的导演和演员创作的电影，而用户表示非常满意，这样就实现了一个惊喜度很高的推荐。因此提高推荐惊喜度需要提高推荐结果的用户满意度，同时降低推荐结果和用户历史兴趣的相似度。惊喜度的问题最近几年获得了学术界的一定关注，但这方面的工作还不是很成熟。相关工作可以参考Yuan Cao Zhang等的论文(参见Yuan Cao Zhang、Diarmuid Ó Séaghdha、Daniele Quercia和 Tamas Jambor的“Auralist: introducing serendipity into music recommendation.”)和Tomoko Murakami等的论文 (参见Tomoko Murakami、 Koichiro. Mori和Ryohei Orihara的“ Metrics for evaluating the serendipity of recommendationlists”)。 7.信任度对于基于机器学习的自动推荐系统，同样存在信任度（trust）的问题，如果用户信任推荐系统，那就会增加用户和推荐系统的交互。度量推荐系统的信任度只能通过问卷调查的方式，询问用户是否信任推荐系统的推荐结果。提高推荐系统的信任度主要有两种方法。首先需要增加推荐系统的透明度(transparency)(参见Henriette Cramer、Vanessa Evers、 Satyan Ramlal、 Maarten van Someren、Lloyd Rutledge、 Natalia Stash、Lora Aroyo和Bob Wielinga的“ The effects of transparency on trust in and acceptance of a content-based art recommender”) ， 而增加推荐系统透明度的主要办法是提供推荐解释。只有让用户了解推荐系统的运行机制，让用 户认同推荐系统的运行机制，才会提高用户对推荐系统的信任度。其次是考虑用户的社交网络 信息，利用用户的好友信息给用户做推荐，并且用好友进行推荐解释。这是因为用户对他们的 好友一般都比较信任，因此如果推荐的商品是好友购买过的，那么他们对推荐结果就会相对比较信任。关于推荐系统信任度的研究(参见Paolo Massa和 Paolo Avesani的“Trust-aware recommender systems”)主要集中在评论网站Epinion的推荐系统上。这是因为Epinion创建了一套用户之间的信任系统来建立用户之间的信任关系，帮助用户判断是否信任当前用户对某一个商品的评论。 8.实时性在很多网站中，因为物品（新闻、微博等）具有很强的时效性，所以需要在物品还具有时效性时就将它们推荐给用户。推荐系统的实时性包括两个方面。首先，推荐系统需要实时地更新推荐列表来满足用户新的行为变化。很多推荐系统都会在离线状态每天计算一次用户推荐列表，然后于在线期间将推荐列表展示给用户。这种设计显然是无法满足实时性的。与用户行为相应的实时性，可以通过推荐列表的变化速率来评测。如果推荐列表在用户有行为后变化不大，或者没有变化，说明推荐系统的实时性不高。实时性的第二个方面是推荐系统需要能够将新加入系统的物品推荐给用户。这主要考验了推荐系统处理物品冷启动的能力。 9.健壮性健壮性（即robust,鲁棒性）指标衡量了一个推荐系统抗击作弊的能力。算法健壮性的评测主要利用模拟攻击。首先，给定一个数据集和一个算法，可以用这个算法给这个数据集中的用户生成推荐列表。然后，用常用的攻击方法向数据集中注入噪声数据，然后利用算法在注入噪声后的数据集上再次给用户生成推荐列表。最后，通过比较攻击前后推荐列表的相似度评测算法的健壮性。如果攻击后的推荐列表相对于攻击前没有发生大的变化，就说明算法比较健壮。在实际系统中，提高系统的健壮性，除了选择健壮性高的算法，还有以下方法。 设计推荐系统时尽量使用代价比较高的用户行为。 在使用数据前，进行攻击检测，从而对数据进行清理。 10.商业目标不同的网站会根据自己的盈利模式设有不同的商业目标。因此，设计推荐系统时需要考虑最终的商业目标，而网站使用推荐系统的目的除了满足用 户发现内容的需求，也需要利用推荐系统加快实现商业上的指标。 11.总结 对于可以离线优化的指标，作者的看法是应该在给定覆盖率、多样性、新颖性等限制条件下，尽量优化预测准确度。用一个数学公式表达，离线实验的优化目标是：​ 最大化预测准确度​ 使得 覆盖率 &gt; A​ 多样性 &gt; B​ 新颖性 &gt; C其中，A、B、C的取值应该视不同的应用而定。 1.3.3 评测维度除了应该考虑评测指标，还应考虑评测维度。增加评测维度的目的就是知道一个推荐算法在什么情况下性能最好。这样可以为融合不同推荐算法取得最好的整体性能带来参考。一般情况下，评测维度分为如下3种： 用户维度：主要包括用户的人口统计学信息、活跃度以及是不是新用户等。 物品维度：包括物品的属性信息、流行度、平均分以及是不是新加入的物品等。 时间维度：包括季节，是工作日还是周末，是白天还是晚上等。 如果能够在推荐系统评测报告中包含不同维度下的系统评测指标，就能帮我们全面地了解推荐系统性能，找到一个看上去比较弱的算法的优势，发现一个看上去比较强的算法的缺点。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次顿悟]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%B8%80%E6%AC%A1%E9%A1%BF%E6%82%9F%2F</url>
    <content type="text"><![CDATA[最近一直都在搞怎么让百度收录我的Blog的问题，最后也没有解决，耽误了两三天的时间。为什么Google就能爬取Github Pages，百度就不行呢，忍不住去吐槽(这个事真是烦死我)，对了还有Coding也是个坑。 在解决这个期间也有所思考，并且得到一个顿悟(大喜)，就是人如果想成功就要在高维度上努力而不是低维度。 人的时间都是有限的，并且假设所有人的资质都是相同的(当然是不可能的)，如果能尽可能地节省时间，那么相比其他人就会走得更远。换句话说就是尽可能地让前进的步子迈得更大。说这话什么意思呢?举个例子，如果你高中三年努力考上了清华北大，可能就会比研究生考上清北的人节省出三四年甚至更多的时间。为什么？因为你高中同样花了三年的时间，大学花去了四年时间才和人家只花高中三年的人站在同一高度，有可能还低一些，那么人家是不是比你少花了三四年呢？拿三年换七年血赚啊，谁都明白这个道理。 上升一个层次再去思考这个问题。有的人本科阶段很努力每天都在研究编程，编程技术很厉害，就比如我。但另一些人会去研究论文，刷绩点，准备出国留学。两者的努力程度是一样的，如果两种人的目标是相同的，那么很明显后者到达目标的速度会明显比前者快很多，这就是努力层次的问题。前者是在低维度努力，而后者是在高纬度努力，类似于高处的人比低处的人看得更远。更形象地距举例就是一个人在高抬腿向前跑，而另一个人则是大跨步向前跑。为什么说前者是低维度而后者是高维度呢？因为前者所做的是有一定经验的人都能去做的，虽然短期可能会得到更现实的成就感，但从长远来看后者所做的开创性研究是不可替代的，更牛逼。 令人伤心地是之前的我就是第一种人，而我本科前两年的努力都是高抬腿跑。我已经落后很多了。但凡事都有两面性，好的一方面是现在的我意识到了这点，于是我坚定了我要考研清华的决心，只有这样我才能追回来一些时间。相比那些保研的同学我还有一个优势，就是别无选择，我不会因为目标的不确定而恍惚。 背水一战，向死而生。希望我自己能谨记这次顿悟，会受益匪浅。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中常用的内置函数]]></title>
    <url>%2F2018%2F11%2F09%2FPython%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python中常用的内置函数Python内置函数(built-in)是随着Python解释器的运行而被创建的。在Python程序中，你可以随时调用这些函数，而且不需要定义。在开发过程中，合理地使用这些内置函数能极大地提升你的开发效率。 这篇文章是对我在开发过程中经常遇到的内置函数的用法总结。 enumerate()函数描述enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合成一个索引序列，同时列出数据和数据下标，一般用于for循环中。 语法1enumerate(sequence, [start=0]) 参数 sequence: 一个序列、迭代器或其他可迭代对象。 start: 下标开始位置。 返回值返回enumerate(枚举)对象。 实例12345&gt;&gt;&gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']&gt;&gt;&gt; list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(seasons, start=1)) # 下标从 1 开始[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] 普通的for循环123456789&gt;&gt;&gt;i = 0&gt;&gt;&gt; seq = ['one', 'two', 'three']&gt;&gt;&gt; for element in seq:... print i, seq[i]... i +=1... 0 one1 two2 three for循环使用enumerate()1234567&gt;&gt;&gt;seq = ['one', 'two', 'three']&gt;&gt;&gt; for i, element in enumerate(seq):... print i, element... 0 one1 two2 three isinstance()函数描述isinstance()函数用来判断一个对象是否是一个已知类型，类似type()。 isinstance()和type()的区别： type()不会认为子类是一种父类类型，不考虑继承关系； isinstance()会认为子类是一种父类类型，考虑继承关系； 如果要判断两个类型是否相同推荐使用isinstance() 语法1isinstance(object, classinfo) 参数 object: 实例对象; classinfo: 可以直接或间接是类名、基本类型或者由它们组成的元组； 说明： 对于基本类型来说classinfo可以是： 1int, float, bool, complex, str(字符串), list, dict(字典), set, tuple 要注意的是，classinfo的字符串是str而不是string，字典也是简写dict。 实例： 1234arg=123isinstance(arg, int) #输出Trueisinstance(arg, str) #输出Falseisinstance(arg, string) #报错 返回值如果对象的类型与classinfo的类型相同则返回True，否则返回False。 实例1234567&gt;&gt;&gt;a = 2&gt;&gt;&gt; isinstance (a,int)True&gt;&gt;&gt; isinstance (a,str)False&gt;&gt;&gt; isinstance (a,(str,int,list)) # 是元组中的一个返回 TrueTrue type与instance的区别12345678910class A: pass class B(A): pass isinstance(A(), A) # returns Truetype(A()) == A # returns Trueisinstance(B(), A) # returns Truetype(B()) == A # returns False]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的列表生成式]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python中的列表生成式顾名思义，列表生成式就是用来生成列表的特定语法形式的表达式。列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 语法格式基础语法格式1[exp for iter_var in iterable] 工作过程 迭代iterable中的每个元素； 每次迭代都先把结果赋值给iter_var，然后通过exp得到一个新的计算值； 最后所有通过exp得到的计算值以一个新的列表的形式返回； 相当于： 123L = []for iter_var in iterable: L.append(exp) 带过滤功能的语法格式1[exp for iter_var in iterable if_exp] 工作过程 迭代iterable中的每个元素，每次迭代都先判断if_exp表达式是否成立，即判断将iter_var代入if_exp后表达式的结果，如果为真则进行下一步，如果为假则进行下一次迭代； 把迭代结果赋值给iter_var，然后通过exp得到一个新的计算值； 最后把所有通过exp得到的计算值以一个新列表的形式返回； 相当于： 1234L = []for iter_var in iterable: if_exp: L.append(exp) 循环嵌套的语法格式1[exp for iter_var_A in iterable_A for iter_var_B in iterable_B] 工作过程 迭代iterable_A中的每个元素，但是每迭代iterable_A中的一个元素，就把iterable_B中的所有元素都迭代一遍； 将每次迭代的变量iterable_var_A和iterable_var_B传入表达式exp(当然可以只传入两者之一)，计算出结果； 最后把所有通过exp得到的结果以一个新的列表的形式返回； 应用场景其实列表生成式是Python中的一种“语法糖”，也就是说列表生成式是Python提供的一种生成列表的简洁形式，应用列表生成式可以快速生成一个新的list。它最主要的应用场景是：根据已存在的可迭代对象推导出一个新的list。 使用实例我们可以对几个生成列表的要求分别通过“不使用列表生成式”和“使用列表生成式”来实现，然后做个对比总结。 实例1：生成一个从3到10的数字列表12345# 不使用列表生成式list1 = list(range(3, 11))# 使用列表生成式list2 = [x for x in range(3, 11)] 实例2：生成一个2n+1的数字列表，n为从3到10的数字1234567# 不使用列表生成式list3 = []for n in range(3, 11): list3.append(2*n + 1) # 使用列表生成式list4 = [2*n + 1 for n in range(3, 11)] 实例3：过滤出指定的数字列表中的值大于20的元素123456789L = [3, 7, 11, 14, 19, 33, 26, 57, 99]# 不使用列表生成式list5 = []for x in L: if x &lt; 20: list5.append(x) # 使用列表生成式list6 = [x for x in L if x &lt; 20] 实例4：计算两个集合的全排列，并将结果保存至一个新的列表中1234567891011L1 = ['香蕉', '苹果', '橙子']L2 = ['可乐', '牛奶']# 不使用列表生成式list7 = []for x in L1: for y in L2: list7.append((x,y)) # 使用列表生成式list8 = [(x,y) for x in L1 for y in L2] 实例5：将一个字典转换成由一组元组组成的列表，元组的格式为(key, value)12345678910D = &#123;'Tom': 15, 'Jerry': 18, 'Peter': 13&#125;# 不使用列表生成式list9 = []for k, v in D.items(): list9.append((k, v)) # 使用列表生成式list10 = []list10 = [(k, v) for k, v in D.items()] 可见，在一些情况下使用列表生成式确实要方便、简洁很多，使用一行代码就搞定了。 列表生成式与map、filter等高阶函数对比列表生成式的功能与之前文章提到的map()和filter()高阶函数功能很像，比如下面两个例子： 实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样123456L = ['TOM', 'Peter', 10, 'Jerry']# 用列表生成式实现list1 = [x.lower() if isinstance(x, str) else x for x in L]# 用map()函数实现list2 = list(map(lambda x : x.lower() if isinstance(x, str) else x, L)) 实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除1234567L = ['TOM', 'Peter', 10, 'Jerry']# 用列表生成式实现list3 = [x.lower() for x in L if isinstance(x, str)] # 注意：这里for x in L相对if isinstance的先后位置，与上一个示例相比较# 用map()和filter()函数实现list4 = list(map(lambda x: x.lower(), filter(lambda x: isinstance(x, str), L))) 对于大部分需求来讲，使用列表生成式和使用高阶函数都能实现。但是map和filter等一些高阶函数在Python3.x中的返回值类型变成了Iterator(迭代器)对象，这对于那些元素数量很大或无限的可迭代对象来说显然是更合适的，因为可以避免不必要的内存空间浪费。 引用文章： Python之列表生成式、生成器、可迭代对象与迭代器 - 云游道士 - 博客园 列表生成式 - 廖雪峰的官方网站]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的装饰器]]></title>
    <url>%2F2018%2F11%2F04%2FPython%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Python中的装饰器装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。 它经常用于有切面需求的场景，比如：插入日志、性能检测、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能无关的雷同代码并继续重用。概括地讲，装饰器的作用就是为已经存在对象添加额外的功能。 先看一个简单例子： 12def foo(): print('i am foo') 现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码： 1234import loggingdef foo(): print('i am foo') logging.info("foo is running") 如果有些函数也有类似的需求，怎么做？都写一个logging在函数内？这样就造成了大量雷同的代码，为了减少重复写代码，可以这么做，重新定义一个函数专门处理日志，日志处理完之后再执行真正的业务代码： 123456789101112def use_logging(func): logging.warning("%s is running" % func.__name__) func() def bar(): print('i am bar')use_logging(bar)# output:# WARNING:root:bar is running# i am bar 逻辑上不难理解，但这样的话，我们每次都要将一个函数作为参数传递给use_logging函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行bar()，但是现在不得不改成use_logging(bar)。那么有没有更好的方式呢？当然有，答案就是装饰器。 简单装饰器123456789101112131415def use_logging(func): def wrapper(*args, **kwargs): logging.warning("%s is running" % func.__name__) return func(*args, **kwargs) return wrapperdef bar(): print('i am bar') bar = use_logging(bar)bar()# output:# WARNING:root:bar is running# i am bar 函数use_logging就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像bar被logging包起来，被装饰了。在这个例子中，函数进入和退出时，被称为一个横切面(Aspect)，这种编程方法称为面向切面的编程(Aspect-Oriented Programming)。 @符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作。 12345678910111213141516171819def use_logging(func): def wrapper(*args, **kwargs): logging.warning("%s is running" % func.__name__) return func(*args) return wrapper@use_loggingdef foo(): print('i am foo') @use_loggingdef bar(): print('i am bar') bar()# output:# WARNING:root:bar is running# i am bar 如上所示，使用@符号我们就可以省去bar = use_logging(bar)这一句了，直接调用bar()即可得到想要的结果。如果我们有其他的类似函数，我们就可以继续调用装饰器来修饰函数，而不用重新修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。 装饰器在Python中使用如此方便都要归功于Python的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他的变量，可以作为返回值，可以被定义在另一个函数内。 带参数的装饰器装饰器还有更大的灵活性，例如带参数的装饰器：在上面的装饰器调用中，比如@use_logging，该装饰器唯一的参数就是执行业务的函数。装饰器的语法云溪我们在调用时，提供其他参数比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。 123456789101112131415161718def use_logging(level): def decorator(func): def wrapper(*args, **kwargs): if level == "warn": logging.warning("%s is running" % func.__name__) return func(*args) return wrapper return decorator@use_logging(level="warn")def foo(name='foo'): print("i am %s" % name) foo()# output:# WARNING:root:bar is running# i am bar 上面的use_logging是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我们使用@use_logging(level=&quot;warn&quot;)调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。 类装饰器再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大，高内聚，封装性等优点。使用类装饰器还可以依赖类内部的__call__方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。 12345678910111213141516171819class Foo(object): def __init__(self, func): self._func = func def __call__(self): print('class decorator running') self._func() print('class decorator ending') @Foodef bar(): print('bar') bar()# output:# class decorator running# bar# class decorator ending functools.wraps使用装饰器极大地复用了代码，但是它有个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子： 装饰器： 12345def logged(func): def with_logging(*args, **kwargs): print(func.__name__ + "was called") return func(*args, **kwargs) return with_logging 函数： 1234@loggeddef f(x): '''do some math''' return x + x * x 该函数完全等价于： 12345def f(x): '''do some math''' return x + x * xf = logged(f) 不难发现，函数f被with_logging替代了，当然它的docstring、__name__就变成了with_logging函数的信息了。 123456print(f.__name__)print(f.__doc__)# output:# with_logging# None 这个问题就比较严重了，好在我们有function.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了。 12345678910111213141516171819from functools import wrapsdef logged(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + "was called") return func(*args, **kwargs) return with_logging@loggeddef f(x): '''do some math''' return x + x * xprint(f.__name__)print(f.__doc__)# output:# f# do some math 内置装饰器@staticmethod、@classmethod、@property 装饰器的顺序： 1234@a@b@cdef f(): 等效于 1f = a(b(c(f))) 引用资料： 如何理解Python装饰器？ - 知乎]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的Lambda函数及其用法]]></title>
    <url>%2F2018%2F11%2F01%2FPython%E4%B8%AD%E7%9A%84Lambda%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中的Lambda函数及其用法Lambda函数又称为匿名函数，匿名函数就是没有名字的函数。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就可以将其定义为匿名函数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。 先来看个简单的lambda函数： 12&gt;&gt;&gt; lambda x, y : x + y&lt;function &lt;lambda&gt; at 0x102bc1c80&gt; x和y是函数的两个参数，冒号后面的表达式是函数的返回值，很明显这个匿名函数就是在求两个变量的和，但作为一个函数，没有名字如何使用呢？ 这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能。 12345&gt;&gt;&gt; add = lambda x, y : x+y&gt;&gt;&gt; add&lt;function &lt;lambda&gt; at 0x102bc2140&gt;&gt;&gt;&gt; add(1,2)3 它等同于常规函数 1234567&gt;&gt;&gt; def add1(x, y):... return x+y...&gt;&gt;&gt; add1&lt;function add1 at 0x102bc1c80&gt;&gt;&gt;&gt; add1(1,2)3 lambda函数的使用场景(函数式编程)sorted函数例如：一个整数列表，要求按照列表中元素的绝对值大小升序排列。 123&gt;&gt;&gt; list1 = [3,5,-4,-1,0,-2,-6]&gt;&gt;&gt; sorted(list1, key=lambda x: abs(x))[0, -1, -2, 3, -4, 5, -6] 排序函数sorted支持接收一个函数作为参数，该参数作为sorted的排序依据，这里按照列表元素的绝对值进行排序。 当然，也可以通过普通函数来实现： 12345&gt;&gt;&gt; def foo(x):... return abs(x)...&gt;&gt;&gt; sorted(list1, key=foo)[0, -1, -2, 3, -4, 5, -6] 只不过是使用这种方式，代码看起来不够Pythonic而已。 lambda：这是Python支持的一种有趣的语法，它允许你快速定义单行的最小函数，可以用在任何需要函数的地方: 12345&gt;&gt;&gt; add = lambda x,y : x+y&gt;&gt;&gt; add(5,6)11&gt;&gt;&gt; (lambda x,y:x+y)(5,6)11 map,reduce,filter函数123456789101112# 求1~20的平方&gt;&gt;&gt; list(map(lambda x:x*x,range(1,21))) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]# 求1~20之间的偶数&gt;&gt;&gt; list(filter(lambda x:x%2 == 0,range(1,21))) [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]# 求1~100之和,再加上10000&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x,y:x+y,range(1,101),10000)15050 闭包闭包：一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域也依然能被访问到。 看一个用lambda函数作为闭包的例子： 123456&gt;&gt;&gt; def add(n):... return lambda x:x+n # 将匿名函数作为返回值返回...&gt;&gt;&gt; add2 = add(5)&gt;&gt;&gt; add2(15)20 这里的lambda函数就是一个闭包，在全局作用域范围中，add2(15)可以正常执行且返回值为20。之所以返回20是因为在add局部作用域中，变量n的值在闭包的作用下也可以被访问到。 参考资料 匿名函数 - 廖雪峰的官方网站 深入理解Lambda函数及其用法 - 碧水幽幽泉 - 博客园]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的高阶函数]]></title>
    <url>%2F2018%2F10%2F29%2FPython%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python中的高阶函数在熟悉了Python基础知识后，我们已经可以做一些脚本开发，或者简单的程序。然而，当我们开发较为复杂的程序时，仅使用基础知识内容就会显得比较吃力。这时，了解Python中的一些高级特性会使我们的开发过程变得简单和快乐。 在函数式编程中，我们可以将函数当做变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为高阶函数(Higher-order-Functions)。 看一个简单的例子： 12def func(g, arr): return [g(x) for x in arr] 上面的代码中func是一个高阶函数，它接收两个参数，第一个参数是函数，第二个参数是数组，func的功能是将函数g逐个作用于数组arr上，并返回一个新的数组。比如，我们可以这样用： 123456789def double(x): return 2 * x def square(x): return x * xlist = [1, 2, 3, 4]arr1 = func(double, list) # arr1 = [2, 4, 6, 8]arr2 = func(square, list) # arr2 = [1, 4, 9, 16] 说到高阶函数，就不得不提到闭包，这里介绍一下Python中闭包的定义： 如果在一个内部函数里，对外部作用域(但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包(closure)。 就拿此例来说，内部函数double中包含了对函数func中局部变量list的引用，这就是闭包。 map reduce filter sorted是Python中较为常用的内置高阶函数，它们为函数式编程提供了不少便利。 说明：本文介绍的内置高阶函数的定义可能会因为Python版本的不同而有所不同，文章以Python3.x版本中的定义为标准。 mapmap函数的使用形式如下： 1map(function, iterable, ...) 注意：这里函数一定要作为map的第一个参数，而不是第二个参数，否则会产生报错。 解释：function函数会作用于可迭代对象的每一个元素，生成结果，并返回一个迭代器。更加具体一点说就是map函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到Iterable的每个元素，并把结果作为新的Iterator返回。 举例说明，比如我们一个函数f(x)=x^2，要把这个函数作用在一个list[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现。 现在，我们用Python代码实现： 123456&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] map传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此需要通过list()函数让它把整个序列都计算出来并返回一个list。 你可能会想，不需要map函数，写一个循环，也可以计算出结果： 1234L = []for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: L.append(f(n))print(L) 的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？明显可读性就差了很多。 所以，map作为高阶函数，体现了Python的设计原则优雅、明确、简单，事实上它把运算规则抽象化。因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把list中的所有数字转化为字符串格式： 12&gt;&gt;&gt; list(map(str, [1, 2, 3, 4]))['1', '2', '3', '4'] 只需一行代码。 看一些简单的例子： 12345678910111213&gt;&gt;&gt; def square(x):... return x * x&gt;&gt;&gt; map(square, [1, 2, 3, 4])&lt;map at 0x106adfe48&gt;&gt;&gt;&gt; list(map(square, [1, 2, 3, 4]))[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4])) # 使用 lambda[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x, y: x + y, [1, 2, 3, 4], [5, 6, 7, 8]))[6, 8, 10, 12] 再来看个复杂一点例子： 1234567891011121314151617def double(x): return 2 * xdef triple(x): return 3 *xdef square(x): return x * xfuncs = [double, triple, square] # 列表元素是函数对象# 相当于 [double(4), triple(4), square(4)]value = list(map(lambda f: f(4), funcs))print(value)output:[8, 12, 16] 最后我想要说明一点，迭代器有一个特点，就是所有的迭代器对象都可以作为next()内置函数的参数调用，每调用一次，就按角标顺序返回一个值，还是用代码讲吧： 123456iter = map(lambda x: x * x, [1, 2, 3, 4])print(next(iter)) # 打印值为：1print(next(iter)) # 打印值为：4print(next(iter)) # 打印值为：9print(next(iter)) # 打印值为：16print(next(iter)) # 抛出StopIteration 异常 reducereduce函数的使用形式如下： 1reduce(function, iterable[, initializer]) 解释：reduce函数必须接受两个参数，先将iterable的前两个item传给function，即function(item1, item2)，函数的返回值和iterable的下一个item再传给function，即function(function(item1, item2), item3)，如此迭代，直到iterable没有元素，如果有initializer，则作为初始值调用。 也就是说： 12reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)# 列表中是以从左到右作为优先顺序 看一些例子，就能很快理解了。 12345678910111213&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4]) # 相当于 ((1 * 2) * 3) * 424&gt;&gt;&gt; reduce(lambda x, y: x - y, [8, 5, 1], 20) # ((20 - 8) - 5) - 16&gt;&gt;&gt; f = lambda a, b: a if (a &gt; b) else b # 两两比较，取最大值&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])10&gt;&gt;&gt; def fn(x, y): # 把序列[1, 3, 5, 7, 9]变换成整数13579... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 filterfilter函数用于过滤元素，它的使用形式如下： 1filter(function, iterable) 解释：和map类似，filter也接收一个函数和一个序列。但和map不同的是，filter把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。将function依次作用于iterable的每个item上，即function(item)，用function返回值为True的item构成iterator作为filter的最终返回值。 看一些例子。 12345678910&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; even_num[2, 4, 6]&gt;&gt;&gt; odd_num = list(filter(lambda x: x % 2, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; odd_num[1, 3, 5]&gt;&gt;&gt; list(filter(lambda x: x &lt; 'g', 'hijack'))'ac'&gt;&gt;&gt; filter(lambda x: x &lt; 'g', 'hijack')&lt;filter object at 0x1034b4080&gt; # python3 可见用filter这个高阶函数，关键在于正确实现一个“筛选”函数。 注意到filter函数返回的同样是一个Iterator，也就是一个惰性序列，所以要强迫filter完成计算结果，需要用list()函数获得所有结果。 sortedsorted函数用于对list进行排序，它的使用形式如下： 1sorted(iterable, *, key=None, reverse=False) 解释：sorted有两个可选参数，必须指定为关键字参数。将key指定的函数作用于iterable的每一个元素上，并根据key函数返回的结果进行排序，最终返回一个新的排序列表。key默认值为None，即直接比较元素大小。 reverse是一个布尔值。如果设置为True，则列表元素将按照比较结果相反的方式进行排序。 看一些例子： 12345678910&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob']&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo']&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且核心代码可以保持得非常简洁。 小结 可接受其他函数作为参数的函数称为高阶函数； map reduce filter sorted为函数式编程提供了不少便利，可使代码变得更简洁； 通过map()来对Iterable中的每个元素进行相同的函数处理最终返回一个Iterator。 reduce()类似栈的思想，先让栈顶的两个元素出栈作为函数的两个参数，再将函数的返回值入栈，然后再让栈顶两个元素出栈，不断循环下去，直到栈里没有元素为止。 filter()的作用是从一个序列中筛选出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。 sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。 参考资料 高阶函数 - 廖雪峰的官方网站 map/reduce/filter - Python 之旅 - 极客学院Wiki 高阶函数 - Python 之旅 - 极客学院Wiki Python笔记(二)：高级特性之高阶函数 - 简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中@classmethod和@staticmethod的区别]]></title>
    <url>%2F2018%2F10%2F27%2FPython%E4%B8%AD%40classmethod%E5%92%8C%40staticmethod%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中@classmethod和@staticmethod的区别接上一篇介绍Python中@staticmethod和@classmethod的用法的文章。虽然@classmethod和@staticmethod非常相似，但两个修饰符的使用情况仍略有不同。 从它们的使用上来看： @classmethod必须引用一个类对象作为第一个参数，即第一个参数需要是表示自身类的cls参数。同时@classmethod因持有cls参数，所以可以调用类的属性，类的方法，实例化对象等，避免硬编码。 @staticmethod则可以完全没有参数，但在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名()。 示例1234567891011121314151617181920class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split("-")) date1 = cls(day, month, year) return date1 @staticmethod def is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split("-")) return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999 date2 = Date.from_string("27-10-2018")is_date = Date.is_date_valid("27-10-2018") 解释让我们假设这样一个类的例子，用来处理日期信息(这将是我们的样板)： 12345class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year 显然，这个类可以用来存储关于某些日期的信息(没有时区信息；假设所有日期都以UTC表示)。 这个类中有__init__，它是Python类实例的初始化方法，它接收参数作为类实例方法，具有第一个非可选参数self(作为对新创建实例的引用)。 Class Method我们有一些任务，通过使用@classmethod可以很好地完成它们。 假设我们想要创建许多Date类实例，其日期信息来自外部输入(编码格式为’dd-mm-year’的字符串)，并假设我们必须在项目源代码的不同位置执行此操作。 所以我们这里必须做到： 解析输入的字符串以接收日、月、年作为三个整数变量或由这些变量组成的三元组。 通过将上面求到的值传递给初始化调用来创建Date类实例。 代码看起来会是这样： 12day, month, year = map(int, string_date.split('-'))date1 = Date(day, month, year) 如果使用@classmethod修饰符写在类中，将会是： 1234567 @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split('-')) date1 = cls(day, month, year) return date1date2 = Date.from_string('27-10-2018') 让我们更仔细地看看上面的代码实现，并回想一下我们做了什么？ 我们在一个地方实现了日期字符串解析函数，现在它可以重用。 将日期字符串解析函数封装在类中并且工作正常(当然你可以在其他地方实现日期字符串解析作为单个函数，但这个解决方案更适合OOP范例)。 cls是一个保存类本身的对象，而不是类的实例。这很酷😎，因为如果我们继承Date类，所有子类也会定义from_string()。 Static Method@staticmethod确实与@classmethod很相似，但@staticmethod不需要任何强制性参数(如类方法或实例方法)。 让我们看看下一个任务(下一个用例): 假设我们有一个日期字符串，我们想要以某种方式进行验证它是否符合要求的格式。此任务也需要封装在Date类中，但不需要实例化它。 这里使用@staticmethod就会很有效。让我们看一下代码： 1234567@staticmethoddef is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split('-')) return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999# usage:is_date = Date.is_date_valid('27-10-2018') 运行上述代码得到is_date是个boolen型变量，而非is_date_valid函数返回的day，month，year三个整型数据。 因此，我们可以从@staticmethod的使用中看到，我们无法访问类的内容——它基本上只是一个函数，在语法上称为方法，无法访问对象及其内部(字段和其他类方法)。而使用@classmethod却可以做到。 补充上面的文章已经很全面地总结了@classmethod和@staticmethod的区别。在这里我想强调当你创建构造函数时，你应该选择@classmethod而不是@staticmethod的另一个原因。在上面的例子中，使用@classmethod from_string()作为Factory，接收不符合__init__要求的参数创建Date类实例。使用@staticmethod可以完成同样的操作，如下面代码所示： 12345678910111213141516171819202122class Date: def __init__(self, month, day, year): self.month = month self.day = day self.year = year def display(self): return "&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format(self.month, self.day, self.year) @staticmethod def millenium(month, day): return Date(month, day, 2000)new_year = Date(1, 1, 2013) # Creates a new Date objectmillenium_new_year = Date.millenium(1, 1) # also creates a Date object. # Proof:new_year.display() # "1-1-2013"millenium_new_year.display() # "1-1-2000"isinstance(new_year, Date) # Trueisinstance(millenium_new_year, Date) # True 运行结果显示new_year和millenium_new_year都是Date类实例。 但是，如果仔细观察就会发现，millenium_new_year是以硬编码的方式创建的Date类实例。这意味着即使一个类继承Date类，该子类仍将创建普通的Date对象即父类对象，而不具有该子类本身的任何属性。请参阅以下示例代码： 12345678910111213class DateTime(Date): def display(self): return "&#123;0&#125;-&#123;1&#125;-&#123;2&#125; - 00:00:00PM".format(self.month, self.day, self.year)datetime1 = DateTime(10, 10, 1990)datetime2 = DateTime.millenium(10, 10)isinstance(datetime1, DateTime) # Trueisinstance(datetime2, DateTime) # Falsedatetime1.display() # returns "10-10-1990 - 00:00:00PM"datetime2.display() # returns "10-10-2000" because it's not a DateTime object but a Date object. Check the implementation of the millenium method on the Date class DateTime类继承Date类，因此具有Date类的millenium()方法。datetime2通过调用DateTime继承来的millenium()方法来创建DateTime类实例。然而代码却显示datetime2并不是DateTime类实例(isinstance(datetime2, DateTime) # False)。怎么回事？这是因为使用了@staticmethod修饰符。 在大多数情况下，这是你不希望出现的。如果你想要的是一个”完整“的类实例，并且是通过调用它的父类方法所创建的话，那么@classmethod就是你所需要的。 将Date.millenium()重写为(这是上述代码中唯一改变的部分)： 123@classmethoddef millenium(cls, month, day): return cls(month, day, 2000) 确保该类的创建不是通过硬编码。cls可以是任何子类，生成的对象将正确地成为cls的实例。我们来试试吧： 123456789datetime1 = DateTime(10, 10, 1990)datetime2 = DateTime.millenium(10, 10)isinstance(datetime1, DateTime) # Trueisinstance(datetime2, DateTime) # Truedatetime1.display() # "10-10-1990 - 00:00:00PM"datetime2.display() # "10-10-2000 - 00:00:00PM" 看吧，用@classmethod替代@staticmethod你不希望出现的情况就会消失。使用了@staticmethod修饰符定义构造函数就是问题出现的关键。 文章的内容有点多，可能需要花一些时间进行理解，最后提供一个小示例帮助大家加深记忆一下@classmethod和@staticmethod的主要不同。 1234567891011121314151617181920212223242526class A(object): bar = 1 def foo(self): print 'foo' @staticmethod def static_foo(): print 'static_foo' print A.bar @classmethod def class_foo(cls): print 'class_foo' print cls.bar cls().foo() A.static_foo()A.class_foo()output:static_foo1class_foo1foo 引用文章： 飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客 python - Meaning of @classmethod and @staticmethod for beginner? - Stack Overflow]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中@staticmethod和@classmethod的用法]]></title>
    <url>%2F2018%2F10%2F27%2FPython%E4%B8%AD%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中@staticmethod和@classmethod的用法一般来说，调用某个类的方法，需要预先生成一个实例，再通过实例调用方法。Java中有静态方法，可以使用类直接进行调用。Python中提供了两个修饰符@staticmethod和@classmethod以达到类似效果，使用它们就可以不需要实例化，直接类名.方法名()来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类中，同时有利于命名空间的整洁。 @staticmethod@staticmethod声明方法为静态方法，直接通过类名.方法名()调用。经过@staticmethod修饰的方法，不需要self参数，其使用方法和直接调用函数一样。 1234567891011121314151617181920#直接定义一个test()函数def test(): print "i am a normal method!" #定义一个类，其中包括一个类方法，采用@staticmethod修饰 class T: @staticmethod def static_test(): # 没有self参数 print "i am a static method!" if __name__ == "__main__": test() T.static_test() T().static_test()output:i am a normal method!i am a static method!i am a static method! @classmethod@classmethod声明方法为类方法，直接通过类名.方法名()调用。经过@classmethod修饰的方法，不需要self参数，但是需要一个标识类本身的cls参数。 12345678910111213class T: @classmethod def class_test(cls): # 必须有cls参数 print "i am a class method" if __name__ == "__main__": T.class_test() T().class_test()output:i am a class methodi am a class method @classmethod另一个实用的用法：在不改变已经写好的类里面的方法的情况下，对输入的数据进行处理。 12345678910111213141516# 输出年月日，正常的情况下class demo1: def __init__(self, year=0, month=0, day=0): self.year = year self.month = month self.day = day def out_date(self): return "year: %d, month: %d, day: %d" % (self.year, self.month, self.day) year = 2018month = 10day = 27demo1 = demo1(year, month, day)print(demo1.out_date()) # year: 2018, month: 10, day: 27 1234567891011121314151617181920212223242526# 如果用户输入的是2018-10-27格式，需要在输出前处理一下，就可以使用classmethod达到想要的效果class demo2: def __init__(self, year=0, month=0, day=0): self.year = year self.month = month self.day = day def out_date(self): return "year: %d, month: %d, day: %d" % (self.year, self.month, self.day) @classmethod def pre_out(cls, date_string): year, month, day = map(int, date_string.split("-")) return cls(year, month, day) date = "2018-10-27"year = 2017month = 7day = 7try: demo2 = demo2.pre_out(date)except: demo2 = demo2(year, month, day) print(demo2.out_date()) # year: 2018, month: 10, day: 6 小结 @staticmethod不需要表示自身对象的self参数和自身类的cls参数，就跟使用函数一样。 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 在Python中类和实例都是对象，都占用了内存空间，合理使用@staticmethod和@classmethod修饰符，就可以不经过实例化直接使用类的方法了。 引用文章： Python @staticmethod@classmethod用法 - sinat_34079973的博客 - CSDN博客 飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客 classmethod的两个实用用法 - 简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中super()函数的用法及其说明]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E4%B8%ADsuper()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中super()函数的用法及其说明为了调用父类(超类)的一个方法，可以使用super()函数，比如： 12345678class A: def spam(self): print('A.spam')class B(A): def spam(self): print('B.spam') super().spam() # Call parent spam() super()函数的一个常见用法是在__init__()中确保父类被正确的初始化： 12345678class A: def __init__(self): self.x = 0class B(A): def __init__(self): super().__init__() self.y = 1 说明__init__()函数：定义类的时候，若是添加__init__()函数，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初始化。 super()的另外一个常见用法出现在覆盖Python特殊方法的代码中，比如： 1234567891011121314class Proxy: def __init__(self, obj): self._obj = obj # Delegate attribute lookup to internal obj def __getattr__(self, name): return getattr(self._obj, name) # Delegate attribute assignment def __setattr__(self, name, value): if name.startswith('_'): super().__setattr__(name, value) # Call original __setattr__ else: setattr(self._obj, name, value) 实际上，大家对于在Python中如何正确使用super()函数普遍知之甚少。你有时候会看到像下面这样直接调用父类的一个方法： 12345678class Base: def __init__(self): print('Base.__init__')class A(Base): def __init__(self): Base.__init__(self) print('A.__init__') 尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。比如，考虑下面的情况： 12345678910111213141516171819class Base: def __init__(self): print('Base.__init__')class A(Base): def __init__(self): Base.__init__(self) print('A.__init__')class B(Base): def __init__(self): Base.__init__(self) print('B.__init__')class C(A,B): def __init__(self): A.__init__(self) B.__init__(self) print('C.__init__') 运行这段代码后就会发现Base.__init__被调用两次，如图所示： 123456&gt;&gt;&gt; c = C()Base.__init__A.__init__Base.__init__B.__init__C.__init__ 可能两次调用Base.__init__()没什么坏处，但有时候却不是。另一方面，假设在代码中换成使用super()，结果就很完美了： 123456789101112131415161718class Base: def __init__(self): print('Base.__init__')class A(Base): def __init__(self): super().__init__() print('A.__init__')class B(Base): def __init__(self): super().__init__() print('B.__init__')class C(A,B): def __init__(self): super().__init__() # Only one call to super() here print('C.__init__') 运行这个新版本后，你会发现Base.__init__()方法只会被调用一次： 12345&gt;&gt;&gt; c = C()Base.__init__B.__init__A.__init__C.__init__ 所以说，super()是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序(MRO)、重复调用(钻石继承)等种种问题。 说明：MRO就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表，下面会有更详尽的介绍。 为了弄清它的原理，我们需要花点时间解释下Python是如何实现继承的。对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。这个MRO列表就是一个简单的所有基类的线性顺序表。例如： 123&gt;&gt;&gt; C.__mro__(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;) 为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则： 子类会先于父类被检查 多个父类会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择，选择第一个父类 老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。 当你使用super()函数时，Python会在MRO列表上继续搜索下一个类。只要每个重定义的方法统一使用super()并只调用它一次，那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。这也是为什么在第二个例子中你不会调用两次Base.__init__()的原因。 super()有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类： 1234class A: def spam(self): print('A.spam') super().spam() 如果你试着直接使用这个类就会出错： 1234567&gt;&gt;&gt; a = A()&gt;&gt;&gt; a.spam()A.spamTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 4, in spamAttributeError: 'super' object has no attribute 'spam' 但是，如果你使用多继承的话看看会发生什么： 1234567891011&gt;&gt;&gt; class B:... def spam(self):... print('B.spam')...&gt;&gt;&gt; class C(A,B):... pass...&gt;&gt;&gt; c = C()&gt;&gt;&gt; c.spam()A.spamB.spam 你可以看到在类A中使用super().spam()实际上调用的是与类A毫无关系的类B中的spam()方法。这个用类C的MRO列表就可以完全解释清楚： 123&gt;&gt;&gt; C.__mro__(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,&lt;class 'object'&gt;) 在定义混入类的时候这样使用super()是很普遍的。 然而，由于super()可能会调用不是你想要的方法，你应该遵循一些通用原则。首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。这样可以确保super()调用一个非直接父类方法时不会出错。其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。 在Python社区内对于super()的使用有时候会引来一些争议。尽管如此，如果一切顺利的话，你应该在你最新的代码中使用它。Raymond Hettinger为此写了一篇非常好的文章，有兴趣的话可以去查查看，文章通过大量的例子向我们解释了为什么super()是极好的。 最后通过一个很好的实例帮助大家加深一下记忆： 12345678910111213141516171819202122class FooParent(object): def __init__(self): self.parent = 'I\'m the parent.' print ('Parent') def bar(self,message): print ("%s from Parent" % message) class FooChild(FooParent): def __init__(self): # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类B的对象 FooChild 转换为类 FooParent 的对象 super(FooChild,self).__init__() print ('Child') def bar(self,message): super(FooChild, self).bar(message) print ('Child bar fuction') print (self.parent) if __name__ == '__main__': fooChild = FooChild() fooChild.bar('HelloWorld') 执行结果： 12345ParentChildHelloWorld from ParentChild bar fuctionI&apos;m the parent. 引用文章： Python super() 函数 | 菜鸟教程 8.7 调用父类方法 — python3-cookbook 3.0.0 文档]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用攻略：添加搜索功能]]></title>
    <url>%2F2018%2F10%2F26%2FHexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Hexo使用攻略：添加搜索功能本教程针对的是Mac环境 前言当博文越来越多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博文上去了，所以添加一个站内搜索功能是很有必要的。 Hexo适配多款搜索插件，个人感觉”Local Search”已满足日常需要，所以下面介绍为Hexo添加”Local Search”搜索插件的过程。 安装插件在命令行中cd到自己的hexo文件夹下(例：/Users/rilzob/hexo)，执行npm install hexo-generator-searchdb --save命令进行安装，等待安装完成。 修改站点配置文件修改当前目录下的_config.yml文件(例：/Users/rilzob/hexo/_config.yml)，新增以下内容到该文件内的任意位置。 123456# Searchsearch: path: search.xml field: post format: html limit: 10000 注意：每个冒号后面都有空格 修改主题配置文件修改主题目录下的_config.yml文件(例：/Users/rilzob/hexo/themes/xxx/_config.yml)，找到该文件内的 1234# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: false 代码段，将其修改为： 1234# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true 即将enable: false修改为enable: true。 重新部署依旧在命令行中进行操作，在hexo文件夹下依次执行hexo g,hexo server和hexo deploy指令即可。这样搜索功能就添加成功了。 引用文章: 1.Hexo博客添加搜索功能 | IT范儿 2.hexo博客添加搜索功能 - qq_40265501的博客 - CSDN博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用攻略：添加分类及标签]]></title>
    <url>%2F2018%2F10%2F25%2FHexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Hexo使用攻略：添加分类及标签本教程针对的是Mac环境 Hexo创建”分类”选项生成”分类”页并添加type属性 打开命令行，cd进入博客所在文件夹。执行命令hexo new page categories，来新建一个页面，并命名为categories。成功后会提示：INFO Created: ~/hexo/source/categories/index.md 根据上面的路径找到index.md这个文件，打开后默认内容如下： 1234---title: categoriesdate: 2018-10-25 20:11:37--- 编辑新创建的页面，添加type: &quot;categories&quot;到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的： 12345---title: categoriesdate: 2018-10-25 20:11:37type: &quot;categories&quot;--- 保存并关闭文件。 给文章添加”categories”属性 打开需要添加分类的文章，为其添加categories属性。下方的categories: Python表示添加这篇文章到“Python”这个分类中。 注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。 1234---title: Python中*args和**kwargs的用法总结categories: Python--- 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加分类选项 cd进/hexo/themes/hexo-theme-next-5.1.4文件夹内，编辑该目录下的_config.yml文件(把链接加上)，将源代码: 12345678910111213menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 改为: 12345678910111213menu: home: / || home #about: /about/ || user #tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 即将menu中的categories:/categories || th的注释去掉，然后保存并退出。 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令，即可看到菜单栏中新增了一个Categories选项。 至此，成功给文章添加分类，点击Index上的Categories可以看到所有的分类情况，再点击该分类就可以看到该分类下的所有文章。当然，前提是添加了categories: xxx字段。 Hexo创建”标签”选项生成”标签”页并添加type属性 打开命令行，cd进入博客所在文件夹。执行命令hexo new page tags，来新建一个页面，并命名为tags。成功后会提示：INFO Created: ~/hexo/source/tags/index.md 根据上面的路径找到index.md这个文件，打开后默认内容如下： 1234---title: tagsdate: 2018-10-25 21:11:00--- 编辑新创建的页面，添加type: &quot;tags&quot;到内容中，主题将自动为这个页面显示所有分类，添加后是这样的： 12345---title: tagsdate: 2018-10-25 21:11:00type: &quot;tags&quot;--- 保存并关闭文件。 给文章添加”tags”属性 打开需要添加标签的文章，为其添加tags属性。下方的tags: Django表示添加这篇文章到“Django”这个标签中。 1234---title: Python中*args和**kwargs的用法总结tags: Django--- 回到hexo文件夹下，依次执行hexo g， hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加标签选项 cd进/hexo/themes/hexo-theme-next-5.1.4文件夹内，编辑该目录下的_config.yml文件(把链接加上)，将源代码: 12345678910111213menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 改为: 12345678910111213menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 即将menu中的tags: /tags/ || tags的注释去掉，然后保存并退出。 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令，即可看到菜单栏中新增了一个tags选项。 引用文章： 1.Hexo使用攻略-添加分类及标签 | linlif-blog 2.hexo怎么在菜单上添加页面和分类呢？ - SegmentFault 思否 3.hexo next 为文章添加分类 | 学而后知不足]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中*args和**kwargs的用法总结]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E4%B8%AD*args%E5%92%8C**kwargs%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中*args和**kwargs的用法总结一、基本概念Python支持可变参数，最简单的方法莫过于使用默认参数。 123456789101112131415def test_defargs(one, two=2): # 参数one没有默认值，two的默认值为2 print('Required argument:', one) print('Optional argument:', two) test_defargs(1)'''Required argument: 1Optional argument: 2'''test_defargs(1, 3)'''Required argument: 1Optional argument: 3''' 另一种达到可变参数(Variable Argument)的方法： 使用*args和**kwargs语法。 *args是可变的位置参数(postional arguments)列表； **kwargs是可变的关键词参数(keyword arguments)列表； 并且规定位置参数必须位于关键词参数之前，即*args必须位于**kwargs之前。 二、位置参数以下是用位置参数正确调用函数的实例： 12345678910def print_hello(name, sex): sex_dict = &#123;1: '先生', 2: '女士'&#125; print('Hello %s %s, welcome to Python World!' % (name, sex_dict.get(sex, '先生'))) # if no such a key, print '先生' print_hello('Chen', 2) # 位置参数要求先后顺序，对应name和sexprint_hello('Chen', 3) # 两个参数的顺序必须一一对应，且少一个参数都不可以'''Hello Chen 女士, welcome to Python World!Hello Chen 先生, welcome to Python World!''' 三、关键字参数用于函数调用，通过“键-值”形式加以指定。 使用关键字参数可以让函数更加清晰，容易使用，同时也清除了参数的顺序需求。 以下是用关键字参数正确调用函数的实例： 123print_hello('Chen', sex=1) # 有位置参数时，位置参数必须在关键字参数的前面# print_hello(1, name='Chen') # Python 3.x中这种写法是错误的print_hello(name='Chen', sex=1) # 关键字参数之间不存在先后顺序的,等价于print_hello(sex=1, name='Chen') 以下是错误的调用方式： 12# print_hello(name='Chen', 1) # 有位置参数时，位置参数必须在关键字参数前面# print_hello(sex=1, 'Chen') 四、可变参数顾名思义，可变参数就是传入的参数个数是可变的，可以是任意个。*args和**kwargs两者都是Python中的可变参数。 1.可变位置参数*argsPython中规定参数前带*的，称为可变位置参数，只是我们通常称这个可变位置参数为*args而已，叫其他的也是一样的。 以数学题为例，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。 要定义这个函数，必须确定输入的参数。由于参数个数不确定，我们可以首先想到把a，b，c……作为一个list或者tuple传进来，这样函数就可以定义为： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： 1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc([1, 3, 5, 7])84 所以，为了方便起见我们把函数的参数改为可变位置函数： 12345def calc(*numbers) # 可变位置参数 sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变位置参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt;calc(1,2)5&gt;&gt;&gt;calc()0 如果已经有一个list或tuple，要调用一个可变位置参数怎么办？可以这么做： 123&gt;&gt;&gt;nums = [1, 2, 3]&gt;&gt;&gt;calc(nums[0], nums[1], nums[2])14 这种做法当然是可行的，问题是太繁琐了，所以Python允许在list或tuple前面加一个*，把list或tuple的元素变成可变位置参数传进去： 123&gt;&gt;&gt;nums = [1, 2, 3]&gt;&gt;&gt;calc(*nums)14 总而言之，*args用来表示函数接收可变长度的非关键字参数列表作为函数的输入。我们可以通过以下这个例子进一步理解*args: 123456def test_args(normal_arg, *args): print('first normal arg:' + normal_arg) for arg in args: print('another arg through *args:' + arg) test_args("normal", "python", "java", "C#") 上面代码的执行结果如下： 1234first normal arg: normalanother arg through *args : pythonanother arg through *args : javaanother arg through *args :C# 2.可变关键字参数**kwargs同理，Python中规定参数前带 的，称为可变关键字参数，通常用kwargs表示。 **kwargs表示函数接收可变长度的关键字参数字典作为函数的输入。当我们需要函数接收带关键字的参数作为输入的时候，应当使用**kwargs。我们可以通过以下的例子进一步理解**kwargs: 123456789def test_kwargs(**kwargs): if kwargs is not None: for key, value in kwargs.iteritems(): print("&#123;&#125; = &#123;&#125;".format(key,value)) # Or you can visit kwargs like a dict() object # for key in kwargs: # print("&#123;&#125; = &#123;&#125;".format(key, kwargs[key])) test_kwargs(name="python", value="5") 以上代码的执行效果如下： 12name = pythonvalue = 5 以上例子只是*args和**kwargs基本使用的例子。下面再给出一个用*args和**kwargs来定义能够接受列表输入和字典输入的函数的例子。 3.使用*args和**kwargs来调用函数比如我们有如下接受普通输入参数的函数： 123456def normal_func(arg1, arg2, arg3): print("arg1: " + arg1) print("arg2: " + arg2) print("arg3: " + arg3)normal_func("python", 1, 3) 使用*args和**kwargs来调用这个函数的代码如下： 1234567# 使用*argsargs_list = ("python", 1, 3)normal_func(*args_list)# 使用**kwargskwargs_dict = &#123;"arg3": 3, "arg1": "python", "arg2": 1&#125;normal_func(**kwargs_dict) 以上三段代码的输出均为： 123arg1: pythonarg2: 1arg3: 3 引用文章： 1.Python中的 *args 和 **kwargs - 简书 2.函数的参数 - 廖雪峰的官方网站 3.python参数传递的*args和**kwargs - 简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过Hexo将文章上传到git.io的方法]]></title>
    <url>%2F2018%2F10%2F21%2F%E9%80%9A%E8%BF%87Hexo%E5%B0%86%E6%96%87%E7%AB%A0%E4%B8%8A%E4%BC%A0%E5%88%B0git.io%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通过Hexo将文章上传到git.io的方法 编辑文章，生成markdown文件，并将文章放到/hexo/source/_posts目录下，一个md文件对应一篇博客文章。 修改文章头部： 123456---title: #博客标题date: #博客发布时间tags: #博客分类标签categories: #博客目录--- 在命令行中cd到_posts目录下并执行hexo generate命令(生成静态页面)。 再执行hexo server命令(本地上传文章)，上传后可以到http://localhost:4000/ 预览博客效果。 最后执行hexo deploy命令，上传文章到github.io上就完成了。 其他Hexo命令： hexo clean（清空资源文件，可选操作） hexo g （重新生成资源文件） 引用文章: 1.Hexo 发布文章到git.io步骤 - 程序男的专栏 - CSDN博客 2.hexo发布文章到个人博客上 - wl67920126的博客 - CSDN博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django中path和url的区别]]></title>
    <url>%2F2018%2F10%2F21%2FDjango%E4%B8%ADpath%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Django中path和url的区别django中url和path都是配置路径，有什么不同？ from django.urls import path from django.conf.urls import url path和url是两个不同的模块，效果都是响应返回界面，path调用的是python第三方模块或框架，而url则是自定义的模块。 例如： 1234url(r'^login', views.login)def login(request): return render(request, 'login.html') 引用自：Django中path和url的用法总结 当然，主要问题在于版本，1.x版本用url，2.x版本用path。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍]]></title>
    <url>%2F2018%2F04%2F25%2F%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Rilzob的个人blog随便写，随便看 邮箱： watermirrosir@163.com]]></content>
  </entry>
</search>
