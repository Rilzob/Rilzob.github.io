<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python中的列表生成式]]></title>
    <url>%2F2018%2F11%2F05%2FPython%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python中的列表生成式顾名思义，列表生成式就是用来生成列表的特定语法形式的表达式。列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 语法格式基础语法格式1[exp for iter_var in iterable] 工作过程 迭代iterable中的每个元素； 每次迭代都先把结果赋值给iter_var，然后通过exp得到一个新的计算值； 最后所有通过exp得到的计算值以一个新的列表的形式返回； 相当于： 123L = []for iter_var in iterable: L.append(exp) 带过滤功能的语法格式1[exp for iter_var in iterable if_exp] 工作过程 迭代iterable中的每个元素，每次迭代都先判断if_exp表达式是否成立，即判断将iter_var代入if_exp后表达式的结果，如果为真则进行下一步，如果为假则进行下一次迭代； 把迭代结果赋值给iter_var，然后通过exp得到一个新的计算值； 最后把所有通过exp得到的计算值以一个新列表的形式返回； 相当于： 1234L = []for iter_var in iterable: if_exp: L.append(exp) 循环嵌套的语法格式1[exp for iter_var_A in iterable_A for iter_var_B in iterable_B] 工作过程 迭代iterable_A中的每个元素，但是每迭代iterable_A中的一个元素，就把iterable_B中的所有元素都迭代一遍； 将每次迭代的变量iterable_var_A和iterable_var_B传入表达式exp(当然可以只传入两者之一)，计算出结果； 最后把所有通过exp得到的结果以一个新的列表的形式返回； 应用场景其实列表生成式是Python中的一种“语法糖”，也就是说列表生成式是Python提供的一种生成列表的简洁形式，应用列表生成式可以快速生成一个新的list。它最主要的应用场景是：根据已存在的可迭代对象推导出一个新的list。 使用实例我们可以对几个生成列表的要求分别通过“不使用列表生成式”和“使用列表生成式”来实现，然后做个对比总结。 实例1：生成一个从3到10的数字列表12345# 不使用列表生成式list1 = list(range(3, 11))# 使用列表生成式list2 = [x for x in range(3, 11)] 实例2：生成一个2n+1的数字列表，n为从3到10的数字1234567# 不使用列表生成式list3 = []for n in range(3, 11): list3.append(2*n + 1) # 使用列表生成式list4 = [2*n + 1 for n in range(3, 11)] 实例3：过滤出指定的数字列表中的值大于20的元素123456789L = [3, 7, 11, 14, 19, 33, 26, 57, 99]# 不使用列表生成式list5 = []for x in L: if x &lt; 20: list5.append(x) # 使用列表生成式list6 = [x for x in L if x &lt; 20] 实例4：计算两个集合的全排列，并将结果保存至一个新的列表中1234567891011L1 = ['香蕉', '苹果', '橙子']L2 = ['可乐', '牛奶']# 不使用列表生成式list7 = []for x in L1: for y in L2: list7.append((x,y)) # 使用列表生成式list8 = [(x,y) for x in L1 for y in L2] 实例5：将一个字典转换成由一组元组组成的列表，元组的格式为(key, value)12345678910D = &#123;'Tom': 15, 'Jerry': 18, 'Peter': 13&#125;# 不使用列表生成式list9 = []for k, v in D.items(): list9.append((k, v)) # 使用列表生成式list10 = []list10 = [(k, v) for k, v in D.items()] 可见，在一些情况下使用列表生成式确实要方便、简洁很多，使用一行代码就搞定了。 列表生成式与map、filter等高阶函数对比列表生成式的功能与之前文章提到的map()和filter()高阶函数功能很像，比如下面两个例子： 实例1：把一个列表中所有的字符串转换为小写，非字符串元素保留原样123456L = ['TOM', 'Peter', 10, 'Jerry']# 用列表生成式实现list1 = [x.lower() if isinstance(x, str) else x for x in L]# 用map()函数实现list2 = list(map(lambda x : x.lower() if isinstance(x, str) else x, L)) 实例2：把一个列表中所有的字符串转换为小写，非字符串元素移除1234567L = ['TOM', 'Peter', 10, 'Jerry']# 用列表生成式实现list3 = [x.lower() for x in L if isinstance(x, str)] # 注意：这里for x in L相对if isinstance的先后位置，与上一个示例相比较# 用map()和filter()函数实现list4 = list(map(lambda x: x.lower(), filter(lambda x: isinstance(x, str), L))) 对于大部分需求来讲，使用列表生成式和使用高阶函数都能实现。但是map和filter等一些高阶函数在Python3.x中的返回值类型变成了Iterator(迭代器)对象，这对于那些元素数量很大或无限的可迭代对象来说显然是更合适的，因为可以避免不必要的内存空间浪费。 引用文章： Python之列表生成式、生成器、可迭代对象与迭代器 - 云游道士 - 博客园 列表生成式 - 廖雪峰的官方网站]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的装饰器]]></title>
    <url>%2F2018%2F11%2F04%2FPython%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Python中的装饰器装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。 它经常用于有切面需求的场景，比如：插入日志、性能检测、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能无关的雷同代码并继续重用。概括地讲，装饰器的作用就是为已经存在对象添加额外的功能。 先看一个简单例子： 12def foo(): print('i am foo') 现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码： 1234import loggingdef foo(): print('i am foo') logging.info("foo is running") 如果有些函数也有类似的需求，怎么做？都写一个logging在函数内？这样就造成了大量雷同的代码，为了减少重复写代码，可以这么做，重新定义一个函数专门处理日志，日志处理完之后再执行真正的业务代码： 123456789101112def use_logging(func): logging.warning("%s is running" % func.__name__) func() def bar(): print('i am bar')use_logging(bar)# output:# WARNING:root:bar is running# i am bar 逻辑上不难理解，但这样的话，我们每次都要将一个函数作为参数传递给use_logging函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行bar()，但是现在不得不改成use_logging(bar)。那么有没有更好的方式呢？当然有，答案就是装饰器。 简单装饰器123456789101112131415def use_logging(func): def wrapper(*args, **kwargs): logging.warning("%s is running" % func.__name__) return func(*args, **kwargs) return wrapperdef bar(): print('i am bar') bar = use_logging(bar)bar()# output:# WARNING:root:bar is running# i am bar 函数use_logging就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像bar被logging包起来，被装饰了。在这个例子中，函数进入和退出时，被称为一个横切面(Aspect)，这种编程方法称为面向切面的编程(Aspect-Oriented Programming)。 @符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作。 12345678910111213141516171819def use_logging(func): def wrapper(*args, **kwargs): logging.warning("%s is running" % func.__name__) return func(*args) return wrapper@use_loggingdef foo(): print('i am foo') @use_loggingdef bar(): print('i am bar') bar()# output:# WARNING:root:bar is running# i am bar 如上所示，使用@符号我们就可以省去bar = use_logging(bar)这一句了，直接调用bar()即可得到想要的结果。如果我们有其他的类似函数，我们就可以继续调用装饰器来修饰函数，而不用重新修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。 装饰器在Python中使用如此方便都要归功于Python的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他的变量，可以作为返回值，可以被定义在另一个函数内。 带参数的装饰器装饰器还有更大的灵活性，例如带参数的装饰器：在上面的装饰器调用中，比如@use_logging，该装饰器唯一的参数就是执行业务的函数。装饰器的语法云溪我们在调用时，提供其他参数比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。 123456789101112131415161718def use_logging(level): def decorator(func): def wrapper(*args, **kwargs): if level == "warn": logging.warning("%s is running" % func.__name__) return func(*args) return wrapper return decorator@use_logging(level="warn")def foo(name='foo'): print("i am %s" % name) foo()# output:# WARNING:root:bar is running# i am bar 上面的use_logging是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我们使用@use_logging(level=&quot;warn&quot;)调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。 类装饰器再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大，高内聚，封装性等优点。使用类装饰器还可以依赖类内部的__call__方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。 12345678910111213141516171819class Foo(object): def __init__(self, func): self._func = func def __call__(self): print('class decorator running') self._func() print('class decorator ending') @Foodef bar(): print('bar') bar()# output:# class decorator running# bar# class decorator ending functools.wraps使用装饰器极大地复用了代码，但是它有个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子： 装饰器： 12345def logged(func): def with_logging(*args, **kwargs): print(func.__name__ + "was called") return func(*args, **kwargs) return with_logging 函数： 1234@loggeddef f(x): '''do some math''' return x + x * x 该函数完全等价于： 12345def f(x): '''do some math''' return x + x * xf = logged(f) 不难发现，函数f被with_logging替代了，当然它的docstring、__name__就变成了with_logging函数的信息了。 123456print(f.__name__)print(f.__doc__)# output:# with_logging# None 这个问题就比较严重了，好在我们有function.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了。 12345678910111213141516171819from functools import wrapsdef logged(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + "was called") return func(*args, **kwargs) return with_logging@loggeddef f(x): '''do some math''' return x + x * xprint(f.__name__)print(f.__doc__)# output:# f# do some math 内置装饰器@staticmethod、@classmethod、@property 装饰器的顺序： 1234@a@b@cdef f(): 等效于 1f = a(b(c(f))) 引用资料： 如何理解Python装饰器？ - 知乎]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的Lambda函数及其用法]]></title>
    <url>%2F2018%2F11%2F01%2FPython%E4%B8%AD%E7%9A%84Lambda%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中的Lambda函数及其用法Lambda函数又称为匿名函数，匿名函数就是没有名字的函数。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就可以将其定义为匿名函数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。 先来看个简单的lambda函数： 12&gt;&gt;&gt; lambda x, y : x + y&lt;function &lt;lambda&gt; at 0x102bc1c80&gt; x和y是函数的两个参数，冒号后面的表达式是函数的返回值，很明显这个匿名函数就是在求两个变量的和，但作为一个函数，没有名字如何使用呢？ 这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能。 12345&gt;&gt;&gt; add = lambda x, y : x+y&gt;&gt;&gt; add&lt;function &lt;lambda&gt; at 0x102bc2140&gt;&gt;&gt;&gt; add(1,2)3 它等同于常规函数 1234567&gt;&gt;&gt; def add1(x, y):... return x+y...&gt;&gt;&gt; add1&lt;function add1 at 0x102bc1c80&gt;&gt;&gt;&gt; add1(1,2)3 lambda函数的使用场景(函数式编程)sorted函数例如：一个整数列表，要求按照列表中元素的绝对值大小升序排列。 123&gt;&gt;&gt; list1 = [3,5,-4,-1,0,-2,-6]&gt;&gt;&gt; sorted(list1, key=lambda x: abs(x))[0, -1, -2, 3, -4, 5, -6] 排序函数sorted支持接收一个函数作为参数，该参数作为sorted的排序依据，这里按照列表元素的绝对值进行排序。 当然，也可以通过普通函数来实现： 12345&gt;&gt;&gt; def foo(x):... return abs(x)...&gt;&gt;&gt; sorted(list1, key=foo)[0, -1, -2, 3, -4, 5, -6] 只不过是使用这种方式，代码看起来不够Pythonic而已。 lambda：这是Python支持的一种有趣的语法，它允许你快速定义单行的最小函数，可以用在任何需要函数的地方: 12345&gt;&gt;&gt; add = lambda x,y : x+y&gt;&gt;&gt; add(5,6)11&gt;&gt;&gt; (lambda x,y:x+y)(5,6)11 map,reduce,filter函数123456789101112# 求1~20的平方&gt;&gt;&gt; list(map(lambda x:x*x,range(1,21))) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]# 求1~20之间的偶数&gt;&gt;&gt; list(filter(lambda x:x%2 == 0,range(1,21))) [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]# 求1~100之和,再加上10000&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x,y:x+y,range(1,101),10000)15050 闭包闭包：一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域也依然能被访问到。 看一个用lambda函数作为闭包的例子： 123456&gt;&gt;&gt; def add(n):... return lambda x:x+n # 将匿名函数作为返回值返回...&gt;&gt;&gt; add2 = add(5)&gt;&gt;&gt; add2(15)20 这里的lambda函数就是一个闭包，在全局作用域范围中，add2(15)可以正常执行且返回值为20。之所以返回20是因为在add局部作用域中，变量n的值在闭包的作用下也可以被访问到。 参考资料 匿名函数 - 廖雪峰的官方网站 深入理解Lambda函数及其用法 - 碧水幽幽泉 - 博客园]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中的高阶函数]]></title>
    <url>%2F2018%2F10%2F29%2FPython%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python中的高阶函数在熟悉了Python基础知识后，我们已经可以做一些脚本开发，或者简单的程序。然而，当我们开发较为复杂的程序时，仅使用基础知识内容就会显得比较吃力。这时，了解Python中的一些高级特性会使我们的开发过程变得简单和快乐。 在函数式编程中，我们可以将函数当做变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为高阶函数(Higher-order-Functions)。 看一个简单的例子： 12def func(g, arr): return [g(x) for x in arr] 上面的代码中func是一个高阶函数，它接收两个参数，第一个参数是函数，第二个参数是数组，func的功能是将函数g逐个作用于数组arr上，并返回一个新的数组。比如，我们可以这样用： 123456789def double(x): return 2 * x def square(x): return x * xlist = [1, 2, 3, 4]arr1 = func(double, list) # arr1 = [2, 4, 6, 8]arr2 = func(square, list) # arr2 = [1, 4, 9, 16] 说到高阶函数，就不得不提到闭包，这里介绍一下Python中闭包的定义： 如果在一个内部函数里，对外部作用域(但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包(closure)。 就拿此例来说，内部函数double中包含了对函数func中局部变量list的引用，这就是闭包。 map reduce filter sorted是Python中较为常用的内置高阶函数，它们为函数式编程提供了不少便利。 说明：本文介绍的内置高阶函数的定义可能会因为Python版本的不同而有所不同，文章以Python3.x版本中的定义为标准。 mapmap函数的使用形式如下： 1map(function, iterable, ...) 注意：这里函数一定要作为map的第一个参数，而不是第二个参数，否则会产生报错。 解释：function函数会作用于可迭代对象的每一个元素，生成结果，并返回一个迭代器。更加具体一点说就是map函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到Iterable的每个元素，并把结果作为新的Iterator返回。 举例说明，比如我们一个函数f(x)=x^2，要把这个函数作用在一个list[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现。 现在，我们用Python代码实现： 123456&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] map传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此需要通过list()函数让它把整个序列都计算出来并返回一个list。 你可能会想，不需要map函数，写一个循环，也可以计算出结果： 1234L = []for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: L.append(f(n))print(L) 的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？明显可读性就差了很多。 所以，map作为高阶函数，体现了Python的设计原则优雅、明确、简单，事实上它把运算规则抽象化。因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把list中的所有数字转化为字符串格式： 12&gt;&gt;&gt; list(map(str, [1, 2, 3, 4]))['1', '2', '3', '4'] 只需一行代码。 看一些简单的例子： 12345678910111213&gt;&gt;&gt; def square(x):... return x * x&gt;&gt;&gt; map(square, [1, 2, 3, 4])&lt;map at 0x106adfe48&gt;&gt;&gt;&gt; list(map(square, [1, 2, 3, 4]))[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4])) # 使用 lambda[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x, y: x + y, [1, 2, 3, 4], [5, 6, 7, 8]))[6, 8, 10, 12] 再来看个复杂一点例子： 1234567891011121314151617def double(x): return 2 * xdef triple(x): return 3 *xdef square(x): return x * xfuncs = [double, triple, square] # 列表元素是函数对象# 相当于 [double(4), triple(4), square(4)]value = list(map(lambda f: f(4), funcs))print(value)output:[8, 12, 16] 最后我想要说明一点，迭代器有一个特点，就是所有的迭代器对象都可以作为next()内置函数的参数调用，每调用一次，就按角标顺序返回一个值，还是用代码讲吧： 123456iter = map(lambda x: x * x, [1, 2, 3, 4])print(next(iter)) # 打印值为：1print(next(iter)) # 打印值为：4print(next(iter)) # 打印值为：9print(next(iter)) # 打印值为：16print(next(iter)) # 抛出StopIteration 异常 reducereduce函数的使用形式如下： 1reduce(function, iterable[, initializer]) 解释：reduce函数必须接受两个参数，先将iterable的前两个item传给function，即function(item1, item2)，函数的返回值和iterable的下一个item再传给function，即function(function(item1, item2), item3)，如此迭代，直到iterable没有元素，如果有initializer，则作为初始值调用。 也就是说： 12reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)# 列表中是以从左到右作为优先顺序 看一些例子，就能很快理解了。 12345678910111213&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4]) # 相当于 ((1 * 2) * 3) * 424&gt;&gt;&gt; reduce(lambda x, y: x - y, [8, 5, 1], 20) # ((20 - 8) - 5) - 16&gt;&gt;&gt; f = lambda a, b: a if (a &gt; b) else b # 两两比较，取最大值&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])10&gt;&gt;&gt; def fn(x, y): # 把序列[1, 3, 5, 7, 9]变换成整数13579... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 filterfilter函数用于过滤元素，它的使用形式如下： 1filter(function, iterable) 解释：和map类似，filter也接收一个函数和一个序列。但和map不同的是，filter把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。将function依次作用于iterable的每个item上，即function(item)，用function返回值为True的item构成iterator作为filter的最终返回值。 看一些例子。 12345678910&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; even_num[2, 4, 6]&gt;&gt;&gt; odd_num = list(filter(lambda x: x % 2, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; odd_num[1, 3, 5]&gt;&gt;&gt; list(filter(lambda x: x &lt; 'g', 'hijack'))'ac'&gt;&gt;&gt; filter(lambda x: x &lt; 'g', 'hijack')&lt;filter object at 0x1034b4080&gt; # python3 可见用filter这个高阶函数，关键在于正确实现一个“筛选”函数。 注意到filter函数返回的同样是一个Iterator，也就是一个惰性序列，所以要强迫filter完成计算结果，需要用list()函数获得所有结果。 sortedsorted函数用于对list进行排序，它的使用形式如下： 1sorted(iterable, *, key=None, reverse=False) 解释：sorted有两个可选参数，必须指定为关键字参数。将key指定的函数作用于iterable的每一个元素上，并根据key函数返回的结果进行排序，最终返回一个新的排序列表。key默认值为None，即直接比较元素大小。 reverse是一个布尔值。如果设置为True，则列表元素将按照比较结果相反的方式进行排序。 看一些例子： 12345678910&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob']&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo']&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且核心代码可以保持得非常简洁。 小结 可接受其他函数作为参数的函数称为高阶函数； map reduce filter sorted为函数式编程提供了不少便利，可使代码变得更简洁； 通过map()来对Iterable中的每个元素进行相同的函数处理最终返回一个Iterator。 reduce()类似栈的思想，先让栈顶的两个元素出栈作为函数的两个参数，再将函数的返回值入栈，然后再让栈顶两个元素出栈，不断循环下去，直到栈里没有元素为止。 filter()的作用是从一个序列中筛选出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。 sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。 参考资料 高阶函数 - 廖雪峰的官方网站 map/reduce/filter - Python 之旅 - 极客学院Wiki 高阶函数 - Python 之旅 - 极客学院Wiki Python笔记(二)：高级特性之高阶函数 - 简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中@classmethod和@staticmethod的区别]]></title>
    <url>%2F2018%2F10%2F27%2FPython%E4%B8%AD%40classmethod%E5%92%8C%40staticmethod%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中@classmethod和@staticmethod的区别接上一篇介绍Python中@staticmethod和@classmethod的用法的文章。虽然@classmethod和@staticmethod非常相似，但两个修饰符的使用情况仍略有不同。 从它们的使用上来看： @classmethod必须引用一个类对象作为第一个参数，即第一个参数需要是表示自身类的cls参数。同时@classmethod因持有cls参数，所以可以调用类的属性，类的方法，实例化对象等，避免硬编码。 @staticmethod则可以完全没有参数，但在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名()。 示例1234567891011121314151617181920class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split("-")) date1 = cls(day, month, year) return date1 @staticmethod def is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split("-")) return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999 date2 = Date.from_string("27-10-2018")is_date = Date.is_date_valid("27-10-2018") 解释让我们假设这样一个类的例子，用来处理日期信息(这将是我们的样板)： 12345class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year 显然，这个类可以用来存储关于某些日期的信息(没有时区信息；假设所有日期都以UTC表示)。 这个类中有__init__，它是Python类实例的初始化方法，它接收参数作为类实例方法，具有第一个非可选参数self(作为对新创建实例的引用)。 Class Method我们有一些任务，通过使用@classmethod可以很好地完成它们。 假设我们想要创建许多Date类实例，其日期信息来自外部输入(编码格式为’dd-mm-year’的字符串)，并假设我们必须在项目源代码的不同位置执行此操作。 所以我们这里必须做到： 解析输入的字符串以接收日、月、年作为三个整数变量或由这些变量组成的三元组。 通过将上面求到的值传递给初始化调用来创建Date类实例。 代码看起来会是这样： 12day, month, year = map(int, string_date.split('-'))date1 = Date(day, month, year) 如果使用@classmethod修饰符写在类中，将会是： 1234567 @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split('-')) date1 = cls(day, month, year) return date1date2 = Date.from_string('27-10-2018') 让我们更仔细地看看上面的代码实现，并回想一下我们做了什么？ 我们在一个地方实现了日期字符串解析函数，现在它可以重用。 将日期字符串解析函数封装在类中并且工作正常(当然你可以在其他地方实现日期字符串解析作为单个函数，但这个解决方案更适合OOP范例)。 cls是一个保存类本身的对象，而不是类的实例。这很酷😎，因为如果我们继承Date类，所有子类也会定义from_string()。 Static Method@staticmethod确实与@classmethod很相似，但@staticmethod不需要任何强制性参数(如类方法或实例方法)。 让我们看看下一个任务(下一个用例): 假设我们有一个日期字符串，我们想要以某种方式进行验证它是否符合要求的格式。此任务也需要封装在Date类中，但不需要实例化它。 这里使用@staticmethod就会很有效。让我们看一下代码： 1234567@staticmethoddef is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split('-')) return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999# usage:is_date = Date.is_date_valid('27-10-2018') 运行上述代码得到is_date是个boolen型变量，而非is_date_valid函数返回的day，month，year三个整型数据。 因此，我们可以从@staticmethod的使用中看到，我们无法访问类的内容——它基本上只是一个函数，在语法上称为方法，无法访问对象及其内部(字段和其他类方法)。而使用@classmethod却可以做到。 补充上面的文章已经很全面地总结了@classmethod和@staticmethod的区别。在这里我想强调当你创建构造函数时，你应该选择@classmethod而不是@staticmethod的另一个原因。在上面的例子中，使用@classmethod from_string()作为Factory，接收不符合__init__要求的参数创建Date类实例。使用@staticmethod可以完成同样的操作，如下面代码所示： 12345678910111213141516171819202122class Date: def __init__(self, month, day, year): self.month = month self.day = day self.year = year def display(self): return "&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format(self.month, self.day, self.year) @staticmethod def millenium(month, day): return Date(month, day, 2000)new_year = Date(1, 1, 2013) # Creates a new Date objectmillenium_new_year = Date.millenium(1, 1) # also creates a Date object. # Proof:new_year.display() # "1-1-2013"millenium_new_year.display() # "1-1-2000"isinstance(new_year, Date) # Trueisinstance(millenium_new_year, Date) # True 运行结果显示new_year和millenium_new_year都是Date类实例。 但是，如果仔细观察就会发现，millenium_new_year是以硬编码的方式创建的Date类实例。这意味着即使一个类继承Date类，该子类仍将创建普通的Date对象即父类对象，而不具有该子类本身的任何属性。请参阅以下示例代码： 12345678910111213class DateTime(Date): def display(self): return "&#123;0&#125;-&#123;1&#125;-&#123;2&#125; - 00:00:00PM".format(self.month, self.day, self.year)datetime1 = DateTime(10, 10, 1990)datetime2 = DateTime.millenium(10, 10)isinstance(datetime1, DateTime) # Trueisinstance(datetime2, DateTime) # Falsedatetime1.display() # returns "10-10-1990 - 00:00:00PM"datetime2.display() # returns "10-10-2000" because it's not a DateTime object but a Date object. Check the implementation of the millenium method on the Date class DateTime类继承Date类，因此具有Date类的millenium()方法。datetime2通过调用DateTime继承来的millenium()方法来创建DateTime类实例。然而代码却显示datetime2并不是DateTime类实例(isinstance(datetime2, DateTime) # False)。怎么回事？这是因为使用了@staticmethod修饰符。 在大多数情况下，这是你不希望出现的。如果你想要的是一个”完整“的类实例，并且是通过调用它的父类方法所创建的话，那么@classmethod就是你所需要的。 将Date.millenium()重写为(这是上述代码中唯一改变的部分)： 123@classmethoddef millenium(cls, month, day): return cls(month, day, 2000) 确保该类的创建不是通过硬编码。cls可以是任何子类，生成的对象将正确地成为cls的实例。我们来试试吧： 123456789datetime1 = DateTime(10, 10, 1990)datetime2 = DateTime.millenium(10, 10)isinstance(datetime1, DateTime) # Trueisinstance(datetime2, DateTime) # Truedatetime1.display() # "10-10-1990 - 00:00:00PM"datetime2.display() # "10-10-2000 - 00:00:00PM" 看吧，用@classmethod替代@staticmethod你不希望出现的情况就会消失。使用了@staticmethod修饰符定义构造函数就是问题出现的关键。 文章的内容有点多，可能需要花一些时间进行理解，最后提供一个小示例帮助大家加深记忆一下@classmethod和@staticmethod的主要不同。 1234567891011121314151617181920212223242526class A(object): bar = 1 def foo(self): print 'foo' @staticmethod def static_foo(): print 'static_foo' print A.bar @classmethod def class_foo(cls): print 'class_foo' print cls.bar cls().foo() A.static_foo()A.class_foo()output:static_foo1class_foo1foo 引用文章： 飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客 python - Meaning of @classmethod and @staticmethod for beginner? - Stack Overflow]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中@staticmethod和@classmethod的用法]]></title>
    <url>%2F2018%2F10%2F27%2FPython%E4%B8%AD%40staticmethod%E5%92%8C%40classmethod%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中@staticmethod和@classmethod的用法一般来说，调用某个类的方法，需要预先生成一个实例，再通过实例调用方法。Java中有静态方法，可以使用类直接进行调用。Python中提供了两个修饰符@staticmethod和@classmethod以达到类似效果，使用它们就可以不需要实例化，直接类名.方法名()来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类中，同时有利于命名空间的整洁。 @staticmethod@staticmethod声明方法为静态方法，直接通过类名.方法名()调用。经过@staticmethod修饰的方法，不需要self参数，其使用方法和直接调用函数一样。 1234567891011121314151617181920#直接定义一个test()函数def test(): print "i am a normal method!" #定义一个类，其中包括一个类方法，采用@staticmethod修饰 class T: @staticmethod def static_test(): # 没有self参数 print "i am a static method!" if __name__ == "__main__": test() T.static_test() T().static_test()output:i am a normal method!i am a static method!i am a static method! @classmethod@classmethod声明方法为类方法，直接通过类名.方法名()调用。经过@classmethod修饰的方法，不需要self参数，但是需要一个标识类本身的cls参数。 12345678910111213class T: @classmethod def class_test(cls): # 必须有cls参数 print "i am a class method" if __name__ == "__main__": T.class_test() T().class_test()output:i am a class methodi am a class method @classmethod另一个实用的用法：在不改变已经写好的类里面的方法的情况下，对输入的数据进行处理。 12345678910111213141516# 输出年月日，正常的情况下class demo1: def __init__(self, year=0, month=0, day=0): self.year = year self.month = month self.day = day def out_date(self): return "year: %d, month: %d, day: %d" % (self.year, self.month, self.day) year = 2018month = 10day = 27demo1 = demo1(year, month, day)print(demo1.out_date()) # year: 2018, month: 10, day: 27 1234567891011121314151617181920212223242526# 如果用户输入的是2018-10-27格式，需要在输出前处理一下，就可以使用classmethod达到想要的效果class demo2: def __init__(self, year=0, month=0, day=0): self.year = year self.month = month self.day = day def out_date(self): return "year: %d, month: %d, day: %d" % (self.year, self.month, self.day) @classmethod def pre_out(cls, date_string): year, month, day = map(int, date_string.split("-")) return cls(year, month, day) date = "2018-10-27"year = 2017month = 7day = 7try: demo2 = demo2.pre_out(date)except: demo2 = demo2(year, month, day) print(demo2.out_date()) # year: 2018, month: 10, day: 6 小结 @staticmethod不需要表示自身对象的self参数和自身类的cls参数，就跟使用函数一样。 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 在Python中类和实例都是对象，都占用了内存空间，合理使用@staticmethod和@classmethod修饰符，就可以不经过实例化直接使用类的方法了。 引用文章： Python @staticmethod@classmethod用法 - sinat_34079973的博客 - CSDN博客 飘逸的python - @staticmethod和@classmethod的作用与区别 - mattkang - CSDN博客 classmethod的两个实用用法 - 简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中super()函数的用法及其说明]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E4%B8%ADsuper()%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中super()函数的用法及其说明为了调用父类(超类)的一个方法，可以使用super()函数，比如： 12345678class A: def spam(self): print('A.spam')class B(A): def spam(self): print('B.spam') super().spam() # Call parent spam() super()函数的一个常见用法是在__init__()中确保父类被正确的初始化： 12345678class A: def __init__(self): self.x = 0class B(A): def __init__(self): super().__init__() self.y = 1 说明__init__()函数：定义类的时候，若是添加__init__()函数，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初始化。 super()的另外一个常见用法出现在覆盖Python特殊方法的代码中，比如： 1234567891011121314class Proxy: def __init__(self, obj): self._obj = obj # Delegate attribute lookup to internal obj def __getattr__(self, name): return getattr(self._obj, name) # Delegate attribute assignment def __setattr__(self, name, value): if name.startswith('_'): super().__setattr__(name, value) # Call original __setattr__ else: setattr(self._obj, name, value) 实际上，大家对于在Python中如何正确使用super()函数普遍知之甚少。你有时候会看到像下面这样直接调用父类的一个方法： 12345678class Base: def __init__(self): print('Base.__init__')class A(Base): def __init__(self): Base.__init__(self) print('A.__init__') 尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。比如，考虑下面的情况： 12345678910111213141516171819class Base: def __init__(self): print('Base.__init__')class A(Base): def __init__(self): Base.__init__(self) print('A.__init__')class B(Base): def __init__(self): Base.__init__(self) print('B.__init__')class C(A,B): def __init__(self): A.__init__(self) B.__init__(self) print('C.__init__') 运行这段代码后就会发现Base.__init__被调用两次，如图所示： 123456&gt;&gt;&gt; c = C()Base.__init__A.__init__Base.__init__B.__init__C.__init__ 可能两次调用Base.__init__()没什么坏处，但有时候却不是。另一方面，假设在代码中换成使用super()，结果就很完美了： 123456789101112131415161718class Base: def __init__(self): print('Base.__init__')class A(Base): def __init__(self): super().__init__() print('A.__init__')class B(Base): def __init__(self): super().__init__() print('B.__init__')class C(A,B): def __init__(self): super().__init__() # Only one call to super() here print('C.__init__') 运行这个新版本后，你会发现Base.__init__()方法只会被调用一次： 12345&gt;&gt;&gt; c = C()Base.__init__B.__init__A.__init__C.__init__ 所以说，super()是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序(MRO)、重复调用(钻石继承)等种种问题。 说明：MRO就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表，下面会有更详尽的介绍。 为了弄清它的原理，我们需要花点时间解释下Python是如何实现继承的。对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。这个MRO列表就是一个简单的所有基类的线性顺序表。例如： 123&gt;&gt;&gt; C.__mro__(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;) 为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则： 子类会先于父类被检查 多个父类会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择，选择第一个父类 老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。 当你使用super()函数时，Python会在MRO列表上继续搜索下一个类。只要每个重定义的方法统一使用super()并只调用它一次，那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。这也是为什么在第二个例子中你不会调用两次Base.__init__()的原因。 super()有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类，你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类： 1234class A: def spam(self): print('A.spam') super().spam() 如果你试着直接使用这个类就会出错： 1234567&gt;&gt;&gt; a = A()&gt;&gt;&gt; a.spam()A.spamTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 4, in spamAttributeError: 'super' object has no attribute 'spam' 但是，如果你使用多继承的话看看会发生什么： 1234567891011&gt;&gt;&gt; class B:... def spam(self):... print('B.spam')...&gt;&gt;&gt; class C(A,B):... pass...&gt;&gt;&gt; c = C()&gt;&gt;&gt; c.spam()A.spamB.spam 你可以看到在类A中使用super().spam()实际上调用的是与类A毫无关系的类B中的spam()方法。这个用类C的MRO列表就可以完全解释清楚： 123&gt;&gt;&gt; C.__mro__(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,&lt;class 'object'&gt;) 在定义混入类的时候这样使用super()是很普遍的。 然而，由于super()可能会调用不是你想要的方法，你应该遵循一些通用原则。首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。这样可以确保super()调用一个非直接父类方法时不会出错。其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。 在Python社区内对于super()的使用有时候会引来一些争议。尽管如此，如果一切顺利的话，你应该在你最新的代码中使用它。Raymond Hettinger为此写了一篇非常好的文章，有兴趣的话可以去查查看，文章通过大量的例子向我们解释了为什么super()是极好的。 最后通过一个很好的实例帮助大家加深一下记忆： 12345678910111213141516171819202122class FooParent(object): def __init__(self): self.parent = 'I\'m the parent.' print ('Parent') def bar(self,message): print ("%s from Parent" % message) class FooChild(FooParent): def __init__(self): # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类B的对象 FooChild 转换为类 FooParent 的对象 super(FooChild,self).__init__() print ('Child') def bar(self,message): super(FooChild, self).bar(message) print ('Child bar fuction') print (self.parent) if __name__ == '__main__': fooChild = FooChild() fooChild.bar('HelloWorld') 执行结果： 12345ParentChildHelloWorld from ParentChild bar fuctionI&apos;m the parent. 引用文章： Python super() 函数 | 菜鸟教程 8.7 调用父类方法 — python3-cookbook 3.0.0 文档]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用攻略：添加搜索功能]]></title>
    <url>%2F2018%2F10%2F26%2FHexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Hexo使用攻略：添加搜索功能本教程针对的是Mac环境 前言当博文越来越多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博文上去了，所以添加一个站内搜索功能是很有必要的。 Hexo适配多款搜索插件，个人感觉”Local Search”已满足日常需要，所以下面介绍为Hexo添加”Local Search”搜索插件的过程。 安装插件在命令行中cd到自己的hexo文件夹下(例：/Users/rilzob/hexo)，执行npm install hexo-generator-searchdb --save命令进行安装，等待安装完成。 修改站点配置文件修改当前目录下的_config.yml文件(例：/Users/rilzob/hexo/_config.yml)，新增以下内容到该文件内的任意位置。 123456# Searchsearch: path: search.xml field: post format: html limit: 10000 注意：每个冒号后面都有空格 修改主题配置文件修改主题目录下的_config.yml文件(例：/Users/rilzob/hexo/themes/xxx/_config.yml)，找到该文件内的 1234# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: false 代码段，将其修改为： 1234# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true 即将enable: false修改为enable: true。 重新部署依旧在命令行中进行操作，在hexo文件夹下依次执行hexo g,hexo server和hexo deploy指令即可。这样搜索功能就添加成功了。 引用文章: 1.Hexo博客添加搜索功能 | IT范儿 2.hexo博客添加搜索功能 - qq_40265501的博客 - CSDN博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用攻略：添加分类及标签]]></title>
    <url>%2F2018%2F10%2F25%2FHexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Hexo使用攻略：添加分类及标签本教程针对的是Mac环境 Hexo创建”分类”选项生成”分类”页并添加type属性 打开命令行，cd进入博客所在文件夹。执行命令hexo new page categories，来新建一个页面，并命名为categories。成功后会提示：INFO Created: ~/hexo/source/categories/index.md 根据上面的路径找到index.md这个文件，打开后默认内容如下： 1234---title: categoriesdate: 2018-10-25 20:11:37--- 编辑新创建的页面，添加type: &quot;categories&quot;到内容中(注意，这些属性和属性值之间必须有一个空格)，主题将自动为这个页面显示所有分类，添加后是这样的： 12345---title: categoriesdate: 2018-10-25 20:11:37type: &quot;categories&quot;--- 保存并关闭文件。 给文章添加”categories”属性 打开需要添加分类的文章，为其添加categories属性。下方的categories: Python表示添加这篇文章到“Python”这个分类中。 注意：Hexo中一篇文章只能属于一个分类，也就是说如果在”Python”下方添加”-xxx”，Hexo不会产生两个分类，而是把分类嵌套，即该文章属于”Python“下的”-xxx“分类。 1234---title: Python中*args和**kwargs的用法总结categories: Python--- 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加分类选项 cd进/hexo/themes/hexo-theme-next-5.1.4文件夹内，编辑该目录下的_config.yml文件(把链接加上)，将源代码: 12345678910111213menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 改为: 12345678910111213menu: home: / || home #about: /about/ || user #tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 即将menu中的categories:/categories || th的注释去掉，然后保存并退出。 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令，即可看到菜单栏中新增了一个Categories选项。 至此，成功给文章添加分类，点击Index上的Categories可以看到所有的分类情况，再点击该分类就可以看到该分类下的所有文章。当然，前提是添加了categories: xxx字段。 Hexo创建”标签”选项生成”标签”页并添加type属性 打开命令行，cd进入博客所在文件夹。执行命令hexo new page tags，来新建一个页面，并命名为tags。成功后会提示：INFO Created: ~/hexo/source/tags/index.md 根据上面的路径找到index.md这个文件，打开后默认内容如下： 1234---title: tagsdate: 2018-10-25 21:11:00--- 编辑新创建的页面，添加type: &quot;tags&quot;到内容中，主题将自动为这个页面显示所有分类，添加后是这样的： 12345---title: tagsdate: 2018-10-25 21:11:00type: &quot;tags&quot;--- 保存并关闭文件。 给文章添加”tags”属性 打开需要添加标签的文章，为其添加tags属性。下方的tags: Django表示添加这篇文章到“Django”这个标签中。 1234---title: Python中*args和**kwargs的用法总结tags: Django--- 回到hexo文件夹下，依次执行hexo g， hexo server和hexo deploy命令(重新部署)。 在Hexo菜单上添加标签选项 cd进/hexo/themes/hexo-theme-next-5.1.4文件夹内，编辑该目录下的_config.yml文件(把链接加上)，将源代码: 12345678910111213menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 改为: 12345678910111213menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 即将menu中的tags: /tags/ || tags的注释去掉，然后保存并退出。 回到hexo文件夹下，依次执行hexo g，hexo server和hexo deploy命令，即可看到菜单栏中新增了一个tags选项。 引用文章： 1.Hexo使用攻略-添加分类及标签 | linlif-blog 2.hexo怎么在菜单上添加页面和分类呢？ - SegmentFault 思否 3.hexo next 为文章添加分类 | 学而后知不足]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python中*args和**kwargs的用法总结]]></title>
    <url>%2F2018%2F10%2F25%2FPython%E4%B8%AD*args%E5%92%8C**kwargs%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%E7%9A%84%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Python中*args和**kwargs的用法总结一、基本概念Python支持可变参数，最简单的方法莫过于使用默认参数。 123456789101112131415def test_defargs(one, two=2): # 参数one没有默认值，two的默认值为2 print('Required argument:', one) print('Optional argument:', two) test_defargs(1)'''Required argument: 1Optional argument: 2'''test_defargs(1, 3)'''Required argument: 1Optional argument: 3''' 另一种达到可变参数(Variable Argument)的方法： 使用*args和**kwargs语法。 *args是可变的位置参数(postional arguments)列表； **kwargs是可变的关键词参数(keyword arguments)列表； 并且规定位置参数必须位于关键词参数之前，即*args必须位于**kwargs之前。 二、位置参数以下是用位置参数正确调用函数的实例： 12345678910def print_hello(name, sex): sex_dict = &#123;1: '先生', 2: '女士'&#125; print('Hello %s %s, welcome to Python World!' % (name, sex_dict.get(sex, '先生'))) # if no such a key, print '先生' print_hello('Chen', 2) # 位置参数要求先后顺序，对应name和sexprint_hello('Chen', 3) # 两个参数的顺序必须一一对应，且少一个参数都不可以'''Hello Chen 女士, welcome to Python World!Hello Chen 先生, welcome to Python World!''' 三、关键字参数用于函数调用，通过“键-值”形式加以指定。 使用关键字参数可以让函数更加清晰，容易使用，同时也清除了参数的顺序需求。 以下是用关键字参数正确调用函数的实例： 123print_hello('Chen', sex=1) # 有位置参数时，位置参数必须在关键字参数的前面# print_hello(1, name='Chen') # Python 3.x中这种写法是错误的print_hello(name='Chen', sex=1) # 关键字参数之间不存在先后顺序的,等价于print_hello(sex=1, name='Chen') 以下是错误的调用方式： 12# print_hello(name='Chen', 1) # 有位置参数时，位置参数必须在关键字参数前面# print_hello(sex=1, 'Chen') 四、可变参数顾名思义，可变参数就是传入的参数个数是可变的，可以是任意个。*args和**kwargs两者都是Python中的可变参数。 1.可变位置参数*argsPython中规定参数前带*的，称为可变位置参数，只是我们通常称这个可变位置参数为*args而已，叫其他的也是一样的。 以数学题为例，给定一组数字a，b，c……，请计算a^2 + b^2 + c^2 + ……。 要定义这个函数，必须确定输入的参数。由于参数个数不确定，我们可以首先想到把a，b，c……作为一个list或者tuple传进来，这样函数就可以定义为： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： 1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc([1, 3, 5, 7])84 所以，为了方便起见我们把函数的参数改为可变位置函数： 12345def calc(*numbers) # 可变位置参数 sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变位置参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt;calc(1,2)5&gt;&gt;&gt;calc()0 如果已经有一个list或tuple，要调用一个可变位置参数怎么办？可以这么做： 123&gt;&gt;&gt;nums = [1, 2, 3]&gt;&gt;&gt;calc(nums[0], nums[1], nums[2])14 这种做法当然是可行的，问题是太繁琐了，所以Python允许在list或tuple前面加一个*，把list或tuple的元素变成可变位置参数传进去： 123&gt;&gt;&gt;nums = [1, 2, 3]&gt;&gt;&gt;calc(*nums)14 总而言之，*args用来表示函数接收可变长度的非关键字参数列表作为函数的输入。我们可以通过以下这个例子进一步理解*args: 123456def test_args(normal_arg, *args): print('first normal arg:' + normal_arg) for arg in args: print('another arg through *args:' + arg) test_args("normal", "python", "java", "C#") 上面代码的执行结果如下： 1234first normal arg: normalanother arg through *args : pythonanother arg through *args : javaanother arg through *args :C# 2.可变关键字参数**kwargs同理，Python中规定参数前带 的，称为可变关键字参数，通常用kwargs表示。 **kwargs表示函数接收可变长度的关键字参数字典作为函数的输入。当我们需要函数接收带关键字的参数作为输入的时候，应当使用**kwargs。我们可以通过以下的例子进一步理解**kwargs: 123456789def test_kwargs(**kwargs): if kwargs is not None: for key, value in kwargs.iteritems(): print("&#123;&#125; = &#123;&#125;".format(key,value)) # Or you can visit kwargs like a dict() object # for key in kwargs: # print("&#123;&#125; = &#123;&#125;".format(key, kwargs[key])) test_kwargs(name="python", value="5") 以上代码的执行效果如下： 12name = pythonvalue = 5 以上例子只是*args和**kwargs基本使用的例子。下面再给出一个用*args和**kwargs来定义能够接受列表输入和字典输入的函数的例子。 3.使用*args和**kwargs来调用函数比如我们有如下接受普通输入参数的函数： 123456def normal_func(arg1, arg2, arg3): print("arg1: " + arg1) print("arg2: " + arg2) print("arg3: " + arg3)normal_func("python", 1, 3) 使用*args和**kwargs来调用这个函数的代码如下： 1234567# 使用*argsargs_list = ("python", 1, 3)normal_func(*args_list)# 使用**kwargskwargs_dict = &#123;"arg3": 3, "arg1": "python", "arg2": 1&#125;normal_func(**kwargs_dict) 以上三段代码的输出均为： 123arg1: pythonarg2: 1arg3: 3 引用文章： 1.Python中的 *args 和 **kwargs - 简书 2.函数的参数 - 廖雪峰的官方网站 3.python参数传递的*args和**kwargs - 简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过Hexo将文章上传到git.io的方法]]></title>
    <url>%2F2018%2F10%2F21%2F%E9%80%9A%E8%BF%87Hexo%E5%B0%86%E6%96%87%E7%AB%A0%E4%B8%8A%E4%BC%A0%E5%88%B0git.io%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通过Hexo将文章上传到git.io的方法 编辑文章，生成markdown文件，并将文章放到/hexo/source/_posts目录下，一个md文件对应一篇博客文章。 修改文章头部： 123456---title: #博客标题date: #博客发布时间tags: #博客分类标签categories: #博客目录--- 在命令行中cd到_posts目录下并执行hexo generate命令(生成静态页面)。 再执行hexo server命令(本地上传文章)，上传后可以到http://localhost:4000/ 预览博客效果。 最后执行hexo deploy命令，上传文章到github.io上就完成了。 其他Hexo命令： hexo clean（清空资源文件，可选操作） hexo g （重新生成资源文件） 引用文章: 1.Hexo 发布文章到git.io步骤 - 程序男的专栏 - CSDN博客 2.hexo发布文章到个人博客上 - wl67920126的博客 - CSDN博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django中path和url的区别]]></title>
    <url>%2F2018%2F10%2F21%2FDjango%E4%B8%ADpath%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Django中path和url的区别django中url和path都是配置路径，有什么不同？ from django.urls import path from django.conf.urls import url path和url是两个不同的模块，效果都是响应返回界面，path调用的是python第三方模块或框架，而url则是自定义的模块。 例如： 1234url(r'^login', views.login)def login(request): return render(request, 'login.html') 引用自：Django中path和url的用法总结 当然，主要问题在于版本，1.x版本用url，2.x版本用path。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍]]></title>
    <url>%2F2018%2F04%2F25%2F%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Rilzob的个人blog随便写，随便看 邮箱： watermirrosir@163.com]]></content>
  </entry>
</search>
